(function () {
  'use strict';

  var top = 'top';
  var bottom = 'bottom';
  var right = 'right';
  var left = 'left';
  var auto = 'auto';
  var basePlacements = [top, bottom, right, left];
  var start = 'start';
  var end = 'end';
  var clippingParents = 'clippingParents';
  var viewport = 'viewport';
  var popper = 'popper';
  var reference = 'reference';
  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []); // modifiers that need to read the DOM

  var beforeRead = 'beforeRead';
  var read = 'read';
  var afterRead = 'afterRead'; // pure-logic modifiers

  var beforeMain = 'beforeMain';
  var main = 'main';
  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

  var beforeWrite = 'beforeWrite';
  var write = 'write';
  var afterWrite = 'afterWrite';
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  function getNodeName(element) {
    return element ? (element.nodeName || '').toLowerCase() : null;
  }

  function getWindow(node) {
    if (node == null) {
      return window;
    }

    if (node.toString() !== '[object Window]') {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }

    return node;
  }

  function isElement$1(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }

  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }

  function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === 'undefined') {
      return false;
    }

    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // and applies them to the HTMLElements such as popper and arrow

  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function (name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name]; // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe[cannot-write]


      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (name) {
        var value = attributes[name];

        if (value === false) {
          element.removeAttribute(name);
        } else {
          element.setAttribute(name, value === true ? '' : value);
        }
      });
    });
  }

  function effect$2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: '0',
        top: '0',
        margin: '0'
      },
      arrow: {
        position: 'absolute'
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;

    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }

    return function () {
      Object.keys(state.elements).forEach(function (name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

        var style = styleProperties.reduce(function (style, property) {
          style[property] = '';
          return style;
        }, {}); // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }

        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  } // eslint-disable-next-line import/no-unused-modules


  var applyStyles$1 = {
    name: 'applyStyles',
    enabled: true,
    phase: 'write',
    fn: applyStyles,
    effect: effect$2,
    requires: ['computeStyles']
  };

  function getBasePlacement(placement) {
    return placement.split('-')[0];
  }

  var max$1 = Math.max;
  var min$1 = Math.min;
  var round = Math.round;

  function getUAString() {
    var uaData = navigator.userAgentData;

    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function (item) {
        return item.brand + "/" + item.version;
      }).join(' ');
    }

    return navigator.userAgent;
  }

  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }

    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }

    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;

    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }

    var _ref = isElement$1(element) ? getWindow(element) : window,
        visualViewport = _ref.visualViewport;

    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width: width,
      height: height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x: x,
      y: y
    };
  }

  // means it doesn't take into account transforms.

  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223

    var width = element.offsetWidth;
    var height = element.offsetHeight;

    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }

    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }

    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width,
      height: height
    };
  }

  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

    if (parent.contains(child)) {
      return true;
    } // then fallback to custom implementation with Shadow DOM support
    else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;

        do {
          if (next && parent.isSameNode(next)) {
            return true;
          } // $FlowFixMe[prop-missing]: need a better way to handle this...


          next = next.parentNode || next.host;
        } while (next);
      } // Give up, the result is false


    return false;
  }

  function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
  }

  function isTableElement(element) {
    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
  }

  function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return ((isElement$1(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
    element.document) || window.document).documentElement;
  }

  function getParentNode(element) {
    if (getNodeName(element) === 'html') {
      return element;
    }

    return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || ( // DOM Element detected
      isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element) // fallback

    );
  }

  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle$1(element).position === 'fixed') {
      return null;
    }

    return element.offsetParent;
  } // `.offsetParent` reports `null` for fixed elements, while absolute elements
  // return the containing block


  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());

    if (isIE && isHTMLElement(element)) {
      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
      var elementCss = getComputedStyle$1(element);

      if (elementCss.position === 'fixed') {
        return null;
      }
    }

    var currentNode = getParentNode(element);

    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }

    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
      // create a containing block.
      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }

    return null;
  } // Gets the closest ancestor positioned element. Handles some edge cases,
  // such as table ancestors and cross browser bugs.


  function getOffsetParent(element) {
    var window = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);

    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
      offsetParent = getTrueOffsetParent(offsetParent);
    }

    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
      return window;
    }

    return offsetParent || getContainingBlock(element) || window;
  }

  function getMainAxisFromPlacement(placement) {
    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
  }

  function within(min, value, max) {
    return max$1(min, min$1(value, max));
  }
  function withinMaxClamp(min, value, max) {
    var v = within(min, value, max);
    return v > max ? max : v;
  }

  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  function expandToHashMap(value, keys) {
    return keys.reduce(function (hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  var toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  };

  function arrow(_ref) {
    var _state$modifiersData$;

    var state = _ref.state,
        name = _ref.name,
        options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? 'height' : 'width';

    if (!arrowElement || !popperOffsets) {
      return;
    }

    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === 'y' ? top : left;
    var maxProp = axis === 'y' ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds

    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = within(min, center, max); // Prevents breaking syntax highlighting...

    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
  }

  function effect$1(_ref2) {
    var state = _ref2.state,
        options = _ref2.options;
    var _options$element = options.element,
        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

    if (arrowElement == null) {
      return;
    } // CSS selector


    if (typeof arrowElement === 'string') {
      arrowElement = state.elements.popper.querySelector(arrowElement);

      if (!arrowElement) {
        return;
      }
    }

    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }

    state.elements.arrow = arrowElement;
  } // eslint-disable-next-line import/no-unused-modules


  var arrow$1 = {
    name: 'arrow',
    enabled: true,
    phase: 'main',
    fn: arrow,
    effect: effect$1,
    requires: ['popperOffsets'],
    requiresIfExists: ['preventOverflow']
  };

  function getVariation(placement) {
    return placement.split('-')[1];
  }

  var unsetSides = {
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto'
  }; // Round the offsets to the nearest suitable subpixel based on the DPR.
  // Zooming can change the DPR, but it seems to report a value that will
  // cleanly divide the values into the appropriate subpixels.

  function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x,
        y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }

  function mapToStyles(_ref2) {
    var _Object$assign2;

    var popper = _ref2.popper,
        popperRect = _ref2.popperRect,
        placement = _ref2.placement,
        variation = _ref2.variation,
        offsets = _ref2.offsets,
        position = _ref2.position,
        gpuAcceleration = _ref2.gpuAcceleration,
        adaptive = _ref2.adaptive,
        roundOffsets = _ref2.roundOffsets,
        isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x,
        x = _offsets$x === void 0 ? 0 : _offsets$x,
        _offsets$y = offsets.y,
        y = _offsets$y === void 0 ? 0 : _offsets$y;

    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
      x: x,
      y: y
    }) : {
      x: x,
      y: y
    };

    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty('x');
    var hasY = offsets.hasOwnProperty('y');
    var sideX = left;
    var sideY = top;
    var win = window;

    if (adaptive) {
      var offsetParent = getOffsetParent(popper);
      var heightProp = 'clientHeight';
      var widthProp = 'clientWidth';

      if (offsetParent === getWindow(popper)) {
        offsetParent = getDocumentElement(popper);

        if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
          heightProp = 'scrollHeight';
          widthProp = 'scrollWidth';
        }
      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


      offsetParent = offsetParent;

      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
        offsetParent[heightProp];
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }

      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
        offsetParent[widthProp];
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }

    var commonStyles = Object.assign({
      position: position
    }, adaptive && unsetSides);

    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x: x,
      y: y
    }, getWindow(popper)) : {
      x: x,
      y: y
    };

    x = _ref4.x;
    y = _ref4.y;

    if (gpuAcceleration) {
      var _Object$assign;

      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }

    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
  }

  function computeStyles(_ref5) {
    var state = _ref5.state,
        options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration,
        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
        _options$adaptive = options.adaptive,
        adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
        _options$roundOffsets = options.roundOffsets,
        roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration: gpuAcceleration,
      isFixed: state.options.strategy === 'fixed'
    };

    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
      })));
    }

    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        adaptive: false,
        roundOffsets: roundOffsets
      })));
    }

    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-placement': state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules


  var computeStyles$1 = {
    name: 'computeStyles',
    enabled: true,
    phase: 'beforeWrite',
    fn: computeStyles,
    data: {}
  };

  var passive = {
    passive: true
  };

  function effect(_ref) {
    var state = _ref.state,
        instance = _ref.instance,
        options = _ref.options;
    var _options$scroll = options.scroll,
        scroll = _options$scroll === void 0 ? true : _options$scroll,
        _options$resize = options.resize,
        resize = _options$resize === void 0 ? true : _options$resize;
    var window = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.addEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.addEventListener('resize', instance.update, passive);
    }

    return function () {
      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.removeEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.removeEventListener('resize', instance.update, passive);
      }
    };
  } // eslint-disable-next-line import/no-unused-modules


  var eventListeners = {
    name: 'eventListeners',
    enabled: true,
    phase: 'write',
    fn: function fn() {},
    effect: effect,
    data: {}
  };

  var hash$1 = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash$1[matched];
    });
  }

  var hash = {
    start: 'end',
    end: 'start'
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function (matched) {
      return hash[matched];
    });
  }

  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft: scrollLeft,
      scrollTop: scrollTop
    };
  }

  function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;

    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();

      if (layoutViewport || !layoutViewport && strategy === 'fixed') {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }

    return {
      width: width,
      height: height,
      x: x + getWindowScrollBarX(element),
      y: y
    };
  }

  // of the `<html>` and `<body>` rect bounds if horizontally scrollable

  function getDocumentRect(element) {
    var _element$ownerDocumen;

    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;

    if (getComputedStyle$1(body || html).direction === 'rtl') {
      x += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
    }

    return {
      width: width,
      height: height,
      x: x,
      y: y
    };
  }

  function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = getComputedStyle$1(element),
        overflow = _getComputedStyle.overflow,
        overflowX = _getComputedStyle.overflowX,
        overflowY = _getComputedStyle.overflowY;

    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  function getScrollParent(node) {
    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return node.ownerDocument.body;
    }

    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }

    return getScrollParent(getParentNode(node));
  }

  /*
  given a DOM element, return the list of all scroll parents, up the list of ancesors
  until we get to the top window object. This list is what we attach scroll listeners
  to, because if any of these parent elements scroll, we'll need to re-calculate the
  reference element's position.
  */

  function listScrollParents(element, list) {
    var _element$ownerDocumen;

    if (list === void 0) {
      list = [];
    }

    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)));
  }

  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === 'fixed');
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }

  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  } // A "clipping parent" is an overflowable container with the characteristic of
  // clipping (or hiding) overflowing elements with a position different from
  // `initial`


  function getClippingParents(element) {
    var clippingParents = listScrollParents(getParentNode(element));
    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

    if (!isElement$1(clipperElement)) {
      return [];
    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


    return clippingParents.filter(function (clippingParent) {
      return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
    });
  } // Gets the maximum area that the element is visible in due to any number of
  // clipping parents


  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max$1(rect.top, accRect.top);
      accRect.right = min$1(rect.right, accRect.right);
      accRect.bottom = min$1(rect.bottom, accRect.bottom);
      accRect.left = max$1(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  function computeOffsets(_ref) {
    var reference = _ref.reference,
        element = _ref.element,
        placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;

    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference.y - element.height
        };
        break;

      case bottom:
        offsets = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;

      case right:
        offsets = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;

      case left:
        offsets = {
          x: reference.x - element.width,
          y: commonY
        };
        break;

      default:
        offsets = {
          x: reference.x,
          y: reference.y
        };
    }

    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

    if (mainAxis != null) {
      var len = mainAxis === 'y' ? 'height' : 'width';

      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
          break;

        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
          break;
      }
    }

    return offsets;
  }

  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        _options$placement = _options.placement,
        placement = _options$placement === void 0 ? state.placement : _options$placement,
        _options$strategy = _options.strategy,
        strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
        _options$boundary = _options.boundary,
        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
        _options$rootBoundary = _options.rootBoundary,
        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
        _options$elementConte = _options.elementContext,
        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
        _options$altBoundary = _options.altBoundary,
        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
        _options$padding = _options.padding,
        padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: 'absolute',
      placement: placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect

    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

    if (elementContext === popper && offsetData) {
      var offset = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function (key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
        overflowOffsets[key] += offset[axis] * multiply;
      });
    }

    return overflowOffsets;
  }

  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        placement = _options.placement,
        boundary = _options.boundary,
        rootBoundary = _options.rootBoundary,
        padding = _options.padding,
        flipVariations = _options.flipVariations,
        _options$allowedAutoP = _options.allowedAutoPlacements,
        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
      return getVariation(placement) === variation;
    }) : basePlacements;
    var allowedPlacements = placements$1.filter(function (placement) {
      return allowedAutoPlacements.indexOf(placement) >= 0;
    });

    if (allowedPlacements.length === 0) {
      allowedPlacements = placements$1;
    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


    var overflows = allowedPlacements.reduce(function (acc, placement) {
      acc[placement] = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding
      })[getBasePlacement(placement)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function (a, b) {
      return overflows[a] - overflows[b];
    });
  }

  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }

    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }

  function flip(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;

    if (state.modifiersData[name]._skip) {
      return;
    }

    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
        specifiedFallbackPlacements = options.fallbackPlacements,
        padding = options.padding,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        _options$flipVariatio = options.flipVariations,
        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
        allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        flipVariations: flipVariations,
        allowedAutoPlacements: allowedAutoPlacements
      }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];

    for (var i = 0; i < placements.length; i++) {
      var placement = placements[i];

      var _basePlacement = getBasePlacement(placement);

      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? 'width' : 'height';
      var overflow = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        altBoundary: altBoundary,
        padding: padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }

      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];

      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }

      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }

      if (checks.every(function (check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }

      checksMap.set(placement, checks);
    }

    if (makeFallbackChecks) {
      // `2` may be desired in some cases â€“ research later
      var numberOfChecks = flipVariations ? 3 : 1;

      var _loop = function _loop(_i) {
        var fittingPlacement = placements.find(function (placement) {
          var checks = checksMap.get(placement);

          if (checks) {
            return checks.slice(0, _i).every(function (check) {
              return check;
            });
          }
        });

        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };

      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);

        if (_ret === "break") break;
      }
    }

    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  } // eslint-disable-next-line import/no-unused-modules


  var flip$1 = {
    name: 'flip',
    enabled: true,
    phase: 'main',
    fn: flip,
    requiresIfExists: ['offset'],
    data: {
      _skip: false
    }
  };

  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }

    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }

  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function (side) {
      return overflow[side] >= 0;
    });
  }

  function hide(_ref) {
    var state = _ref.state,
        name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: 'reference'
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets: referenceClippingOffsets,
      popperEscapeOffsets: popperEscapeOffsets,
      isReferenceHidden: isReferenceHidden,
      hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-reference-hidden': isReferenceHidden,
      'data-popper-escaped': hasPopperEscaped
    });
  } // eslint-disable-next-line import/no-unused-modules


  var hide$1 = {
    name: 'hide',
    enabled: true,
    phase: 'main',
    requiresIfExists: ['preventOverflow'],
    fn: hide
  };

  function distanceAndSkiddingToXY(placement, rects, offset) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
      placement: placement
    })) : offset,
        skidding = _ref[0],
        distance = _ref[1];

    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }

  function offset(_ref2) {
    var state = _ref2.state,
        options = _ref2.options,
        name = _ref2.name;
    var _options$offset = options.offset,
        offset = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function (acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement],
        x = _data$state$placement.x,
        y = _data$state$placement.y;

    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules


  var offset$1 = {
    name: 'offset',
    enabled: true,
    phase: 'main',
    requires: ['popperOffsets'],
    fn: offset
  };

  function popperOffsets(_ref) {
    var state = _ref.state,
        name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: 'absolute',
      placement: state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules


  var popperOffsets$1 = {
    name: 'popperOffsets',
    enabled: true,
    phase: 'read',
    fn: popperOffsets,
    data: {}
  };

  function getAltAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }

  function preventOverflow(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        padding = options.padding,
        _options$tether = options.tether,
        tether = _options$tether === void 0 ? true : _options$tether,
        _options$tetherOffset = options.tetherOffset,
        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      altBoundary: altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };

    if (!popperOffsets) {
      return;
    }

    if (checkMainAxis) {
      var _offsetModifierState$;

      var mainSide = mainAxis === 'y' ? top : left;
      var altSide = mainAxis === 'y' ? bottom : right;
      var len = mainAxis === 'y' ? 'height' : 'width';
      var offset = popperOffsets[mainAxis];
      var min = offset + overflow[mainSide];
      var max = offset - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
      // outside the reference bounds

      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
      // to include its full size in the calculation. If the reference is small
      // and near the edge of a boundary, the popper can overflow even if the
      // reference is not overflowing as well (e.g. virtual elements with no
      // width or height)

      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min$1(min, tetherMin) : min, offset, tether ? max$1(max, tetherMax) : max);
      popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }

    if (checkAltAxis) {
      var _offsetModifierState$2;

      var _mainSide = mainAxis === 'x' ? top : left;

      var _altSide = mainAxis === 'x' ? bottom : right;

      var _offset = popperOffsets[altAxis];

      var _len = altAxis === 'y' ? 'height' : 'width';

      var _min = _offset + overflow[_mainSide];

      var _max = _offset - overflow[_altSide];

      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

      popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules


  var preventOverflow$1 = {
    name: 'preventOverflow',
    enabled: true,
    phase: 'main',
    fn: preventOverflow,
    requiresIfExists: ['offset']
  };

  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  } // Returns the composite rect of an element relative to its offsetParent.
  // Composite means it takes into account transforms as well as layout.


  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }

    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };

    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }

      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }

    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function (modifier) {
      map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively

    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function (dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);

          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }

    modifiers.forEach(function (modifier) {
      if (!visited.has(modifier.name)) {
        // check for visited object
        sort(modifier);
      }
    });
    return result;
  }

  function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase

    return modifierPhases.reduce(function (acc, phase) {
      return acc.concat(orderedModifiers.filter(function (modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  function debounce(fn) {
    var pending;
    return function () {
      if (!pending) {
        pending = new Promise(function (resolve) {
          Promise.resolve().then(function () {
            pending = undefined;
            resolve(fn());
          });
        });
      }

      return pending;
    };
  }

  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function (merged, current) {
      var existing = merged[current.name];
      merged[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged;
    }, {}); // IE11 does not support Object.values

    return Object.keys(merged).map(function (key) {
      return merged[key];
    });
  }

  var DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute'
  };

  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return !args.some(function (element) {
      return !(element && typeof element.getBoundingClientRect === 'function');
    });
  }

  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }

    var _generatorOptions = generatorOptions,
        _generatorOptions$def = _generatorOptions.defaultModifiers,
        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
        _generatorOptions$def2 = _generatorOptions.defaultOptions,
        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var state = {
        placement: 'bottom',
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference,
          popper: popper
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state: state,
        setOptions: function setOptions(setOptionsAction) {
          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options);
          state.scrollParents = {
            reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
            popper: listScrollParents(popper)
          }; // Orders the modifiers based on their dependencies and `phase`
          // properties

          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

          state.orderedModifiers = orderedModifiers.filter(function (m) {
            return m.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update â€“ it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }

          var _state$elements = state.elements,
              reference = _state$elements.reference,
              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
          // anymore

          if (!areValidElements(reference, popper)) {
            return;
          } // Store the reference and popper rects to be read by modifiers


          state.rects = {
            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
            popper: getLayoutRect(popper)
          }; // Modifiers have the ability to reset the current update cycle. The
          // most common use case for this is the `flip` modifier changing the
          // placement, which then needs to re-run all the modifiers, because the
          // logic was previously ran for the previous placement and is therefore
          // stale/incorrect

          state.reset = false;
          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
          // is filled with the initial data specified by the modifier. This means
          // it doesn't persist and is fresh on each update.
          // To ensure persistent data, use `${name}#persistent`

          state.orderedModifiers.forEach(function (modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });

          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }

            var _state$orderedModifie = state.orderedModifiers[index],
                fn = _state$orderedModifie.fn,
                _state$orderedModifie2 = _state$orderedModifie.options,
                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                name = _state$orderedModifie.name;

            if (typeof fn === 'function') {
              state = fn({
                state: state,
                options: _options,
                name: name,
                instance: instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update â€“ it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function () {
          return new Promise(function (resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };

      if (!areValidElements(reference, popper)) {
        return instance;
      }

      instance.setOptions(options).then(function (state) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state);
        }
      }); // Modifiers have the ability to execute arbitrary code before the first
      // update cycle runs. They will be executed in the same order as the update
      // cycle. This is useful when a modifier adds some persistent data that
      // other modifiers need to use, but the modifier is run after the dependent
      // one.

      function runModifierEffects() {
        state.orderedModifiers.forEach(function (_ref) {
          var name = _ref.name,
              _ref$options = _ref.options,
              options = _ref$options === void 0 ? {} : _ref$options,
              effect = _ref.effect;

          if (typeof effect === 'function') {
            var cleanupFn = effect({
              state: state,
              name: name,
              instance: instance,
              options: options
            });

            var noopFn = function noopFn() {};

            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }

      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function (fn) {
          return fn();
        });
        effectCleanupFns = [];
      }

      return instance;
    };
  }
  var createPopper$2 = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules

  var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
  var createPopper$1 = /*#__PURE__*/popperGenerator({
    defaultModifiers: defaultModifiers$1
  }); // eslint-disable-next-line import/no-unused-modules

  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
  var createPopper = /*#__PURE__*/popperGenerator({
    defaultModifiers: defaultModifiers
  }); // eslint-disable-next-line import/no-unused-modules

  var Popper = /*#__PURE__*/Object.freeze({
    __proto__: null,
    afterMain: afterMain,
    afterRead: afterRead,
    afterWrite: afterWrite,
    applyStyles: applyStyles$1,
    arrow: arrow$1,
    auto: auto,
    basePlacements: basePlacements,
    beforeMain: beforeMain,
    beforeRead: beforeRead,
    beforeWrite: beforeWrite,
    bottom: bottom,
    clippingParents: clippingParents,
    computeStyles: computeStyles$1,
    createPopper: createPopper,
    createPopperBase: createPopper$2,
    createPopperLite: createPopper$1,
    detectOverflow: detectOverflow,
    end: end,
    eventListeners: eventListeners,
    flip: flip$1,
    hide: hide$1,
    left: left,
    main: main,
    modifierPhases: modifierPhases,
    offset: offset$1,
    placements: placements,
    popper: popper,
    popperGenerator: popperGenerator,
    popperOffsets: popperOffsets$1,
    preventOverflow: preventOverflow$1,
    read: read,
    reference: reference,
    right: right,
    start: start,
    top: top,
    variationPlacements: variationPlacements,
    viewport: viewport,
    write: write
  });

  /*!
    * Bootstrap v5.3.3 (https://getbootstrap.com/)
    * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
    * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
    */

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dom/data.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const elementMap = new Map();
  const Data = {
    set(element, key, instance) {
      if (!elementMap.has(element)) {
        elementMap.set(element, new Map());
      }
      const instanceMap = elementMap.get(element);

      // make it clear we only want one instance per element
      // can be removed later when multiple key/instances are fine to be used
      if (!instanceMap.has(key) && instanceMap.size !== 0) {
        // eslint-disable-next-line no-console
        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
        return;
      }
      instanceMap.set(key, instance);
    },
    get(element, key) {
      if (elementMap.has(element)) {
        return elementMap.get(element).get(key) || null;
      }
      return null;
    },
    remove(element, key) {
      if (!elementMap.has(element)) {
        return;
      }
      const instanceMap = elementMap.get(element);
      instanceMap.delete(key);

      // free up element references if there are no instances left for an element
      if (instanceMap.size === 0) {
        elementMap.delete(element);
      }
    }
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  const MAX_UID = 1000000;
  const MILLISECONDS_MULTIPLIER = 1000;
  const TRANSITION_END = 'transitionend';

  /**
   * Properly escape IDs selectors to handle weird IDs
   * @param {string} selector
   * @returns {string}
   */
  const parseSelector = selector => {
    if (selector && window.CSS && window.CSS.escape) {
      // document.querySelector needs escaping to handle IDs (html5+) containing for instance /
      selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
    }
    return selector;
  };

  // Shout-out Angus Croll (https://goo.gl/pxwQGp)
  const toType = object => {
    if (object === null || object === undefined) {
      return `${object}`;
    }
    return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
  };

  /**
   * Public Util API
   */

  const getUID = prefix => {
    do {
      prefix += Math.floor(Math.random() * MAX_UID);
    } while (document.getElementById(prefix));
    return prefix;
  };
  const getTransitionDurationFromElement = element => {
    if (!element) {
      return 0;
    }

    // Get transition-duration of the element
    let {
      transitionDuration,
      transitionDelay
    } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay);

    // Return 0 if element or transition duration is not found
    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    }

    // If multiple durations are defined, take the first
    transitionDuration = transitionDuration.split(',')[0];
    transitionDelay = transitionDelay.split(',')[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };
  const triggerTransitionEnd = element => {
    element.dispatchEvent(new Event(TRANSITION_END));
  };
  const isElement = object => {
    if (!object || typeof object !== 'object') {
      return false;
    }
    if (typeof object.jquery !== 'undefined') {
      object = object[0];
    }
    return typeof object.nodeType !== 'undefined';
  };
  const getElement = object => {
    // it's a jQuery object or a node element
    if (isElement(object)) {
      return object.jquery ? object[0] : object;
    }
    if (typeof object === 'string' && object.length > 0) {
      return document.querySelector(parseSelector(object));
    }
    return null;
  };
  const isVisible = element => {
    if (!isElement(element) || element.getClientRects().length === 0) {
      return false;
    }
    const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible';
    // Handle `details` element as its content may falsie appear visible when it is closed
    const closedDetails = element.closest('details:not([open])');
    if (!closedDetails) {
      return elementIsVisible;
    }
    if (closedDetails !== element) {
      const summary = element.closest('summary');
      if (summary && summary.parentNode !== closedDetails) {
        return false;
      }
      if (summary === null) {
        return false;
      }
    }
    return elementIsVisible;
  };
  const isDisabled = element => {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    if (element.classList.contains('disabled')) {
      return true;
    }
    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }
    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };
  const findShadowRoot = element => {
    if (!document.documentElement.attachShadow) {
      return null;
    }

    // Can find the shadow root otherwise it'll return the document
    if (typeof element.getRootNode === 'function') {
      const root = element.getRootNode();
      return root instanceof ShadowRoot ? root : null;
    }
    if (element instanceof ShadowRoot) {
      return element;
    }

    // when we don't find a shadow root
    if (!element.parentNode) {
      return null;
    }
    return findShadowRoot(element.parentNode);
  };
  const noop$1 = () => {};

  /**
   * Trick to restart an element's animation
   *
   * @param {HTMLElement} element
   * @return void
   *
   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
   */
  const reflow = element => {
    element.offsetHeight; // eslint-disable-line no-unused-expressions
  };
  const getjQuery = () => {
    if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return window.jQuery;
    }
    return null;
  };
  const DOMContentLoadedCallbacks = [];
  const onDOMContentLoaded = callback => {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', () => {
          for (const callback of DOMContentLoadedCallbacks) {
            callback();
          }
        });
      }
      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };
  const isRTL = () => document.documentElement.dir === 'rtl';
  const defineJQueryPlugin = plugin => {
    onDOMContentLoaded(() => {
      const $ = getjQuery();
      /* istanbul ignore if */
      if ($) {
        const name = plugin.NAME;
        const JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;
        $.fn[name].noConflict = () => {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  const execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
    return typeof possibleCallback === 'function' ? possibleCallback(...args) : defaultValue;
  };
  const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
    if (!waitForTransition) {
      execute(callback);
      return;
    }
    const durationPadding = 5;
    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;
    const handler = ({
      target
    }) => {
      if (target !== transitionElement) {
        return;
      }
      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };
    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(() => {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };

  /**
   * Return the previous/next element of a list.
   *
   * @param {array} list    The list of elements
   * @param activeElement   The active element
   * @param shouldGetNext   Choose to get next or previous element
   * @param isCycleAllowed
   * @return {Element|elem} The proper element
   */
  const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
    const listLength = list.length;
    let index = list.indexOf(activeElement);

    // if the element does not exist in the list return an element
    // depending on the direction and if cycle is allowed
    if (index === -1) {
      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
    }
    index += shouldGetNext ? 1 : -1;
    if (isCycleAllowed) {
      index = (index + listLength) % listLength;
    }
    return list[Math.max(0, Math.min(index, listLength - 1))];
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dom/event-handler.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
  const stripNameRegex = /\..*/;
  const stripUidRegex = /::\d+$/;
  const eventRegistry = {}; // Events storage
  let uidEvent = 1;
  const customEvents$1 = {
    mouseenter: 'mouseover',
    mouseleave: 'mouseout'
  };
  const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);

  /**
   * Private methods
   */

  function makeEventUid(element, uid) {
    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
  }
  function getElementEvents(element) {
    const uid = makeEventUid(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
  }
  function bootstrapHandler(element, fn) {
    return function handler(event) {
      hydrateObj(event, {
        delegateTarget: element
      });
      if (handler.oneOff) {
        EventHandler.off(element, event.type, fn);
      }
      return fn.apply(element, [event]);
    };
  }
  function bootstrapDelegationHandler(element, selector, fn) {
    return function handler(event) {
      const domElements = element.querySelectorAll(selector);
      for (let {
        target
      } = event; target && target !== this; target = target.parentNode) {
        for (const domElement of domElements) {
          if (domElement !== target) {
            continue;
          }
          hydrateObj(event, {
            delegateTarget: target
          });
          if (handler.oneOff) {
            EventHandler.off(element, event.type, selector, fn);
          }
          return fn.apply(target, [event]);
        }
      }
    };
  }
  function findHandler(events, callable, delegationSelector = null) {
    return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector);
  }
  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
    const isDelegated = typeof handler === 'string';
    // TODO: tooltip passes `false` instead of selector, so we need to check
    const callable = isDelegated ? delegationFunction : handler || delegationFunction;
    let typeEvent = getTypeEvent(originalTypeEvent);
    if (!nativeEvents.has(typeEvent)) {
      typeEvent = originalTypeEvent;
    }
    return [isDelegated, callable, typeEvent];
  }
  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
    if (typeof originalTypeEvent !== 'string' || !element) {
      return;
    }
    let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);

    // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
    // this prevents the handler from being dispatched the same way as mouseover or mouseout does
    if (originalTypeEvent in customEvents$1) {
      const wrapFunction = fn => {
        return function (event) {
          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
            return fn.call(this, event);
          }
        };
      };
      callable = wrapFunction(callable);
    }
    const events = getElementEvents(element);
    const handlers = events[typeEvent] || (events[typeEvent] = {});
    const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
    if (previousFunction) {
      previousFunction.oneOff = previousFunction.oneOff && oneOff;
      return;
    }
    const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));
    const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
    fn.delegationSelector = isDelegated ? handler : null;
    fn.callable = callable;
    fn.oneOff = oneOff;
    fn.uidEvent = uid;
    handlers[uid] = fn;
    element.addEventListener(typeEvent, fn, isDelegated);
  }
  function removeHandler(element, events, typeEvent, handler, delegationSelector) {
    const fn = findHandler(events[typeEvent], handler, delegationSelector);
    if (!fn) {
      return;
    }
    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
    delete events[typeEvent][fn.uidEvent];
  }
  function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    const storeElementEvent = events[typeEvent] || {};
    for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
      if (handlerKey.includes(namespace)) {
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  }
  function getTypeEvent(event) {
    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
    event = event.replace(stripNameRegex, '');
    return customEvents$1[event] || event;
  }
  const EventHandler = {
    on(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, false);
    },
    one(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, true);
    },
    off(element, originalTypeEvent, handler, delegationFunction) {
      if (typeof originalTypeEvent !== 'string' || !element) {
        return;
      }
      const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
      const inNamespace = typeEvent !== originalTypeEvent;
      const events = getElementEvents(element);
      const storeElementEvent = events[typeEvent] || {};
      const isNamespace = originalTypeEvent.startsWith('.');
      if (typeof callable !== 'undefined') {
        // Simplest case: handler is passed, remove that listener ONLY.
        if (!Object.keys(storeElementEvent).length) {
          return;
        }
        removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
        return;
      }
      if (isNamespace) {
        for (const elementEvent of Object.keys(events)) {
          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
        }
      }
      for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
        const handlerKey = keyHandlers.replace(stripUidRegex, '');
        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
        }
      }
    },
    trigger(element, event, args) {
      if (typeof event !== 'string' || !element) {
        return null;
      }
      const $ = getjQuery();
      const typeEvent = getTypeEvent(event);
      const inNamespace = event !== typeEvent;
      let jQueryEvent = null;
      let bubbles = true;
      let nativeDispatch = true;
      let defaultPrevented = false;
      if (inNamespace && $) {
        jQueryEvent = $.Event(event, args);
        $(element).trigger(jQueryEvent);
        bubbles = !jQueryEvent.isPropagationStopped();
        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
        defaultPrevented = jQueryEvent.isDefaultPrevented();
      }
      const evt = hydrateObj(new Event(event, {
        bubbles,
        cancelable: true
      }), args);
      if (defaultPrevented) {
        evt.preventDefault();
      }
      if (nativeDispatch) {
        element.dispatchEvent(evt);
      }
      if (evt.defaultPrevented && jQueryEvent) {
        jQueryEvent.preventDefault();
      }
      return evt;
    }
  };
  function hydrateObj(obj, meta = {}) {
    for (const [key, value] of Object.entries(meta)) {
      try {
        obj[key] = value;
      } catch (_unused) {
        Object.defineProperty(obj, key, {
          configurable: true,
          get() {
            return value;
          }
        });
      }
    }
    return obj;
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dom/manipulator.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  function normalizeData(value) {
    if (value === 'true') {
      return true;
    }
    if (value === 'false') {
      return false;
    }
    if (value === Number(value).toString()) {
      return Number(value);
    }
    if (value === '' || value === 'null') {
      return null;
    }
    if (typeof value !== 'string') {
      return value;
    }
    try {
      return JSON.parse(decodeURIComponent(value));
    } catch (_unused) {
      return value;
    }
  }
  function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);
  }
  const Manipulator = {
    setDataAttribute(element, key, value) {
      element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
    },
    removeDataAttribute(element, key) {
      element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
    },
    getDataAttributes(element) {
      if (!element) {
        return {};
      }
      const attributes = {};
      const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith('bs') && !key.startsWith('bsConfig'));
      for (const key of bsKeys) {
        let pureKey = key.replace(/^bs/, '');
        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
        attributes[pureKey] = normalizeData(element.dataset[key]);
      }
      return attributes;
    },
    getDataAttribute(element, key) {
      return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
    }
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/config.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Class definition
   */

  class Config {
    // Getters
    static get Default() {
      return {};
    }
    static get DefaultType() {
      return {};
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
    _getConfig(config) {
      config = this._mergeConfigObj(config);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
    _configAfterMerge(config) {
      return config;
    }
    _mergeConfigObj(config, element) {
      const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse

      return {
        ...this.constructor.Default,
        ...(typeof jsonConfig === 'object' ? jsonConfig : {}),
        ...(isElement(element) ? Manipulator.getDataAttributes(element) : {}),
        ...(typeof config === 'object' ? config : {})
      };
    }
    _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
      for (const [property, expectedTypes] of Object.entries(configTypes)) {
        const value = config[property];
        const valueType = isElement(value) ? 'element' : toType(value);
        if (!new RegExp(expectedTypes).test(valueType)) {
          throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
        }
      }
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap base-component.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const VERSION = '5.3.3';

  /**
   * Class definition
   */

  class BaseComponent extends Config {
    constructor(element, config) {
      super();
      element = getElement(element);
      if (!element) {
        return;
      }
      this._element = element;
      this._config = this._getConfig(config);
      Data.set(this._element, this.constructor.DATA_KEY, this);
    }

    // Public
    dispose() {
      Data.remove(this._element, this.constructor.DATA_KEY);
      EventHandler.off(this._element, this.constructor.EVENT_KEY);
      for (const propertyName of Object.getOwnPropertyNames(this)) {
        this[propertyName] = null;
      }
    }
    _queueCallback(callback, element, isAnimated = true) {
      executeAfterTransition(callback, element, isAnimated);
    }
    _getConfig(config) {
      config = this._mergeConfigObj(config, this._element);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }

    // Static
    static getInstance(element) {
      return Data.get(getElement(element), this.DATA_KEY);
    }
    static getOrCreateInstance(element, config = {}) {
      return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);
    }
    static get VERSION() {
      return VERSION;
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
    static eventName(name) {
      return `${name}${this.EVENT_KEY}`;
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dom/selector-engine.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  const getSelector = element => {
    let selector = element.getAttribute('data-bs-target');
    if (!selector || selector === '#') {
      let hrefAttribute = element.getAttribute('href');

      // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273
      if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {
        return null;
      }

      // Just in case some CMS puts out a full URL with the anchor appended
      if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {
        hrefAttribute = `#${hrefAttribute.split('#')[1]}`;
      }
      selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;
    }
    return selector ? selector.split(',').map(sel => parseSelector(sel)).join(',') : null;
  };
  const SelectorEngine = {
    find(selector, element = document.documentElement) {
      return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
    },
    findOne(selector, element = document.documentElement) {
      return Element.prototype.querySelector.call(element, selector);
    },
    children(element, selector) {
      return [].concat(...element.children).filter(child => child.matches(selector));
    },
    parents(element, selector) {
      const parents = [];
      let ancestor = element.parentNode.closest(selector);
      while (ancestor) {
        parents.push(ancestor);
        ancestor = ancestor.parentNode.closest(selector);
      }
      return parents;
    },
    prev(element, selector) {
      let previous = element.previousElementSibling;
      while (previous) {
        if (previous.matches(selector)) {
          return [previous];
        }
        previous = previous.previousElementSibling;
      }
      return [];
    },
    // TODO: this is now unused; remove later along with prev()
    next(element, selector) {
      let next = element.nextElementSibling;
      while (next) {
        if (next.matches(selector)) {
          return [next];
        }
        next = next.nextElementSibling;
      }
      return [];
    },
    focusableChildren(element) {
      const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(selector => `${selector}:not([tabindex^="-"])`).join(',');
      return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));
    },
    getSelectorFromElement(element) {
      const selector = getSelector(element);
      if (selector) {
        return SelectorEngine.findOne(selector) ? selector : null;
      }
      return null;
    },
    getElementFromSelector(element) {
      const selector = getSelector(element);
      return selector ? SelectorEngine.findOne(selector) : null;
    },
    getMultipleElementsFromSelector(element) {
      const selector = getSelector(element);
      return selector ? SelectorEngine.find(selector) : [];
    }
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/component-functions.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  const enableDismissTrigger = (component, method = 'hide') => {
    const clickEvent = `click.dismiss${component.EVENT_KEY}`;
    const name = component.NAME;
    EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function (event) {
      if (['A', 'AREA'].includes(this.tagName)) {
        event.preventDefault();
      }
      if (isDisabled(this)) {
        return;
      }
      const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);
      const instance = component.getOrCreateInstance(target);

      // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method
      instance[method]();
    });
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap alert.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$f = 'alert';
  const DATA_KEY$a = 'bs.alert';
  const EVENT_KEY$b = `.${DATA_KEY$a}`;
  const EVENT_CLOSE = `close${EVENT_KEY$b}`;
  const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
  const CLASS_NAME_FADE$5 = 'fade';
  const CLASS_NAME_SHOW$8 = 'show';

  /**
   * Class definition
   */

  class Alert extends BaseComponent {
    // Getters
    static get NAME() {
      return NAME$f;
    }

    // Public
    close() {
      const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
      if (closeEvent.defaultPrevented) {
        return;
      }
      this._element.classList.remove(CLASS_NAME_SHOW$8);
      const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
      this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
    }

    // Private
    _destroyElement() {
      this._element.remove();
      EventHandler.trigger(this._element, EVENT_CLOSED);
      this.dispose();
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Alert.getOrCreateInstance(this);
        if (typeof config !== 'string') {
          return;
        }
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      });
    }
  }

  /**
   * Data API implementation
   */

  enableDismissTrigger(Alert, 'close');

  /**
   * jQuery
   */

  defineJQueryPlugin(Alert);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap button.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$e = 'button';
  const DATA_KEY$9 = 'bs.button';
  const EVENT_KEY$a = `.${DATA_KEY$9}`;
  const DATA_API_KEY$6 = '.data-api';
  const CLASS_NAME_ACTIVE$3 = 'active';
  const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
  const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;

  /**
   * Class definition
   */

  class Button extends BaseComponent {
    // Getters
    static get NAME() {
      return NAME$e;
    }

    // Public
    toggle() {
      // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
      this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Button.getOrCreateInstance(this);
        if (config === 'toggle') {
          data[config]();
        }
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {
    event.preventDefault();
    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
    const data = Button.getOrCreateInstance(button);
    data.toggle();
  });

  /**
   * jQuery
   */

  defineJQueryPlugin(Button);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/swipe.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$d = 'swipe';
  const EVENT_KEY$9 = '.bs.swipe';
  const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
  const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
  const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
  const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
  const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
  const POINTER_TYPE_TOUCH = 'touch';
  const POINTER_TYPE_PEN = 'pen';
  const CLASS_NAME_POINTER_EVENT = 'pointer-event';
  const SWIPE_THRESHOLD = 40;
  const Default$c = {
    endCallback: null,
    leftCallback: null,
    rightCallback: null
  };
  const DefaultType$c = {
    endCallback: '(function|null)',
    leftCallback: '(function|null)',
    rightCallback: '(function|null)'
  };

  /**
   * Class definition
   */

  class Swipe extends Config {
    constructor(element, config) {
      super();
      this._element = element;
      if (!element || !Swipe.isSupported()) {
        return;
      }
      this._config = this._getConfig(config);
      this._deltaX = 0;
      this._supportPointerEvents = Boolean(window.PointerEvent);
      this._initEvents();
    }

    // Getters
    static get Default() {
      return Default$c;
    }
    static get DefaultType() {
      return DefaultType$c;
    }
    static get NAME() {
      return NAME$d;
    }

    // Public
    dispose() {
      EventHandler.off(this._element, EVENT_KEY$9);
    }

    // Private
    _start(event) {
      if (!this._supportPointerEvents) {
        this._deltaX = event.touches[0].clientX;
        return;
      }
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX;
      }
    }
    _end(event) {
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX - this._deltaX;
      }
      this._handleSwipe();
      execute(this._config.endCallback);
    }
    _move(event) {
      this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
    }
    _handleSwipe() {
      const absDeltaX = Math.abs(this._deltaX);
      if (absDeltaX <= SWIPE_THRESHOLD) {
        return;
      }
      const direction = absDeltaX / this._deltaX;
      this._deltaX = 0;
      if (!direction) {
        return;
      }
      execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
    }
    _initEvents() {
      if (this._supportPointerEvents) {
        EventHandler.on(this._element, EVENT_POINTERDOWN, event => this._start(event));
        EventHandler.on(this._element, EVENT_POINTERUP, event => this._end(event));
        this._element.classList.add(CLASS_NAME_POINTER_EVENT);
      } else {
        EventHandler.on(this._element, EVENT_TOUCHSTART, event => this._start(event));
        EventHandler.on(this._element, EVENT_TOUCHMOVE, event => this._move(event));
        EventHandler.on(this._element, EVENT_TOUCHEND, event => this._end(event));
      }
    }
    _eventIsPointerPenTouch(event) {
      return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
    }

    // Static
    static isSupported() {
      return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap carousel.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$c = 'carousel';
  const DATA_KEY$8 = 'bs.carousel';
  const EVENT_KEY$8 = `.${DATA_KEY$8}`;
  const DATA_API_KEY$5 = '.data-api';
  const ARROW_LEFT_KEY$1 = 'ArrowLeft';
  const ARROW_RIGHT_KEY$1 = 'ArrowRight';
  const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

  const ORDER_NEXT = 'next';
  const ORDER_PREV = 'prev';
  const DIRECTION_LEFT = 'left';
  const DIRECTION_RIGHT = 'right';
  const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
  const EVENT_SLID = `slid${EVENT_KEY$8}`;
  const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
  const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
  const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
  const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
  const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
  const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
  const CLASS_NAME_CAROUSEL = 'carousel';
  const CLASS_NAME_ACTIVE$2 = 'active';
  const CLASS_NAME_SLIDE = 'slide';
  const CLASS_NAME_END = 'carousel-item-end';
  const CLASS_NAME_START = 'carousel-item-start';
  const CLASS_NAME_NEXT = 'carousel-item-next';
  const CLASS_NAME_PREV = 'carousel-item-prev';
  const SELECTOR_ACTIVE = '.active';
  const SELECTOR_ITEM = '.carousel-item';
  const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
  const SELECTOR_ITEM_IMG = '.carousel-item img';
  const SELECTOR_INDICATORS = '.carousel-indicators';
  const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';
  const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
  const KEY_TO_DIRECTION = {
    [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
    [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
  };
  const Default$b = {
    interval: 5000,
    keyboard: true,
    pause: 'hover',
    ride: false,
    touch: true,
    wrap: true
  };
  const DefaultType$b = {
    interval: '(number|boolean)',
    // TODO:v6 remove boolean support
    keyboard: 'boolean',
    pause: '(string|boolean)',
    ride: '(boolean|string)',
    touch: 'boolean',
    wrap: 'boolean'
  };

  /**
   * Class definition
   */

  class Carousel extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._interval = null;
      this._activeElement = null;
      this._isSliding = false;
      this.touchTimeout = null;
      this._swipeHelper = null;
      this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
      this._addEventListeners();
      if (this._config.ride === CLASS_NAME_CAROUSEL) {
        this.cycle();
      }
    }

    // Getters
    static get Default() {
      return Default$b;
    }
    static get DefaultType() {
      return DefaultType$b;
    }
    static get NAME() {
      return NAME$c;
    }

    // Public
    next() {
      this._slide(ORDER_NEXT);
    }
    nextWhenVisible() {
      // FIXME TODO use `document.visibilityState`
      // Don't call next when the page isn't visible
      // or the carousel or its parent isn't visible
      if (!document.hidden && isVisible(this._element)) {
        this.next();
      }
    }
    prev() {
      this._slide(ORDER_PREV);
    }
    pause() {
      if (this._isSliding) {
        triggerTransitionEnd(this._element);
      }
      this._clearInterval();
    }
    cycle() {
      this._clearInterval();
      this._updateInterval();
      this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
    }
    _maybeEnableCycle() {
      if (!this._config.ride) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
        return;
      }
      this.cycle();
    }
    to(index) {
      const items = this._getItems();
      if (index > items.length - 1 || index < 0) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
        return;
      }
      const activeIndex = this._getItemIndex(this._getActive());
      if (activeIndex === index) {
        return;
      }
      const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
      this._slide(order, items[index]);
    }
    dispose() {
      if (this._swipeHelper) {
        this._swipeHelper.dispose();
      }
      super.dispose();
    }

    // Private
    _configAfterMerge(config) {
      config.defaultInterval = config.interval;
      return config;
    }
    _addEventListeners() {
      if (this._config.keyboard) {
        EventHandler.on(this._element, EVENT_KEYDOWN$1, event => this._keydown(event));
      }
      if (this._config.pause === 'hover') {
        EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
        EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
      }
      if (this._config.touch && Swipe.isSupported()) {
        this._addTouchEventListeners();
      }
    }
    _addTouchEventListeners() {
      for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
        EventHandler.on(img, EVENT_DRAG_START, event => event.preventDefault());
      }
      const endCallBack = () => {
        if (this._config.pause !== 'hover') {
          return;
        }

        // If it's a touch-enabled device, mouseenter/leave are fired as
        // part of the mouse compatibility events on first tap - the carousel
        // would stop cycling until user tapped out of it;
        // here, we listen for touchend, explicitly pause the carousel
        // (as if it's the second time we tap on it, mouseenter compat event
        // is NOT fired) and after a timeout (to allow for mouse compatibility
        // events to fire) we explicitly restart cycling

        this.pause();
        if (this.touchTimeout) {
          clearTimeout(this.touchTimeout);
        }
        this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
      };
      const swipeConfig = {
        leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
        rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
        endCallback: endCallBack
      };
      this._swipeHelper = new Swipe(this._element, swipeConfig);
    }
    _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }
      const direction = KEY_TO_DIRECTION[event.key];
      if (direction) {
        event.preventDefault();
        this._slide(this._directionToOrder(direction));
      }
    }
    _getItemIndex(element) {
      return this._getItems().indexOf(element);
    }
    _setActiveIndicatorElement(index) {
      if (!this._indicatorsElement) {
        return;
      }
      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
      activeIndicator.removeAttribute('aria-current');
      const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
      if (newActiveIndicator) {
        newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
        newActiveIndicator.setAttribute('aria-current', 'true');
      }
    }
    _updateInterval() {
      const element = this._activeElement || this._getActive();
      if (!element) {
        return;
      }
      const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);
      this._config.interval = elementInterval || this._config.defaultInterval;
    }
    _slide(order, element = null) {
      if (this._isSliding) {
        return;
      }
      const activeElement = this._getActive();
      const isNext = order === ORDER_NEXT;
      const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
      if (nextElement === activeElement) {
        return;
      }
      const nextElementIndex = this._getItemIndex(nextElement);
      const triggerEvent = eventName => {
        return EventHandler.trigger(this._element, eventName, {
          relatedTarget: nextElement,
          direction: this._orderToDirection(order),
          from: this._getItemIndex(activeElement),
          to: nextElementIndex
        });
      };
      const slideEvent = triggerEvent(EVENT_SLIDE);
      if (slideEvent.defaultPrevented) {
        return;
      }
      if (!activeElement || !nextElement) {
        // Some weirdness is happening, so we bail
        // TODO: change tests that use empty divs to avoid this check
        return;
      }
      const isCycling = Boolean(this._interval);
      this.pause();
      this._isSliding = true;
      this._setActiveIndicatorElement(nextElementIndex);
      this._activeElement = nextElement;
      const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
      const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
      nextElement.classList.add(orderClassName);
      reflow(nextElement);
      activeElement.classList.add(directionalClassName);
      nextElement.classList.add(directionalClassName);
      const completeCallBack = () => {
        nextElement.classList.remove(directionalClassName, orderClassName);
        nextElement.classList.add(CLASS_NAME_ACTIVE$2);
        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
        this._isSliding = false;
        triggerEvent(EVENT_SLID);
      };
      this._queueCallback(completeCallBack, activeElement, this._isAnimated());
      if (isCycling) {
        this.cycle();
      }
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_SLIDE);
    }
    _getActive() {
      return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
    }
    _getItems() {
      return SelectorEngine.find(SELECTOR_ITEM, this._element);
    }
    _clearInterval() {
      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }
    }
    _directionToOrder(direction) {
      if (isRTL()) {
        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
      }
      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
    }
    _orderToDirection(order) {
      if (isRTL()) {
        return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Carousel.getOrCreateInstance(this, config);
        if (typeof config === 'number') {
          data.to(config);
          return;
        }
        if (typeof config === 'string') {
          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
      return;
    }
    event.preventDefault();
    const carousel = Carousel.getOrCreateInstance(target);
    const slideIndex = this.getAttribute('data-bs-slide-to');
    if (slideIndex) {
      carousel.to(slideIndex);
      carousel._maybeEnableCycle();
      return;
    }
    if (Manipulator.getDataAttribute(this, 'slide') === 'next') {
      carousel.next();
      carousel._maybeEnableCycle();
      return;
    }
    carousel.prev();
    carousel._maybeEnableCycle();
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
    for (const carousel of carousels) {
      Carousel.getOrCreateInstance(carousel);
    }
  });

  /**
   * jQuery
   */

  defineJQueryPlugin(Carousel);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap collapse.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$b = 'collapse';
  const DATA_KEY$7 = 'bs.collapse';
  const EVENT_KEY$7 = `.${DATA_KEY$7}`;
  const DATA_API_KEY$4 = '.data-api';
  const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
  const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
  const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
  const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
  const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
  const CLASS_NAME_SHOW$7 = 'show';
  const CLASS_NAME_COLLAPSE = 'collapse';
  const CLASS_NAME_COLLAPSING = 'collapsing';
  const CLASS_NAME_COLLAPSED = 'collapsed';
  const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
  const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
  const WIDTH = 'width';
  const HEIGHT = 'height';
  const SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';
  const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
  const Default$a = {
    parent: null,
    toggle: true
  };
  const DefaultType$a = {
    parent: '(null|element)',
    toggle: 'boolean'
  };

  /**
   * Class definition
   */

  class Collapse extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._isTransitioning = false;
      this._triggerArray = [];
      const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
      for (const elem of toggleList) {
        const selector = SelectorEngine.getSelectorFromElement(elem);
        const filterElement = SelectorEngine.find(selector).filter(foundElement => foundElement === this._element);
        if (selector !== null && filterElement.length) {
          this._triggerArray.push(elem);
        }
      }
      this._initializeChildren();
      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
      }
      if (this._config.toggle) {
        this.toggle();
      }
    }

    // Getters
    static get Default() {
      return Default$a;
    }
    static get DefaultType() {
      return DefaultType$a;
    }
    static get NAME() {
      return NAME$b;
    }

    // Public
    toggle() {
      if (this._isShown()) {
        this.hide();
      } else {
        this.show();
      }
    }
    show() {
      if (this._isTransitioning || this._isShown()) {
        return;
      }
      let activeChildren = [];

      // find active children
      if (this._config.parent) {
        activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(element => element !== this._element).map(element => Collapse.getOrCreateInstance(element, {
          toggle: false
        }));
      }
      if (activeChildren.length && activeChildren[0]._isTransitioning) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      for (const activeInstance of activeChildren) {
        activeInstance.hide();
      }
      const dimension = this._getDimension();
      this._element.classList.remove(CLASS_NAME_COLLAPSE);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.style[dimension] = 0;
      this._addAriaAndCollapsedClass(this._triggerArray, true);
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
        this._element.style[dimension] = '';
        EventHandler.trigger(this._element, EVENT_SHOWN$6);
      };
      const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      const scrollSize = `scroll${capitalizedDimension}`;
      this._queueCallback(complete, this._element, true);
      this._element.style[dimension] = `${this._element[scrollSize]}px`;
    }
    hide() {
      if (this._isTransitioning || !this._isShown()) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      const dimension = this._getDimension();
      this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      for (const trigger of this._triggerArray) {
        const element = SelectorEngine.getElementFromSelector(trigger);
        if (element && !this._isShown(element)) {
          this._addAriaAndCollapsedClass([trigger], false);
        }
      }
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE);
        EventHandler.trigger(this._element, EVENT_HIDDEN$6);
      };
      this._element.style[dimension] = '';
      this._queueCallback(complete, this._element, true);
    }
    _isShown(element = this._element) {
      return element.classList.contains(CLASS_NAME_SHOW$7);
    }

    // Private
    _configAfterMerge(config) {
      config.toggle = Boolean(config.toggle); // Coerce string values
      config.parent = getElement(config.parent);
      return config;
    }
    _getDimension() {
      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
    }
    _initializeChildren() {
      if (!this._config.parent) {
        return;
      }
      const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
      for (const element of children) {
        const selected = SelectorEngine.getElementFromSelector(element);
        if (selected) {
          this._addAriaAndCollapsedClass([element], this._isShown(selected));
        }
      }
    }
    _getFirstLevelChildren(selector) {
      const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
      // remove children if greater depth
      return SelectorEngine.find(selector, this._config.parent).filter(element => !children.includes(element));
    }
    _addAriaAndCollapsedClass(triggerArray, isOpen) {
      if (!triggerArray.length) {
        return;
      }
      for (const element of triggerArray) {
        element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
        element.setAttribute('aria-expanded', isOpen);
      }
    }

    // Static
    static jQueryInterface(config) {
      const _config = {};
      if (typeof config === 'string' && /show|hide/.test(config)) {
        _config.toggle = false;
      }
      return this.each(function () {
        const data = Collapse.getOrCreateInstance(this, _config);
        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {
    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
    if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {
      event.preventDefault();
    }
    for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {
      Collapse.getOrCreateInstance(element, {
        toggle: false
      }).toggle();
    }
  });

  /**
   * jQuery
   */

  defineJQueryPlugin(Collapse);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dropdown.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$a = 'dropdown';
  const DATA_KEY$6 = 'bs.dropdown';
  const EVENT_KEY$6 = `.${DATA_KEY$6}`;
  const DATA_API_KEY$3 = '.data-api';
  const ESCAPE_KEY$2 = 'Escape';
  const TAB_KEY$1 = 'Tab';
  const ARROW_UP_KEY$1 = 'ArrowUp';
  const ARROW_DOWN_KEY$1 = 'ArrowDown';
  const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button

  const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
  const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
  const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
  const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
  const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
  const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
  const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
  const CLASS_NAME_SHOW$6 = 'show';
  const CLASS_NAME_DROPUP = 'dropup';
  const CLASS_NAME_DROPEND = 'dropend';
  const CLASS_NAME_DROPSTART = 'dropstart';
  const CLASS_NAME_DROPUP_CENTER = 'dropup-center';
  const CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';
  const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
  const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
  const SELECTOR_MENU = '.dropdown-menu';
  const SELECTOR_NAVBAR = '.navbar';
  const SELECTOR_NAVBAR_NAV = '.navbar-nav';
  const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
  const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';
  const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';
  const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';
  const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';
  const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';
  const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';
  const PLACEMENT_TOPCENTER = 'top';
  const PLACEMENT_BOTTOMCENTER = 'bottom';
  const Default$9 = {
    autoClose: true,
    boundary: 'clippingParents',
    display: 'dynamic',
    offset: [0, 2],
    popperConfig: null,
    reference: 'toggle'
  };
  const DefaultType$9 = {
    autoClose: '(boolean|string)',
    boundary: '(string|element)',
    display: 'string',
    offset: '(array|string|function)',
    popperConfig: '(null|object|function)',
    reference: '(string|element|object)'
  };

  /**
   * Class definition
   */

  class Dropdown extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._popper = null;
      this._parent = this._element.parentNode; // dropdown wrapper
      // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
      this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
      this._inNavbar = this._detectNavbar();
    }

    // Getters
    static get Default() {
      return Default$9;
    }
    static get DefaultType() {
      return DefaultType$9;
    }
    static get NAME() {
      return NAME$a;
    }

    // Public
    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (isDisabled(this._element) || this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._createPopper();

      // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
      if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.on(element, 'mouseover', noop$1);
        }
      }
      this._element.focus();
      this._element.setAttribute('aria-expanded', true);
      this._menu.classList.add(CLASS_NAME_SHOW$6);
      this._element.classList.add(CLASS_NAME_SHOW$6);
      EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
    }
    hide() {
      if (isDisabled(this._element) || !this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      this._completeHide(relatedTarget);
    }
    dispose() {
      if (this._popper) {
        this._popper.destroy();
      }
      super.dispose();
    }
    update() {
      this._inNavbar = this._detectNavbar();
      if (this._popper) {
        this._popper.update();
      }
    }

    // Private
    _completeHide(relatedTarget) {
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
      if (hideEvent.defaultPrevented) {
        return;
      }

      // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support
      if ('ontouchstart' in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.off(element, 'mouseover', noop$1);
        }
      }
      if (this._popper) {
        this._popper.destroy();
      }
      this._menu.classList.remove(CLASS_NAME_SHOW$6);
      this._element.classList.remove(CLASS_NAME_SHOW$6);
      this._element.setAttribute('aria-expanded', 'false');
      Manipulator.removeDataAttribute(this._menu, 'popper');
      EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
    }
    _getConfig(config) {
      config = super._getConfig(config);
      if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {
        // Popper virtual elements require a getBoundingClientRect method
        throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
      }
      return config;
    }
    _createPopper() {
      if (typeof Popper === 'undefined') {
        throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org)');
      }
      let referenceElement = this._element;
      if (this._config.reference === 'parent') {
        referenceElement = this._parent;
      } else if (isElement(this._config.reference)) {
        referenceElement = getElement(this._config.reference);
      } else if (typeof this._config.reference === 'object') {
        referenceElement = this._config.reference;
      }
      const popperConfig = this._getPopperConfig();
      this._popper = createPopper(referenceElement, this._menu, popperConfig);
    }
    _isShown() {
      return this._menu.classList.contains(CLASS_NAME_SHOW$6);
    }
    _getPlacement() {
      const parentDropdown = this._parent;
      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
        return PLACEMENT_RIGHT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
        return PLACEMENT_LEFT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
        return PLACEMENT_TOPCENTER;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
        return PLACEMENT_BOTTOMCENTER;
      }

      // We need to trim the value because custom properties can also include spaces
      const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
      }
      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }
    _detectNavbar() {
      return this._element.closest(SELECTOR_NAVBAR) !== null;
    }
    _getOffset() {
      const {
        offset
      } = this._config;
      if (typeof offset === 'string') {
        return offset.split(',').map(value => Number.parseInt(value, 10));
      }
      if (typeof offset === 'function') {
        return popperData => offset(popperData, this._element);
      }
      return offset;
    }
    _getPopperConfig() {
      const defaultBsPopperConfig = {
        placement: this._getPlacement(),
        modifiers: [{
          name: 'preventOverflow',
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: 'offset',
          options: {
            offset: this._getOffset()
          }
        }]
      };

      // Disable Popper if we have a static display or Dropdown is in Navbar
      if (this._inNavbar || this._config.display === 'static') {
        Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // TODO: v6 remove
        defaultBsPopperConfig.modifiers = [{
          name: 'applyStyles',
          enabled: false
        }];
      }
      return {
        ...defaultBsPopperConfig,
        ...execute(this._config.popperConfig, [defaultBsPopperConfig])
      };
    }
    _selectMenuItem({
      key,
      target
    }) {
      const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(element => isVisible(element));
      if (!items.length) {
        return;
      }

      // if target isn't included in items (e.g. when expanding the dropdown)
      // allow cycling to get the last item in case key equals ARROW_UP_KEY
      getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Dropdown.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
    static clearMenus(event) {
      if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {
        return;
      }
      const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
      for (const toggle of openToggles) {
        const context = Dropdown.getInstance(toggle);
        if (!context || context._config.autoClose === false) {
          continue;
        }
        const composedPath = event.composedPath();
        const isMenuTarget = composedPath.includes(context._menu);
        if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {
          continue;
        }

        // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu
        if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
          continue;
        }
        const relatedTarget = {
          relatedTarget: context._element
        };
        if (event.type === 'click') {
          relatedTarget.clickEvent = event;
        }
        context._completeHide(relatedTarget);
      }
    }
    static dataApiKeydownHandler(event) {
      // If not an UP | DOWN | ESCAPE key => not a dropdown command
      // If input/textarea && if key is other than ESCAPE => not a dropdown command

      const isInput = /input|textarea/i.test(event.target.tagName);
      const isEscapeEvent = event.key === ESCAPE_KEY$2;
      const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
      if (!isUpOrDownEvent && !isEscapeEvent) {
        return;
      }
      if (isInput && !isEscapeEvent) {
        return;
      }
      event.preventDefault();

      // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
      const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
      const instance = Dropdown.getOrCreateInstance(getToggleButton);
      if (isUpOrDownEvent) {
        event.stopPropagation();
        instance.show();
        instance._selectMenuItem(event);
        return;
      }
      if (instance._isShown()) {
        // else is escape and we check if it is shown
        event.stopPropagation();
        instance.hide();
        getToggleButton.focus();
      }
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
  });

  /**
   * jQuery
   */

  defineJQueryPlugin(Dropdown);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/backdrop.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$9 = 'backdrop';
  const CLASS_NAME_FADE$4 = 'fade';
  const CLASS_NAME_SHOW$5 = 'show';
  const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
  const Default$8 = {
    className: 'modal-backdrop',
    clickCallback: null,
    isAnimated: false,
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    rootElement: 'body' // give the choice to place backdrop under different elements
  };
  const DefaultType$8 = {
    className: 'string',
    clickCallback: '(function|null)',
    isAnimated: 'boolean',
    isVisible: 'boolean',
    rootElement: '(element|string)'
  };

  /**
   * Class definition
   */

  class Backdrop extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
      this._isAppended = false;
      this._element = null;
    }

    // Getters
    static get Default() {
      return Default$8;
    }
    static get DefaultType() {
      return DefaultType$8;
    }
    static get NAME() {
      return NAME$9;
    }

    // Public
    show(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._append();
      const element = this._getElement();
      if (this._config.isAnimated) {
        reflow(element);
      }
      element.classList.add(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        execute(callback);
      });
    }
    hide(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._getElement().classList.remove(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        this.dispose();
        execute(callback);
      });
    }
    dispose() {
      if (!this._isAppended) {
        return;
      }
      EventHandler.off(this._element, EVENT_MOUSEDOWN);
      this._element.remove();
      this._isAppended = false;
    }

    // Private
    _getElement() {
      if (!this._element) {
        const backdrop = document.createElement('div');
        backdrop.className = this._config.className;
        if (this._config.isAnimated) {
          backdrop.classList.add(CLASS_NAME_FADE$4);
        }
        this._element = backdrop;
      }
      return this._element;
    }
    _configAfterMerge(config) {
      // use getElement() with the default "body" to get a fresh Element on each instantiation
      config.rootElement = getElement(config.rootElement);
      return config;
    }
    _append() {
      if (this._isAppended) {
        return;
      }
      const element = this._getElement();
      this._config.rootElement.append(element);
      EventHandler.on(element, EVENT_MOUSEDOWN, () => {
        execute(this._config.clickCallback);
      });
      this._isAppended = true;
    }
    _emulateAnimation(callback) {
      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/focustrap.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$8 = 'focustrap';
  const DATA_KEY$5 = 'bs.focustrap';
  const EVENT_KEY$5 = `.${DATA_KEY$5}`;
  const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
  const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
  const TAB_KEY = 'Tab';
  const TAB_NAV_FORWARD = 'forward';
  const TAB_NAV_BACKWARD = 'backward';
  const Default$7 = {
    autofocus: true,
    trapElement: null // The element to trap focus inside of
  };
  const DefaultType$7 = {
    autofocus: 'boolean',
    trapElement: 'element'
  };

  /**
   * Class definition
   */

  class FocusTrap extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
      this._isActive = false;
      this._lastTabNavDirection = null;
    }

    // Getters
    static get Default() {
      return Default$7;
    }
    static get DefaultType() {
      return DefaultType$7;
    }
    static get NAME() {
      return NAME$8;
    }

    // Public
    activate() {
      if (this._isActive) {
        return;
      }
      if (this._config.autofocus) {
        this._config.trapElement.focus();
      }
      EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop
      EventHandler.on(document, EVENT_FOCUSIN$2, event => this._handleFocusin(event));
      EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));
      this._isActive = true;
    }
    deactivate() {
      if (!this._isActive) {
        return;
      }
      this._isActive = false;
      EventHandler.off(document, EVENT_KEY$5);
    }

    // Private
    _handleFocusin(event) {
      const {
        trapElement
      } = this._config;
      if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
        return;
      }
      const elements = SelectorEngine.focusableChildren(trapElement);
      if (elements.length === 0) {
        trapElement.focus();
      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
        elements[elements.length - 1].focus();
      } else {
        elements[0].focus();
      }
    }
    _handleKeydown(event) {
      if (event.key !== TAB_KEY) {
        return;
      }
      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/scrollBar.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
  const SELECTOR_STICKY_CONTENT = '.sticky-top';
  const PROPERTY_PADDING = 'padding-right';
  const PROPERTY_MARGIN = 'margin-right';

  /**
   * Class definition
   */

  class ScrollBarHelper {
    constructor() {
      this._element = document.body;
    }

    // Public
    getWidth() {
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
      const documentWidth = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
    hide() {
      const width = this.getWidth();
      this._disableOverFlow();
      // give padding to element to balance the hidden scrollbar width
      this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width);
      // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth
      this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width);
      this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width);
    }
    reset() {
      this._resetElementAttributes(this._element, 'overflow');
      this._resetElementAttributes(this._element, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }

    // Private
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, 'overflow');
      this._element.style.overflow = 'hidden';
    }
    _setElementAttributes(selector, styleProperty, callback) {
      const scrollbarWidth = this.getWidth();
      const manipulationCallBack = element => {
        if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
          return;
        }
        this._saveInitialAttribute(element, styleProperty);
        const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
        element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _saveInitialAttribute(element, styleProperty) {
      const actualValue = element.style.getPropertyValue(styleProperty);
      if (actualValue) {
        Manipulator.setDataAttribute(element, styleProperty, actualValue);
      }
    }
    _resetElementAttributes(selector, styleProperty) {
      const manipulationCallBack = element => {
        const value = Manipulator.getDataAttribute(element, styleProperty);
        // We only want to remove the property if the value is `null`; the value can also be zero
        if (value === null) {
          element.style.removeProperty(styleProperty);
          return;
        }
        Manipulator.removeDataAttribute(element, styleProperty);
        element.style.setProperty(styleProperty, value);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _applyManipulationCallback(selector, callBack) {
      if (isElement(selector)) {
        callBack(selector);
        return;
      }
      for (const sel of SelectorEngine.find(selector, this._element)) {
        callBack(sel);
      }
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap modal.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$7 = 'modal';
  const DATA_KEY$4 = 'bs.modal';
  const EVENT_KEY$4 = `.${DATA_KEY$4}`;
  const DATA_API_KEY$2 = '.data-api';
  const ESCAPE_KEY$1 = 'Escape';
  const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
  const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
  const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
  const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
  const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
  const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
  const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
  const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
  const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
  const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
  const CLASS_NAME_OPEN = 'modal-open';
  const CLASS_NAME_FADE$3 = 'fade';
  const CLASS_NAME_SHOW$4 = 'show';
  const CLASS_NAME_STATIC = 'modal-static';
  const OPEN_SELECTOR$1 = '.modal.show';
  const SELECTOR_DIALOG = '.modal-dialog';
  const SELECTOR_MODAL_BODY = '.modal-body';
  const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
  const Default$6 = {
    backdrop: true,
    focus: true,
    keyboard: true
  };
  const DefaultType$6 = {
    backdrop: '(boolean|string)',
    focus: 'boolean',
    keyboard: 'boolean'
  };

  /**
   * Class definition
   */

  class Modal extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._isShown = false;
      this._isTransitioning = false;
      this._scrollBar = new ScrollBarHelper();
      this._addEventListeners();
    }

    // Getters
    static get Default() {
      return Default$6;
    }
    static get DefaultType() {
      return DefaultType$6;
    }
    static get NAME() {
      return NAME$7;
    }

    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown || this._isTransitioning) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._isTransitioning = true;
      this._scrollBar.hide();
      document.body.classList.add(CLASS_NAME_OPEN);
      this._adjustDialog();
      this._backdrop.show(() => this._showElement(relatedTarget));
    }
    hide() {
      if (!this._isShown || this._isTransitioning) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._isShown = false;
      this._isTransitioning = true;
      this._focustrap.deactivate();
      this._element.classList.remove(CLASS_NAME_SHOW$4);
      this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
    }
    dispose() {
      EventHandler.off(window, EVENT_KEY$4);
      EventHandler.off(this._dialog, EVENT_KEY$4);
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }

    // Private
    _initializeBackDrop() {
      return new Backdrop({
        isVisible: Boolean(this._config.backdrop),
        // 'static' option will be translated to true, and booleans will keep their value,
        isAnimated: this._isAnimated()
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
    _showElement(relatedTarget) {
      // try to append dynamic modal
      if (!document.body.contains(this._element)) {
        document.body.append(this._element);
      }
      this._element.style.display = 'block';
      this._element.removeAttribute('aria-hidden');
      this._element.setAttribute('aria-modal', true);
      this._element.setAttribute('role', 'dialog');
      this._element.scrollTop = 0;
      const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
      if (modalBody) {
        modalBody.scrollTop = 0;
      }
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW$4);
      const transitionComplete = () => {
        if (this._config.focus) {
          this._focustrap.activate();
        }
        this._isTransitioning = false;
        EventHandler.trigger(this._element, EVENT_SHOWN$4, {
          relatedTarget
        });
      };
      this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {
        if (event.key !== ESCAPE_KEY$1) {
          return;
        }
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        this._triggerBackdropTransition();
      });
      EventHandler.on(window, EVENT_RESIZE$1, () => {
        if (this._isShown && !this._isTransitioning) {
          this._adjustDialog();
        }
      });
      EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, event => {
        // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks
        EventHandler.one(this._element, EVENT_CLICK_DISMISS, event2 => {
          if (this._element !== event.target || this._element !== event2.target) {
            return;
          }
          if (this._config.backdrop === 'static') {
            this._triggerBackdropTransition();
            return;
          }
          if (this._config.backdrop) {
            this.hide();
          }
        });
      });
    }
    _hideModal() {
      this._element.style.display = 'none';
      this._element.setAttribute('aria-hidden', true);
      this._element.removeAttribute('aria-modal');
      this._element.removeAttribute('role');
      this._isTransitioning = false;
      this._backdrop.hide(() => {
        document.body.classList.remove(CLASS_NAME_OPEN);
        this._resetAdjustments();
        this._scrollBar.reset();
        EventHandler.trigger(this._element, EVENT_HIDDEN$4);
      });
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_FADE$3);
    }
    _triggerBackdropTransition() {
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const initialOverflowY = this._element.style.overflowY;
      // return if the following background transition hasn't yet completed
      if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {
        return;
      }
      if (!isModalOverflowing) {
        this._element.style.overflowY = 'hidden';
      }
      this._element.classList.add(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.classList.remove(CLASS_NAME_STATIC);
        this._queueCallback(() => {
          this._element.style.overflowY = initialOverflowY;
        }, this._dialog);
      }, this._dialog);
      this._element.focus();
    }

    /**
     * The following methods are used to handle overflowing modals
     */

    _adjustDialog() {
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const scrollbarWidth = this._scrollBar.getWidth();
      const isBodyOverflowing = scrollbarWidth > 0;
      if (isBodyOverflowing && !isModalOverflowing) {
        const property = isRTL() ? 'paddingLeft' : 'paddingRight';
        this._element.style[property] = `${scrollbarWidth}px`;
      }
      if (!isBodyOverflowing && isModalOverflowing) {
        const property = isRTL() ? 'paddingRight' : 'paddingLeft';
        this._element.style[property] = `${scrollbarWidth}px`;
      }
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
    }

    // Static
    static jQueryInterface(config, relatedTarget) {
      return this.each(function () {
        const data = Modal.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](relatedTarget);
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }
    EventHandler.one(target, EVENT_SHOW$4, showEvent => {
      if (showEvent.defaultPrevented) {
        // only register focus restorer if modal will actually get shown
        return;
      }
      EventHandler.one(target, EVENT_HIDDEN$4, () => {
        if (isVisible(this)) {
          this.focus();
        }
      });
    });

    // avoid conflict when clicking modal toggler while another one is open
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
    if (alreadyOpen) {
      Modal.getInstance(alreadyOpen).hide();
    }
    const data = Modal.getOrCreateInstance(target);
    data.toggle(this);
  });
  enableDismissTrigger(Modal);

  /**
   * jQuery
   */

  defineJQueryPlugin(Modal);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap offcanvas.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$6 = 'offcanvas';
  const DATA_KEY$3 = 'bs.offcanvas';
  const EVENT_KEY$3 = `.${DATA_KEY$3}`;
  const DATA_API_KEY$1 = '.data-api';
  const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
  const ESCAPE_KEY = 'Escape';
  const CLASS_NAME_SHOW$3 = 'show';
  const CLASS_NAME_SHOWING$1 = 'showing';
  const CLASS_NAME_HIDING = 'hiding';
  const CLASS_NAME_BACKDROP = 'offcanvas-backdrop';
  const OPEN_SELECTOR = '.offcanvas.show';
  const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
  const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
  const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
  const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
  const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
  const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
  const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
  const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
  const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
  const Default$5 = {
    backdrop: true,
    keyboard: true,
    scroll: false
  };
  const DefaultType$5 = {
    backdrop: '(boolean|string)',
    keyboard: 'boolean',
    scroll: 'boolean'
  };

  /**
   * Class definition
   */

  class Offcanvas extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._isShown = false;
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._addEventListeners();
    }

    // Getters
    static get Default() {
      return Default$5;
    }
    static get DefaultType() {
      return DefaultType$5;
    }
    static get NAME() {
      return NAME$6;
    }

    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._backdrop.show();
      if (!this._config.scroll) {
        new ScrollBarHelper().hide();
      }
      this._element.setAttribute('aria-modal', true);
      this._element.setAttribute('role', 'dialog');
      this._element.classList.add(CLASS_NAME_SHOWING$1);
      const completeCallBack = () => {
        if (!this._config.scroll || this._config.backdrop) {
          this._focustrap.activate();
        }
        this._element.classList.add(CLASS_NAME_SHOW$3);
        this._element.classList.remove(CLASS_NAME_SHOWING$1);
        EventHandler.trigger(this._element, EVENT_SHOWN$3, {
          relatedTarget
        });
      };
      this._queueCallback(completeCallBack, this._element, true);
    }
    hide() {
      if (!this._isShown) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._focustrap.deactivate();
      this._element.blur();
      this._isShown = false;
      this._element.classList.add(CLASS_NAME_HIDING);
      this._backdrop.hide();
      const completeCallback = () => {
        this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
        this._element.removeAttribute('aria-modal');
        this._element.removeAttribute('role');
        if (!this._config.scroll) {
          new ScrollBarHelper().reset();
        }
        EventHandler.trigger(this._element, EVENT_HIDDEN$3);
      };
      this._queueCallback(completeCallback, this._element, true);
    }
    dispose() {
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }

    // Private
    _initializeBackDrop() {
      const clickCallback = () => {
        if (this._config.backdrop === 'static') {
          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
          return;
        }
        this.hide();
      };

      // 'static' option will be translated to true, and booleans will keep their value
      const isVisible = Boolean(this._config.backdrop);
      return new Backdrop({
        className: CLASS_NAME_BACKDROP,
        isVisible,
        isAnimated: true,
        rootElement: this._element.parentNode,
        clickCallback: isVisible ? clickCallback : null
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {
        if (event.key !== ESCAPE_KEY) {
          return;
        }
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
      });
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Offcanvas.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$3, () => {
      // focus on trigger when it is closed
      if (isVisible(this)) {
        this.focus();
      }
    });

    // avoid conflict when clicking a toggler of an offcanvas, while another is open
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
    if (alreadyOpen && alreadyOpen !== target) {
      Offcanvas.getInstance(alreadyOpen).hide();
    }
    const data = Offcanvas.getOrCreateInstance(target);
    data.toggle(this);
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
    for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
      Offcanvas.getOrCreateInstance(selector).show();
    }
  });
  EventHandler.on(window, EVENT_RESIZE, () => {
    for (const element of SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')) {
      if (getComputedStyle(element).position !== 'fixed') {
        Offcanvas.getOrCreateInstance(element).hide();
      }
    }
  });
  enableDismissTrigger(Offcanvas);

  /**
   * jQuery
   */

  defineJQueryPlugin(Offcanvas);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/sanitizer.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  // js-docs-start allow-list
  const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  const DefaultAllowlist = {
    // Global attributes allowed on any supplied element below.
    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
    a: ['target', 'href', 'title', 'rel'],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    dd: [],
    div: [],
    dl: [],
    dt: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  };
  // js-docs-end allow-list

  const uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);

  /**
   * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation
   * contexts.
   *
   * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38
   */
  // eslint-disable-next-line unicorn/better-regex
  const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
  const allowedAttribute = (attribute, allowedAttributeList) => {
    const attributeName = attribute.nodeName.toLowerCase();
    if (allowedAttributeList.includes(attributeName)) {
      if (uriAttributes.has(attributeName)) {
        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
      }
      return true;
    }

    // Check if a regular expression validates the attribute.
    return allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp).some(regex => regex.test(attributeName));
  };
  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
    if (!unsafeHtml.length) {
      return unsafeHtml;
    }
    if (sanitizeFunction && typeof sanitizeFunction === 'function') {
      return sanitizeFunction(unsafeHtml);
    }
    const domParser = new window.DOMParser();
    const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
    const elements = [].concat(...createdDocument.body.querySelectorAll('*'));
    for (const element of elements) {
      const elementName = element.nodeName.toLowerCase();
      if (!Object.keys(allowList).includes(elementName)) {
        element.remove();
        continue;
      }
      const attributeList = [].concat(...element.attributes);
      const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);
      for (const attribute of attributeList) {
        if (!allowedAttribute(attribute, allowedAttributes)) {
          element.removeAttribute(attribute.nodeName);
        }
      }
    }
    return createdDocument.body.innerHTML;
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/template-factory.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$5 = 'TemplateFactory';
  const Default$4 = {
    allowList: DefaultAllowlist,
    content: {},
    // { selector : text ,  selector2 : text2 , }
    extraClass: '',
    html: false,
    sanitize: true,
    sanitizeFn: null,
    template: '<div></div>'
  };
  const DefaultType$4 = {
    allowList: 'object',
    content: 'object',
    extraClass: '(string|function)',
    html: 'boolean',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    template: 'string'
  };
  const DefaultContentType = {
    entry: '(string|element|function|null)',
    selector: '(string|element)'
  };

  /**
   * Class definition
   */

  class TemplateFactory extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
    }

    // Getters
    static get Default() {
      return Default$4;
    }
    static get DefaultType() {
      return DefaultType$4;
    }
    static get NAME() {
      return NAME$5;
    }

    // Public
    getContent() {
      return Object.values(this._config.content).map(config => this._resolvePossibleFunction(config)).filter(Boolean);
    }
    hasContent() {
      return this.getContent().length > 0;
    }
    changeContent(content) {
      this._checkContent(content);
      this._config.content = {
        ...this._config.content,
        ...content
      };
      return this;
    }
    toHtml() {
      const templateWrapper = document.createElement('div');
      templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
      for (const [selector, text] of Object.entries(this._config.content)) {
        this._setContent(templateWrapper, text, selector);
      }
      const template = templateWrapper.children[0];
      const extraClass = this._resolvePossibleFunction(this._config.extraClass);
      if (extraClass) {
        template.classList.add(...extraClass.split(' '));
      }
      return template;
    }

    // Private
    _typeCheckConfig(config) {
      super._typeCheckConfig(config);
      this._checkContent(config.content);
    }
    _checkContent(arg) {
      for (const [selector, content] of Object.entries(arg)) {
        super._typeCheckConfig({
          selector,
          entry: content
        }, DefaultContentType);
      }
    }
    _setContent(template, content, selector) {
      const templateElement = SelectorEngine.findOne(selector, template);
      if (!templateElement) {
        return;
      }
      content = this._resolvePossibleFunction(content);
      if (!content) {
        templateElement.remove();
        return;
      }
      if (isElement(content)) {
        this._putElementInTemplate(getElement(content), templateElement);
        return;
      }
      if (this._config.html) {
        templateElement.innerHTML = this._maybeSanitize(content);
        return;
      }
      templateElement.textContent = content;
    }
    _maybeSanitize(arg) {
      return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
    }
    _resolvePossibleFunction(arg) {
      return execute(arg, [this]);
    }
    _putElementInTemplate(element, templateElement) {
      if (this._config.html) {
        templateElement.innerHTML = '';
        templateElement.append(element);
        return;
      }
      templateElement.textContent = element.textContent;
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap tooltip.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$4 = 'tooltip';
  const DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);
  const CLASS_NAME_FADE$2 = 'fade';
  const CLASS_NAME_MODAL = 'modal';
  const CLASS_NAME_SHOW$2 = 'show';
  const SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
  const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
  const EVENT_MODAL_HIDE = 'hide.bs.modal';
  const TRIGGER_HOVER = 'hover';
  const TRIGGER_FOCUS = 'focus';
  const TRIGGER_CLICK = 'click';
  const TRIGGER_MANUAL = 'manual';
  const EVENT_HIDE$2 = 'hide';
  const EVENT_HIDDEN$2 = 'hidden';
  const EVENT_SHOW$2 = 'show';
  const EVENT_SHOWN$2 = 'shown';
  const EVENT_INSERTED = 'inserted';
  const EVENT_CLICK$1 = 'click';
  const EVENT_FOCUSIN$1 = 'focusin';
  const EVENT_FOCUSOUT$1 = 'focusout';
  const EVENT_MOUSEENTER = 'mouseenter';
  const EVENT_MOUSELEAVE = 'mouseleave';
  const AttachmentMap = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: isRTL() ? 'left' : 'right',
    BOTTOM: 'bottom',
    LEFT: isRTL() ? 'right' : 'left'
  };
  const Default$3 = {
    allowList: DefaultAllowlist,
    animation: true,
    boundary: 'clippingParents',
    container: false,
    customClass: '',
    delay: 0,
    fallbackPlacements: ['top', 'right', 'bottom', 'left'],
    html: false,
    offset: [0, 6],
    placement: 'top',
    popperConfig: null,
    sanitize: true,
    sanitizeFn: null,
    selector: false,
    template: '<div class="tooltip" role="tooltip">' + '<div class="tooltip-arrow"></div>' + '<div class="tooltip-inner"></div>' + '</div>',
    title: '',
    trigger: 'hover focus'
  };
  const DefaultType$3 = {
    allowList: 'object',
    animation: 'boolean',
    boundary: '(string|element)',
    container: '(string|element|boolean)',
    customClass: '(string|function)',
    delay: '(number|object)',
    fallbackPlacements: 'array',
    html: 'boolean',
    offset: '(array|string|function)',
    placement: '(string|function)',
    popperConfig: '(null|object|function)',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    selector: '(string|boolean)',
    template: 'string',
    title: '(string|element|function)',
    trigger: 'string'
  };

  /**
   * Class definition
   */

  class Tooltip extends BaseComponent {
    constructor(element, config) {
      if (typeof Popper === 'undefined') {
        throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org)');
      }
      super(element, config);

      // Private
      this._isEnabled = true;
      this._timeout = 0;
      this._isHovered = null;
      this._activeTrigger = {};
      this._popper = null;
      this._templateFactory = null;
      this._newContent = null;

      // Protected
      this.tip = null;
      this._setListeners();
      if (!this._config.selector) {
        this._fixTitle();
      }
    }

    // Getters
    static get Default() {
      return Default$3;
    }
    static get DefaultType() {
      return DefaultType$3;
    }
    static get NAME() {
      return NAME$4;
    }

    // Public
    enable() {
      this._isEnabled = true;
    }
    disable() {
      this._isEnabled = false;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle() {
      if (!this._isEnabled) {
        return;
      }
      this._activeTrigger.click = !this._activeTrigger.click;
      if (this._isShown()) {
        this._leave();
        return;
      }
      this._enter();
    }
    dispose() {
      clearTimeout(this._timeout);
      EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
      if (this._element.getAttribute('data-bs-original-title')) {
        this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));
      }
      this._disposePopper();
      super.dispose();
    }
    show() {
      if (this._element.style.display === 'none') {
        throw new Error('Please use show on visible elements');
      }
      if (!(this._isWithContent() && this._isEnabled)) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
      const shadowRoot = findShadowRoot(this._element);
      const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
      if (showEvent.defaultPrevented || !isInTheDom) {
        return;
      }

      // TODO: v6 remove this or make it optional
      this._disposePopper();
      const tip = this._getTipElement();
      this._element.setAttribute('aria-describedby', tip.getAttribute('id'));
      const {
        container
      } = this._config;
      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
        container.append(tip);
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
      }
      this._popper = this._createPopper(tip);
      tip.classList.add(CLASS_NAME_SHOW$2);

      // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
      if ('ontouchstart' in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.on(element, 'mouseover', noop$1);
        }
      }
      const complete = () => {
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
        if (this._isHovered === false) {
          this._leave();
        }
        this._isHovered = false;
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
    hide() {
      if (!this._isShown()) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
      if (hideEvent.defaultPrevented) {
        return;
      }
      const tip = this._getTipElement();
      tip.classList.remove(CLASS_NAME_SHOW$2);

      // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support
      if ('ontouchstart' in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.off(element, 'mouseover', noop$1);
        }
      }
      this._activeTrigger[TRIGGER_CLICK] = false;
      this._activeTrigger[TRIGGER_FOCUS] = false;
      this._activeTrigger[TRIGGER_HOVER] = false;
      this._isHovered = null; // it is a trick to support manual triggering

      const complete = () => {
        if (this._isWithActiveTrigger()) {
          return;
        }
        if (!this._isHovered) {
          this._disposePopper();
        }
        this._element.removeAttribute('aria-describedby');
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
    update() {
      if (this._popper) {
        this._popper.update();
      }
    }

    // Protected
    _isWithContent() {
      return Boolean(this._getTitle());
    }
    _getTipElement() {
      if (!this.tip) {
        this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
      }
      return this.tip;
    }
    _createTipElement(content) {
      const tip = this._getTemplateFactory(content).toHtml();

      // TODO: remove this check in v6
      if (!tip) {
        return null;
      }
      tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
      // TODO: v6 the following can be achieved with CSS only
      tip.classList.add(`bs-${this.constructor.NAME}-auto`);
      const tipId = getUID(this.constructor.NAME).toString();
      tip.setAttribute('id', tipId);
      if (this._isAnimated()) {
        tip.classList.add(CLASS_NAME_FADE$2);
      }
      return tip;
    }
    setContent(content) {
      this._newContent = content;
      if (this._isShown()) {
        this._disposePopper();
        this.show();
      }
    }
    _getTemplateFactory(content) {
      if (this._templateFactory) {
        this._templateFactory.changeContent(content);
      } else {
        this._templateFactory = new TemplateFactory({
          ...this._config,
          // the `content` var has to be after `this._config`
          // to override config.content in case of popover
          content,
          extraClass: this._resolvePossibleFunction(this._config.customClass)
        });
      }
      return this._templateFactory;
    }
    _getContentForTemplate() {
      return {
        [SELECTOR_TOOLTIP_INNER]: this._getTitle()
      };
    }
    _getTitle() {
      return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title');
    }

    // Private
    _initializeOnDelegatedTarget(event) {
      return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
    }
    _isAnimated() {
      return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
    }
    _isShown() {
      return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
    }
    _createPopper(tip) {
      const placement = execute(this._config.placement, [this, tip, this._element]);
      const attachment = AttachmentMap[placement.toUpperCase()];
      return createPopper(this._element, tip, this._getPopperConfig(attachment));
    }
    _getOffset() {
      const {
        offset
      } = this._config;
      if (typeof offset === 'string') {
        return offset.split(',').map(value => Number.parseInt(value, 10));
      }
      if (typeof offset === 'function') {
        return popperData => offset(popperData, this._element);
      }
      return offset;
    }
    _resolvePossibleFunction(arg) {
      return execute(arg, [this._element]);
    }
    _getPopperConfig(attachment) {
      const defaultBsPopperConfig = {
        placement: attachment,
        modifiers: [{
          name: 'flip',
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: 'offset',
          options: {
            offset: this._getOffset()
          }
        }, {
          name: 'preventOverflow',
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: 'arrow',
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        }, {
          name: 'preSetPlacement',
          enabled: true,
          phase: 'beforeMain',
          fn: data => {
            // Pre-set Popper's placement attribute in order to read the arrow sizes properly.
            // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement
            this._getTipElement().setAttribute('data-popper-placement', data.state.placement);
          }
        }]
      };
      return {
        ...defaultBsPopperConfig,
        ...execute(this._config.popperConfig, [defaultBsPopperConfig])
      };
    }
    _setListeners() {
      const triggers = this._config.trigger.split(' ');
      for (const trigger of triggers) {
        if (trigger === 'click') {
          EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, event => {
            const context = this._initializeOnDelegatedTarget(event);
            context.toggle();
          });
        } else if (trigger !== TRIGGER_MANUAL) {
          const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
          const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
          EventHandler.on(this._element, eventIn, this._config.selector, event => {
            const context = this._initializeOnDelegatedTarget(event);
            context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
            context._enter();
          });
          EventHandler.on(this._element, eventOut, this._config.selector, event => {
            const context = this._initializeOnDelegatedTarget(event);
            context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
            context._leave();
          });
        }
      }
      this._hideModalHandler = () => {
        if (this._element) {
          this.hide();
        }
      };
      EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    }
    _fixTitle() {
      const title = this._element.getAttribute('title');
      if (!title) {
        return;
      }
      if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {
        this._element.setAttribute('aria-label', title);
      }
      this._element.setAttribute('data-bs-original-title', title); // DO NOT USE IT. Is only for backwards compatibility
      this._element.removeAttribute('title');
    }
    _enter() {
      if (this._isShown() || this._isHovered) {
        this._isHovered = true;
        return;
      }
      this._isHovered = true;
      this._setTimeout(() => {
        if (this._isHovered) {
          this.show();
        }
      }, this._config.delay.show);
    }
    _leave() {
      if (this._isWithActiveTrigger()) {
        return;
      }
      this._isHovered = false;
      this._setTimeout(() => {
        if (!this._isHovered) {
          this.hide();
        }
      }, this._config.delay.hide);
    }
    _setTimeout(handler, timeout) {
      clearTimeout(this._timeout);
      this._timeout = setTimeout(handler, timeout);
    }
    _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).includes(true);
    }
    _getConfig(config) {
      const dataAttributes = Manipulator.getDataAttributes(this._element);
      for (const dataAttribute of Object.keys(dataAttributes)) {
        if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
          delete dataAttributes[dataAttribute];
        }
      }
      config = {
        ...dataAttributes,
        ...(typeof config === 'object' && config ? config : {})
      };
      config = this._mergeConfigObj(config);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
    _configAfterMerge(config) {
      config.container = config.container === false ? document.body : getElement(config.container);
      if (typeof config.delay === 'number') {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }
      if (typeof config.title === 'number') {
        config.title = config.title.toString();
      }
      if (typeof config.content === 'number') {
        config.content = config.content.toString();
      }
      return config;
    }
    _getDelegateConfig() {
      const config = {};
      for (const [key, value] of Object.entries(this._config)) {
        if (this.constructor.Default[key] !== value) {
          config[key] = value;
        }
      }
      config.selector = false;
      config.trigger = 'manual';

      // In the future can be replaced with:
      // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
      // `Object.fromEntries(keysWithDifferentValues)`
      return config;
    }
    _disposePopper() {
      if (this._popper) {
        this._popper.destroy();
        this._popper = null;
      }
      if (this.tip) {
        this.tip.remove();
        this.tip = null;
      }
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Tooltip.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  }

  /**
   * jQuery
   */

  defineJQueryPlugin(Tooltip);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap popover.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$3 = 'popover';
  const SELECTOR_TITLE = '.popover-header';
  const SELECTOR_CONTENT = '.popover-body';
  const Default$2 = {
    ...Tooltip.Default,
    content: '',
    offset: [0, 8],
    placement: 'right',
    template: '<div class="popover" role="tooltip">' + '<div class="popover-arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div>' + '</div>',
    trigger: 'click'
  };
  const DefaultType$2 = {
    ...Tooltip.DefaultType,
    content: '(null|string|element|function)'
  };

  /**
   * Class definition
   */

  class Popover extends Tooltip {
    // Getters
    static get Default() {
      return Default$2;
    }
    static get DefaultType() {
      return DefaultType$2;
    }
    static get NAME() {
      return NAME$3;
    }

    // Overrides
    _isWithContent() {
      return this._getTitle() || this._getContent();
    }

    // Private
    _getContentForTemplate() {
      return {
        [SELECTOR_TITLE]: this._getTitle(),
        [SELECTOR_CONTENT]: this._getContent()
      };
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Popover.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  }

  /**
   * jQuery
   */

  defineJQueryPlugin(Popover);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap scrollspy.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$2 = 'scrollspy';
  const DATA_KEY$2 = 'bs.scrollspy';
  const EVENT_KEY$2 = `.${DATA_KEY$2}`;
  const DATA_API_KEY = '.data-api';
  const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
  const EVENT_CLICK = `click${EVENT_KEY$2}`;
  const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
  const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
  const CLASS_NAME_ACTIVE$1 = 'active';
  const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
  const SELECTOR_TARGET_LINKS = '[href]';
  const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
  const SELECTOR_NAV_LINKS = '.nav-link';
  const SELECTOR_NAV_ITEMS = '.nav-item';
  const SELECTOR_LIST_ITEMS = '.list-group-item';
  const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
  const SELECTOR_DROPDOWN = '.dropdown';
  const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';
  const Default$1 = {
    offset: null,
    // TODO: v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: '0px 0px -25%',
    smoothScroll: false,
    target: null,
    threshold: [0.1, 0.5, 1]
  };
  const DefaultType$1 = {
    offset: '(number|null)',
    // TODO v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: 'string',
    smoothScroll: 'boolean',
    target: 'element',
    threshold: 'array'
  };

  /**
   * Class definition
   */

  class ScrollSpy extends BaseComponent {
    constructor(element, config) {
      super(element, config);

      // this._element is the observablesContainer and config.target the menu links wrapper
      this._targetLinks = new Map();
      this._observableSections = new Map();
      this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element;
      this._activeTarget = null;
      this._observer = null;
      this._previousScrollData = {
        visibleEntryTop: 0,
        parentScrollTop: 0
      };
      this.refresh(); // initialize
    }

    // Getters
    static get Default() {
      return Default$1;
    }
    static get DefaultType() {
      return DefaultType$1;
    }
    static get NAME() {
      return NAME$2;
    }

    // Public
    refresh() {
      this._initializeTargetsAndObservables();
      this._maybeEnableSmoothScroll();
      if (this._observer) {
        this._observer.disconnect();
      } else {
        this._observer = this._getNewObserver();
      }
      for (const section of this._observableSections.values()) {
        this._observer.observe(section);
      }
    }
    dispose() {
      this._observer.disconnect();
      super.dispose();
    }

    // Private
    _configAfterMerge(config) {
      // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case
      config.target = getElement(config.target) || document.body;

      // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only
      config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;
      if (typeof config.threshold === 'string') {
        config.threshold = config.threshold.split(',').map(value => Number.parseFloat(value));
      }
      return config;
    }
    _maybeEnableSmoothScroll() {
      if (!this._config.smoothScroll) {
        return;
      }

      // unregister any previous listeners
      EventHandler.off(this._config.target, EVENT_CLICK);
      EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, event => {
        const observableSection = this._observableSections.get(event.target.hash);
        if (observableSection) {
          event.preventDefault();
          const root = this._rootElement || window;
          const height = observableSection.offsetTop - this._element.offsetTop;
          if (root.scrollTo) {
            root.scrollTo({
              top: height,
              behavior: 'smooth'
            });
            return;
          }

          // Chrome 60 doesn't support `scrollTo`
          root.scrollTop = height;
        }
      });
    }
    _getNewObserver() {
      const options = {
        root: this._rootElement,
        threshold: this._config.threshold,
        rootMargin: this._config.rootMargin
      };
      return new IntersectionObserver(entries => this._observerCallback(entries), options);
    }

    // The logic of selection
    _observerCallback(entries) {
      const targetElement = entry => this._targetLinks.get(`#${entry.target.id}`);
      const activate = entry => {
        this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
        this._process(targetElement(entry));
      };
      const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
      const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
      this._previousScrollData.parentScrollTop = parentScrollTop;
      for (const entry of entries) {
        if (!entry.isIntersecting) {
          this._activeTarget = null;
          this._clearActiveClass(targetElement(entry));
          continue;
        }
        const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
        // if we are scrolling down, pick the bigger offsetTop
        if (userScrollsDown && entryIsLowerThanPrevious) {
          activate(entry);
          // if parent isn't scrolled, let's keep the first visible item, breaking the iteration
          if (!parentScrollTop) {
            return;
          }
          continue;
        }

        // if we are scrolling up, pick the smallest offsetTop
        if (!userScrollsDown && !entryIsLowerThanPrevious) {
          activate(entry);
        }
      }
    }
    _initializeTargetsAndObservables() {
      this._targetLinks = new Map();
      this._observableSections = new Map();
      const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
      for (const anchor of targetLinks) {
        // ensure that the anchor has an id and is not disabled
        if (!anchor.hash || isDisabled(anchor)) {
          continue;
        }
        const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);

        // ensure that the observableSection exists & is visible
        if (isVisible(observableSection)) {
          this._targetLinks.set(decodeURI(anchor.hash), anchor);
          this._observableSections.set(anchor.hash, observableSection);
        }
      }
    }
    _process(target) {
      if (this._activeTarget === target) {
        return;
      }
      this._clearActiveClass(this._config.target);
      this._activeTarget = target;
      target.classList.add(CLASS_NAME_ACTIVE$1);
      this._activateParents(target);
      EventHandler.trigger(this._element, EVENT_ACTIVATE, {
        relatedTarget: target
      });
    }
    _activateParents(target) {
      // Activate dropdown parents
      if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
        SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
        return;
      }
      for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
        // Set triggered links parents as active
        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
        for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
          item.classList.add(CLASS_NAME_ACTIVE$1);
        }
      }
    }
    _clearActiveClass(parent) {
      parent.classList.remove(CLASS_NAME_ACTIVE$1);
      const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
      for (const node of activeNodes) {
        node.classList.remove(CLASS_NAME_ACTIVE$1);
      }
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = ScrollSpy.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
    for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
      ScrollSpy.getOrCreateInstance(spy);
    }
  });

  /**
   * jQuery
   */

  defineJQueryPlugin(ScrollSpy);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap tab.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$1 = 'tab';
  const DATA_KEY$1 = 'bs.tab';
  const EVENT_KEY$1 = `.${DATA_KEY$1}`;
  const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
  const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
  const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
  const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
  const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
  const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
  const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
  const ARROW_LEFT_KEY = 'ArrowLeft';
  const ARROW_RIGHT_KEY = 'ArrowRight';
  const ARROW_UP_KEY = 'ArrowUp';
  const ARROW_DOWN_KEY = 'ArrowDown';
  const HOME_KEY = 'Home';
  const END_KEY = 'End';
  const CLASS_NAME_ACTIVE = 'active';
  const CLASS_NAME_FADE$1 = 'fade';
  const CLASS_NAME_SHOW$1 = 'show';
  const CLASS_DROPDOWN = 'dropdown';
  const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
  const SELECTOR_DROPDOWN_MENU = '.dropdown-menu';
  const NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
  const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
  const SELECTOR_OUTER = '.nav-item, .list-group-item';
  const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
  const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; // TODO: could only be `tab` in v6
  const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
  const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;

  /**
   * Class definition
   */

  class Tab extends BaseComponent {
    constructor(element) {
      super(element);
      this._parent = this._element.closest(SELECTOR_TAB_PANEL);
      if (!this._parent) {
        return;
        // TODO: should throw exception in v6
        // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)
      }

      // Set up initial aria attributes
      this._setInitialAttributes(this._parent, this._getChildren());
      EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));
    }

    // Getters
    static get NAME() {
      return NAME$1;
    }

    // Public
    show() {
      // Shows this elem and deactivate the active sibling if exists
      const innerElem = this._element;
      if (this._elemIsActive(innerElem)) {
        return;
      }

      // Search for active tab on same parent to deactivate it
      const active = this._getActiveElem();
      const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
        relatedTarget: innerElem
      }) : null;
      const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
        relatedTarget: active
      });
      if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
        return;
      }
      this._deactivate(active, innerElem);
      this._activate(innerElem, active);
    }

    // Private
    _activate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.add(CLASS_NAME_ACTIVE);
      this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section

      const complete = () => {
        if (element.getAttribute('role') !== 'tab') {
          element.classList.add(CLASS_NAME_SHOW$1);
          return;
        }
        element.removeAttribute('tabindex');
        element.setAttribute('aria-selected', true);
        this._toggleDropDown(element, true);
        EventHandler.trigger(element, EVENT_SHOWN$1, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _deactivate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.remove(CLASS_NAME_ACTIVE);
      element.blur();
      this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too

      const complete = () => {
        if (element.getAttribute('role') !== 'tab') {
          element.classList.remove(CLASS_NAME_SHOW$1);
          return;
        }
        element.setAttribute('aria-selected', false);
        element.setAttribute('tabindex', '-1');
        this._toggleDropDown(element, false);
        EventHandler.trigger(element, EVENT_HIDDEN$1, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _keydown(event) {
      if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {
        return;
      }
      event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page
      event.preventDefault();
      const children = this._getChildren().filter(element => !isDisabled(element));
      let nextActiveElement;
      if ([HOME_KEY, END_KEY].includes(event.key)) {
        nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
      } else {
        const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
        nextActiveElement = getNextActiveElement(children, event.target, isNext, true);
      }
      if (nextActiveElement) {
        nextActiveElement.focus({
          preventScroll: true
        });
        Tab.getOrCreateInstance(nextActiveElement).show();
      }
    }
    _getChildren() {
      // collection of inner elements
      return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
    }
    _getActiveElem() {
      return this._getChildren().find(child => this._elemIsActive(child)) || null;
    }
    _setInitialAttributes(parent, children) {
      this._setAttributeIfNotExists(parent, 'role', 'tablist');
      for (const child of children) {
        this._setInitialAttributesOnChild(child);
      }
    }
    _setInitialAttributesOnChild(child) {
      child = this._getInnerElement(child);
      const isActive = this._elemIsActive(child);
      const outerElem = this._getOuterElement(child);
      child.setAttribute('aria-selected', isActive);
      if (outerElem !== child) {
        this._setAttributeIfNotExists(outerElem, 'role', 'presentation');
      }
      if (!isActive) {
        child.setAttribute('tabindex', '-1');
      }
      this._setAttributeIfNotExists(child, 'role', 'tab');

      // set attributes to the related panel too
      this._setInitialAttributesOnTargetPanel(child);
    }
    _setInitialAttributesOnTargetPanel(child) {
      const target = SelectorEngine.getElementFromSelector(child);
      if (!target) {
        return;
      }
      this._setAttributeIfNotExists(target, 'role', 'tabpanel');
      if (child.id) {
        this._setAttributeIfNotExists(target, 'aria-labelledby', `${child.id}`);
      }
    }
    _toggleDropDown(element, open) {
      const outerElem = this._getOuterElement(element);
      if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
        return;
      }
      const toggle = (selector, className) => {
        const element = SelectorEngine.findOne(selector, outerElem);
        if (element) {
          element.classList.toggle(className, open);
        }
      };
      toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
      toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
      outerElem.setAttribute('aria-expanded', open);
    }
    _setAttributeIfNotExists(element, attribute, value) {
      if (!element.hasAttribute(attribute)) {
        element.setAttribute(attribute, value);
      }
    }
    _elemIsActive(elem) {
      return elem.classList.contains(CLASS_NAME_ACTIVE);
    }

    // Try to get the inner element (usually the .nav-link)
    _getInnerElement(elem) {
      return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
    }

    // Try to get the outer element (usually the .nav-item)
    _getOuterElement(elem) {
      return elem.closest(SELECTOR_OUTER) || elem;
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Tab.getOrCreateInstance(this);
        if (typeof config !== 'string') {
          return;
        }
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    Tab.getOrCreateInstance(this).show();
  });

  /**
   * Initialize on focus
   */
  EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
    for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
      Tab.getOrCreateInstance(element);
    }
  });
  /**
   * jQuery
   */

  defineJQueryPlugin(Tab);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap toast.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME = 'toast';
  const DATA_KEY = 'bs.toast';
  const EVENT_KEY = `.${DATA_KEY}`;
  const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
  const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
  const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
  const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
  const EVENT_HIDE = `hide${EVENT_KEY}`;
  const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  const EVENT_SHOW = `show${EVENT_KEY}`;
  const EVENT_SHOWN = `shown${EVENT_KEY}`;
  const CLASS_NAME_FADE = 'fade';
  const CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility
  const CLASS_NAME_SHOW = 'show';
  const CLASS_NAME_SHOWING = 'showing';
  const DefaultType = {
    animation: 'boolean',
    autohide: 'boolean',
    delay: 'number'
  };
  const Default = {
    animation: true,
    autohide: true,
    delay: 5000
  };

  /**
   * Class definition
   */

  class Toast extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._timeout = null;
      this._hasMouseInteraction = false;
      this._hasKeyboardInteraction = false;
      this._setListeners();
    }

    // Getters
    static get Default() {
      return Default;
    }
    static get DefaultType() {
      return DefaultType;
    }
    static get NAME() {
      return NAME;
    }

    // Public
    show() {
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._clearTimeout();
      if (this._config.animation) {
        this._element.classList.add(CLASS_NAME_FADE);
      }
      const complete = () => {
        this._element.classList.remove(CLASS_NAME_SHOWING);
        EventHandler.trigger(this._element, EVENT_SHOWN);
        this._maybeScheduleHide();
      };
      this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    hide() {
      if (!this.isShown()) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const complete = () => {
        this._element.classList.add(CLASS_NAME_HIDE); // @deprecated
        this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
        EventHandler.trigger(this._element, EVENT_HIDDEN);
      };
      this._element.classList.add(CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    dispose() {
      this._clearTimeout();
      if (this.isShown()) {
        this._element.classList.remove(CLASS_NAME_SHOW);
      }
      super.dispose();
    }
    isShown() {
      return this._element.classList.contains(CLASS_NAME_SHOW);
    }

    // Private

    _maybeScheduleHide() {
      if (!this._config.autohide) {
        return;
      }
      if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
        return;
      }
      this._timeout = setTimeout(() => {
        this.hide();
      }, this._config.delay);
    }
    _onInteraction(event, isInteracting) {
      switch (event.type) {
        case 'mouseover':
        case 'mouseout':
          {
            this._hasMouseInteraction = isInteracting;
            break;
          }
        case 'focusin':
        case 'focusout':
          {
            this._hasKeyboardInteraction = isInteracting;
            break;
          }
      }
      if (isInteracting) {
        this._clearTimeout();
        return;
      }
      const nextElement = event.relatedTarget;
      if (this._element === nextElement || this._element.contains(nextElement)) {
        return;
      }
      this._maybeScheduleHide();
    }
    _setListeners() {
      EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));
      EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));
      EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));
      EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));
    }
    _clearTimeout() {
      clearTimeout(this._timeout);
      this._timeout = null;
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Toast.getOrCreateInstance(this, config);
        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config](this);
        }
      });
    }
  }

  /**
   * Data API implementation
   */

  enableDismissTrigger(Toast);

  /**
   * jQuery
   */

  defineJQueryPlugin(Toast);

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var tuiDatePicker = {exports: {}};

  var tuiTimePicker = {exports: {}};

  /*!
   * TOAST UI Time Picker
   * @version 2.1.6
   * @license MIT
   */

  var hasRequiredTuiTimePicker;

  function requireTuiTimePicker () {
  	if (hasRequiredTuiTimePicker) return tuiTimePicker.exports;
  	hasRequiredTuiTimePicker = 1;
  	(function (module, exports) {
  		(function webpackUniversalModuleDefinition(root, factory) {
  			module.exports = factory();
  		})(window, function() {
  		return /******/ (function(modules) { // webpackBootstrap
  		/******/ 	// The module cache
  		/******/ 	var installedModules = {};
  		/******/
  		/******/ 	// The require function
  		/******/ 	function __webpack_require__(moduleId) {
  		/******/
  		/******/ 		// Check if module is in cache
  		/******/ 		if(installedModules[moduleId]) {
  		/******/ 			return installedModules[moduleId].exports;
  		/******/ 		}
  		/******/ 		// Create a new module (and put it into the cache)
  		/******/ 		var module = installedModules[moduleId] = {
  		/******/ 			i: moduleId,
  		/******/ 			l: false,
  		/******/ 			exports: {}
  		/******/ 		};
  		/******/
  		/******/ 		// Execute the module function
  		/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  		/******/
  		/******/ 		// Flag the module as loaded
  		/******/ 		module.l = true;
  		/******/
  		/******/ 		// Return the exports of the module
  		/******/ 		return module.exports;
  		/******/ 	}
  		/******/
  		/******/
  		/******/ 	// expose the modules object (__webpack_modules__)
  		/******/ 	__webpack_require__.m = modules;
  		/******/
  		/******/ 	// expose the module cache
  		/******/ 	__webpack_require__.c = installedModules;
  		/******/
  		/******/ 	// define getter function for harmony exports
  		/******/ 	__webpack_require__.d = function(exports, name, getter) {
  		/******/ 		if(!__webpack_require__.o(exports, name)) {
  		/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
  		/******/ 		}
  		/******/ 	};
  		/******/
  		/******/ 	// define __esModule on exports
  		/******/ 	__webpack_require__.r = function(exports) {
  		/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  		/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  		/******/ 		}
  		/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
  		/******/ 	};
  		/******/
  		/******/ 	// create a fake namespace object
  		/******/ 	// mode & 1: value is a module id, require it
  		/******/ 	// mode & 2: merge all properties of value into the ns
  		/******/ 	// mode & 4: return value when already ns object
  		/******/ 	// mode & 8|1: behave like require
  		/******/ 	__webpack_require__.t = function(value, mode) {
  		/******/ 		if(mode & 1) value = __webpack_require__(value);
  		/******/ 		if(mode & 8) return value;
  		/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
  		/******/ 		var ns = Object.create(null);
  		/******/ 		__webpack_require__.r(ns);
  		/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
  		/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
  		/******/ 		return ns;
  		/******/ 	};
  		/******/
  		/******/ 	// getDefaultExport function for compatibility with non-harmony modules
  		/******/ 	__webpack_require__.n = function(module) {
  		/******/ 		var getter = module && module.__esModule ?
  		/******/ 			function getDefault() { return module['default']; } :
  		/******/ 			function getModuleExports() { return module; };
  		/******/ 		__webpack_require__.d(getter, 'a', getter);
  		/******/ 		return getter;
  		/******/ 	};
  		/******/
  		/******/ 	// Object.prototype.hasOwnProperty.call
  		/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  		/******/
  		/******/ 	// __webpack_public_path__
  		/******/ 	__webpack_require__.p = "dist";
  		/******/
  		/******/
  		/******/ 	// Load entry module and return exports
  		/******/ 	return __webpack_require__(__webpack_require__.s = 20);
  		/******/ })
  		/************************************************************************/
  		/******/ ([
  		/* 0 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/* eslint-disable complexity */
  		/**
  		 * @fileoverview Returns the first index at which a given element can be found in the array.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var isArray = __webpack_require__(3);

  		/**
  		 * @module array
  		 */

  		/**
  		 * Returns the first index at which a given element can be found in the array
  		 * from start index(default 0), or -1 if it is not present.
  		 * It compares searchElement to elements of the Array using strict equality
  		 * (the same method used by the ===, or triple-equals, operator).
  		 * @param {*} searchElement Element to locate in the array
  		 * @param {Array} array Array that will be traversed.
  		 * @param {number} startIndex Start index in array for searching (default 0)
  		 * @returns {number} the First index at which a given element, or -1 if it is not present
  		 * @memberof module:array
  		 * @example
  		 * var inArray = require('tui-code-snippet/array/inArray'); // node, commonjs
  		 *
  		 * var arr = ['one', 'two', 'three', 'four'];
  		 * var idx1 = inArray('one', arr, 3); // -1
  		 * var idx2 = inArray('one', arr); // 0
  		 */
  		function inArray(searchElement, array, startIndex) {
  		  var i;
  		  var length;
  		  startIndex = startIndex || 0;

  		  if (!isArray(array)) {
  		    return -1;
  		  }

  		  if (Array.prototype.indexOf) {
  		    return Array.prototype.indexOf.call(array, searchElement, startIndex);
  		  }

  		  length = array.length;
  		  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
  		    if (array[i] === searchElement) {
  		      return i;
  		    }
  		  }

  		  return -1;
  		}

  		module.exports = inArray;


  		/***/ }),
  		/* 1 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		/**
  		 * Execute the provided callback once for each element present
  		 * in the array(or Array-like object) in ascending order.
  		 * If the callback function returns false, the loop will be stopped.
  		 * Callback function(iteratee) is invoked with three arguments:
  		 *  1) The value of the element
  		 *  2) The index of the element
  		 *  3) The array(or Array-like object) being traversed
  		 * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed
  		 * @param {function} iteratee Callback function
  		 * @param {Object} [context] Context(this) of callback function
  		 * @memberof module:collection
  		 * @example
  		 * var forEachArray = require('tui-code-snippet/collection/forEachArray'); // node, commonjs
  		 *
  		 * var sum = 0;
  		 *
  		 * forEachArray([1,2,3], function(value){
  		 *     sum += value;
  		 * });
  		 * alert(sum); // 6
  		 */
  		function forEachArray(arr, iteratee, context) {
  		  var index = 0;
  		  var len = arr.length;

  		  context = context || null;

  		  for (; index < len; index += 1) {
  		    if (iteratee.call(context, arr[index], index, arr) === false) {
  		      break;
  		    }
  		  }
  		}

  		module.exports = forEachArray;


  		/***/ }),
  		/* 2 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Extend the target object from other objects.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		/**
  		 * @module object
  		 */

  		/**
  		 * Extend the target object from other objects.
  		 * @param {object} target - Object that will be extended
  		 * @param {...object} objects - Objects as sources
  		 * @returns {object} Extended object
  		 * @memberof module:object
  		 */
  		function extend(target, objects) { // eslint-disable-line no-unused-vars
  		  var hasOwnProp = Object.prototype.hasOwnProperty;
  		  var source, prop, i, len;

  		  for (i = 1, len = arguments.length; i < len; i += 1) {
  		    source = arguments[i];
  		    for (prop in source) {
  		      if (hasOwnProp.call(source, prop)) {
  		        target[prop] = source[prop];
  		      }
  		    }
  		  }

  		  return target;
  		}

  		module.exports = extend;


  		/***/ }),
  		/* 3 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Check whether the given variable is an instance of Array or not.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		/**
  		 * Check whether the given variable is an instance of Array or not.
  		 * If the given variable is an instance of Array, return true.
  		 * @param {*} obj - Target for checking
  		 * @returns {boolean} Is array instance?
  		 * @memberof module:type
  		 */
  		function isArray(obj) {
  		  return obj instanceof Array;
  		}

  		module.exports = isArray;


  		/***/ }),
  		/* 4 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var isArray = __webpack_require__(3);
  		var forEachArray = __webpack_require__(1);
  		var forEachOwnProperties = __webpack_require__(16);

  		/**
  		 * @module collection
  		 */

  		/**
  		 * Execute the provided callback once for each property of object(or element of array) which actually exist.
  		 * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).
  		 * If the callback function returns false, the loop will be stopped.
  		 * Callback function(iteratee) is invoked with three arguments:
  		 *  1) The value of the property(or The value of the element)
  		 *  2) The name of the property(or The index of the element)
  		 *  3) The object being traversed
  		 * @param {Object} obj The object that will be traversed
  		 * @param {function} iteratee Callback function
  		 * @param {Object} [context] Context(this) of callback function
  		 * @memberof module:collection
  		 * @example
  		 * var forEach = require('tui-code-snippet/collection/forEach'); // node, commonjs
  		 *
  		 * var sum = 0;
  		 *
  		 * forEach([1,2,3], function(value){
  		 *     sum += value;
  		 * });
  		 * alert(sum); // 6
  		 *
  		 * // In case of Array-like object
  		 * var array = Array.prototype.slice.call(arrayLike); // change to array
  		 * forEach(array, function(value){
  		 *     sum += value;
  		 * });
  		 */
  		function forEach(obj, iteratee, context) {
  		  if (isArray(obj)) {
  		    forEachArray(obj, iteratee, context);
  		  } else {
  		    forEachOwnProperties(obj, iteratee, context);
  		  }
  		}

  		module.exports = forEach;


  		/***/ }),
  		/* 5 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Check whether the given variable is undefined or not.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		/**
  		 * Check whether the given variable is undefined or not.
  		 * If the given variable is undefined, returns true.
  		 * @param {*} obj - Target for checking
  		 * @returns {boolean} Is undefined?
  		 * @memberof module:type
  		 */
  		function isUndefined(obj) {
  		  return obj === undefined; // eslint-disable-line no-undefined
  		}

  		module.exports = isUndefined;


  		/***/ }),
  		/* 6 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Check whether the given variable is a string or not.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		/**
  		 * Check whether the given variable is a string or not.
  		 * If the given variable is a string, return true.
  		 * @param {*} obj - Target for checking
  		 * @returns {boolean} Is string?
  		 * @memberof module:type
  		 */
  		function isString(obj) {
  		  return typeof obj === 'string' || obj instanceof String;
  		}

  		module.exports = isString;


  		/***/ }),
  		/* 7 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Convert text by binding expressions with context.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var inArray = __webpack_require__(0);
  		var forEach = __webpack_require__(4);
  		var isArray = __webpack_require__(3);
  		var isString = __webpack_require__(6);
  		var extend = __webpack_require__(2);

  		// IE8 does not support capture groups.
  		var EXPRESSION_REGEXP = /{{\s?|\s?}}/g;
  		var BRACKET_NOTATION_REGEXP = /^[a-zA-Z0-9_@]+\[[a-zA-Z0-9_@"']+\]$/;
  		var BRACKET_REGEXP = /\[\s?|\s?\]/;
  		var DOT_NOTATION_REGEXP = /^[a-zA-Z_]+\.[a-zA-Z_]+$/;
  		var DOT_REGEXP = /\./;
  		var STRING_NOTATION_REGEXP = /^["']\w+["']$/;
  		var STRING_REGEXP = /"|'/g;
  		var NUMBER_REGEXP = /^-?\d+\.?\d*$/;

  		var EXPRESSION_INTERVAL = 2;

  		var BLOCK_HELPERS = {
  		  'if': handleIf,
  		  'each': handleEach,
  		  'with': handleWith
  		};

  		var isValidSplit = 'a'.split(/a/).length === 3;

  		/**
  		 * Split by RegExp. (Polyfill for IE8)
  		 * @param {string} text - text to be splitted\
  		 * @param {RegExp} regexp - regular expression
  		 * @returns {Array.<string>}
  		 */
  		var splitByRegExp = (function() {
  		  if (isValidSplit) {
  		    return function(text, regexp) {
  		      return text.split(regexp);
  		    };
  		  }

  		  return function(text, regexp) {
  		    var result = [];
  		    var prevIndex = 0;
  		    var match, index;

  		    if (!regexp.global) {
  		      regexp = new RegExp(regexp, 'g');
  		    }

  		    match = regexp.exec(text);
  		    while (match !== null) {
  		      index = match.index;
  		      result.push(text.slice(prevIndex, index));

  		      prevIndex = index + match[0].length;
  		      match = regexp.exec(text);
  		    }
  		    result.push(text.slice(prevIndex));

  		    return result;
  		  };
  		})();

  		/**
  		 * Find value in the context by an expression.
  		 * @param {string} exp - an expression
  		 * @param {object} context - context
  		 * @returns {*}
  		 * @private
  		 */
  		// eslint-disable-next-line complexity
  		function getValueFromContext(exp, context) {
  		  var splitedExps;
  		  var value = context[exp];

  		  if (exp === 'true') {
  		    value = true;
  		  } else if (exp === 'false') {
  		    value = false;
  		  } else if (STRING_NOTATION_REGEXP.test(exp)) {
  		    value = exp.replace(STRING_REGEXP, '');
  		  } else if (BRACKET_NOTATION_REGEXP.test(exp)) {
  		    splitedExps = exp.split(BRACKET_REGEXP);
  		    value = getValueFromContext(splitedExps[0], context)[getValueFromContext(splitedExps[1], context)];
  		  } else if (DOT_NOTATION_REGEXP.test(exp)) {
  		    splitedExps = exp.split(DOT_REGEXP);
  		    value = getValueFromContext(splitedExps[0], context)[splitedExps[1]];
  		  } else if (NUMBER_REGEXP.test(exp)) {
  		    value = parseFloat(exp);
  		  }

  		  return value;
  		}

  		/**
  		 * Extract elseif and else expressions.
  		 * @param {Array.<string>} ifExps - args of if expression
  		 * @param {Array.<string>} sourcesInsideBlock - sources inside if block
  		 * @returns {object} - exps: expressions of if, elseif, and else / sourcesInsideIf: sources inside if, elseif, and else block.
  		 * @private
  		 */
  		function extractElseif(ifExps, sourcesInsideBlock) {
  		  var exps = [ifExps];
  		  var sourcesInsideIf = [];
  		  var otherIfCount = 0;
  		  var start = 0;

  		  // eslint-disable-next-line complexity
  		  forEach(sourcesInsideBlock, function(source, index) {
  		    if (source.indexOf('if') === 0) {
  		      otherIfCount += 1;
  		    } else if (source === '/if') {
  		      otherIfCount -= 1;
  		    } else if (!otherIfCount && (source.indexOf('elseif') === 0 || source === 'else')) {
  		      exps.push(source === 'else' ? ['true'] : source.split(' ').slice(1));
  		      sourcesInsideIf.push(sourcesInsideBlock.slice(start, index));
  		      start = index + 1;
  		    }
  		  });

  		  sourcesInsideIf.push(sourcesInsideBlock.slice(start));

  		  return {
  		    exps: exps,
  		    sourcesInsideIf: sourcesInsideIf
  		  };
  		}

  		/**
  		 * Helper function for "if". 
  		 * @param {Array.<string>} exps - array of expressions split by spaces
  		 * @param {Array.<string>} sourcesInsideBlock - array of sources inside the if block
  		 * @param {object} context - context
  		 * @returns {string}
  		 * @private
  		 */
  		function handleIf(exps, sourcesInsideBlock, context) {
  		  var analyzed = extractElseif(exps, sourcesInsideBlock);
  		  var result = false;
  		  var compiledSource = '';

  		  forEach(analyzed.exps, function(exp, index) {
  		    result = handleExpression(exp, context);
  		    if (result) {
  		      compiledSource = compile(analyzed.sourcesInsideIf[index], context);
  		    }

  		    return !result;
  		  });

  		  return compiledSource;
  		}

  		/**
  		 * Helper function for "each".
  		 * @param {Array.<string>} exps - array of expressions split by spaces
  		 * @param {Array.<string>} sourcesInsideBlock - array of sources inside the each block
  		 * @param {object} context - context
  		 * @returns {string}
  		 * @private
  		 */
  		function handleEach(exps, sourcesInsideBlock, context) {
  		  var collection = handleExpression(exps, context);
  		  var additionalKey = isArray(collection) ? '@index' : '@key';
  		  var additionalContext = {};
  		  var result = '';

  		  forEach(collection, function(item, key) {
  		    additionalContext[additionalKey] = key;
  		    additionalContext['@this'] = item;
  		    extend(context, additionalContext);

  		    result += compile(sourcesInsideBlock.slice(), context);
  		  });

  		  return result;
  		}

  		/**
  		 * Helper function for "with ... as"
  		 * @param {Array.<string>} exps - array of expressions split by spaces
  		 * @param {Array.<string>} sourcesInsideBlock - array of sources inside the with block
  		 * @param {object} context - context
  		 * @returns {string}
  		 * @private
  		 */
  		function handleWith(exps, sourcesInsideBlock, context) {
  		  var asIndex = inArray('as', exps);
  		  var alias = exps[asIndex + 1];
  		  var result = handleExpression(exps.slice(0, asIndex), context);

  		  var additionalContext = {};
  		  additionalContext[alias] = result;

  		  return compile(sourcesInsideBlock, extend(context, additionalContext)) || '';
  		}

  		/**
  		 * Extract sources inside block in place.
  		 * @param {Array.<string>} sources - array of sources
  		 * @param {number} start - index of start block
  		 * @param {number} end - index of end block
  		 * @returns {Array.<string>}
  		 * @private
  		 */
  		function extractSourcesInsideBlock(sources, start, end) {
  		  var sourcesInsideBlock = sources.splice(start + 1, end - start);
  		  sourcesInsideBlock.pop();

  		  return sourcesInsideBlock;
  		}

  		/**
  		 * Handle block helper function
  		 * @param {string} helperKeyword - helper keyword (ex. if, each, with)
  		 * @param {Array.<string>} sourcesToEnd - array of sources after the starting block
  		 * @param {object} context - context
  		 * @returns {Array.<string>}
  		 * @private
  		 */
  		function handleBlockHelper(helperKeyword, sourcesToEnd, context) {
  		  var executeBlockHelper = BLOCK_HELPERS[helperKeyword];
  		  var helperCount = 1;
  		  var startBlockIndex = 0;
  		  var endBlockIndex;
  		  var index = startBlockIndex + EXPRESSION_INTERVAL;
  		  var expression = sourcesToEnd[index];

  		  while (helperCount && isString(expression)) {
  		    if (expression.indexOf(helperKeyword) === 0) {
  		      helperCount += 1;
  		    } else if (expression.indexOf('/' + helperKeyword) === 0) {
  		      helperCount -= 1;
  		      endBlockIndex = index;
  		    }

  		    index += EXPRESSION_INTERVAL;
  		    expression = sourcesToEnd[index];
  		  }

  		  if (helperCount) {
  		    throw Error(helperKeyword + ' needs {{/' + helperKeyword + '}} expression.');
  		  }

  		  sourcesToEnd[startBlockIndex] = executeBlockHelper(
  		    sourcesToEnd[startBlockIndex].split(' ').slice(1),
  		    extractSourcesInsideBlock(sourcesToEnd, startBlockIndex, endBlockIndex),
  		    context
  		  );

  		  return sourcesToEnd;
  		}

  		/**
  		 * Helper function for "custom helper".
  		 * If helper is not a function, return helper itself.
  		 * @param {Array.<string>} exps - array of expressions split by spaces (first element: helper)
  		 * @param {object} context - context
  		 * @returns {string}
  		 * @private
  		 */
  		function handleExpression(exps, context) {
  		  var result = getValueFromContext(exps[0], context);

  		  if (result instanceof Function) {
  		    return executeFunction(result, exps.slice(1), context);
  		  }

  		  return result;
  		}

  		/**
  		 * Execute a helper function.
  		 * @param {Function} helper - helper function
  		 * @param {Array.<string>} argExps - expressions of arguments
  		 * @param {object} context - context
  		 * @returns {string} - result of executing the function with arguments
  		 * @private
  		 */
  		function executeFunction(helper, argExps, context) {
  		  var args = [];
  		  forEach(argExps, function(exp) {
  		    args.push(getValueFromContext(exp, context));
  		  });

  		  return helper.apply(null, args);
  		}

  		/**
  		 * Get a result of compiling an expression with the context.
  		 * @param {Array.<string>} sources - array of sources split by regexp of expression.
  		 * @param {object} context - context
  		 * @returns {Array.<string>} - array of sources that bind with its context
  		 * @private
  		 */
  		function compile(sources, context) {
  		  var index = 1;
  		  var expression = sources[index];
  		  var exps, firstExp, result;

  		  while (isString(expression)) {
  		    exps = expression.split(' ');
  		    firstExp = exps[0];

  		    if (BLOCK_HELPERS[firstExp]) {
  		      result = handleBlockHelper(firstExp, sources.splice(index, sources.length - index), context);
  		      sources = sources.concat(result);
  		    } else {
  		      sources[index] = handleExpression(exps, context);
  		    }

  		    index += EXPRESSION_INTERVAL;
  		    expression = sources[index];
  		  }

  		  return sources.join('');
  		}

  		/**
  		 * Convert text by binding expressions with context.
  		 * <br>
  		 * If expression exists in the context, it will be replaced.
  		 * ex) '{{title}}' with context {title: 'Hello!'} is converted to 'Hello!'.
  		 * An array or object can be accessed using bracket and dot notation.
  		 * ex) '{{odds\[2\]}}' with context {odds: \[1, 3, 5\]} is converted to '5'.
  		 * ex) '{{evens\[first\]}}' with context {evens: \[2, 4\], first: 0} is converted to '2'.
  		 * ex) '{{project\["name"\]}}' and '{{project.name}}' with context {project: {name: 'CodeSnippet'}} is converted to 'CodeSnippet'.
  		 * <br>
  		 * If replaced expression is a function, next expressions will be arguments of the function.
  		 * ex) '{{add 1 2}}' with context {add: function(a, b) {return a + b;}} is converted to '3'.
  		 * <br>
  		 * It has 3 predefined block helpers '{{helper ...}} ... {{/helper}}': 'if', 'each', 'with ... as ...'.
  		 * 1) 'if' evaluates conditional statements. It can use with 'elseif' and 'else'.
  		 * 2) 'each' iterates an array or object. It provides '@index'(array), '@key'(object), and '@this'(current element).
  		 * 3) 'with ... as ...' provides an alias.
  		 * @param {string} text - text with expressions
  		 * @param {object} context - context
  		 * @returns {string} - text that bind with its context
  		 * @memberof module:domUtil
  		 * @example
  		 * var template = require('tui-code-snippet/domUtil/template');
  		 * 
  		 * var source = 
  		 *     '<h1>'
  		 *   +   '{{if isValidNumber title}}'
  		 *   +     '{{title}}th'
  		 *   +   '{{elseif isValidDate title}}'
  		 *   +     'Date: {{title}}'
  		 *   +   '{{/if}}'
  		 *   + '</h1>'
  		 *   + '{{each list}}'
  		 *   +   '{{with addOne @index as idx}}'
  		 *   +     '<p>{{idx}}: {{@this}}</p>'
  		 *   +   '{{/with}}'
  		 *   + '{{/each}}';
  		 * 
  		 * var context = {
  		 *   isValidDate: function(text) {
  		 *     return /^\d{4}-(0|1)\d-(0|1|2|3)\d$/.test(text);
  		 *   },
  		 *   isValidNumber: function(text) {
  		 *     return /^\d+$/.test(text);
  		 *   }
  		 *   title: '2019-11-25',
  		 *   list: ['Clean the room', 'Wash the dishes'],
  		 *   addOne: function(num) {
  		 *     return num + 1;
  		 *   }
  		 * };
  		 * 
  		 * var result = template(source, context);
  		 * console.log(result); // <h1>Date: 2019-11-25</h1><p>1: Clean the room</p><p>2: Wash the dishes</p>
  		 */
  		function template(text, context) {
  		  return compile(splitByRegExp(text, EXPRESSION_REGEXP), context);
  		}

  		module.exports = template;


  		/***/ }),
  		/* 8 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview This module provides some functions for custom events. And it is implemented in the observer design pattern.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var extend = __webpack_require__(2);
  		var isExisty = __webpack_require__(23);
  		var isString = __webpack_require__(6);
  		var isObject = __webpack_require__(25);
  		var isArray = __webpack_require__(3);
  		var isFunction = __webpack_require__(26);
  		var forEach = __webpack_require__(4);

  		var R_EVENTNAME_SPLIT = /\s+/g;

  		/**
  		 * @class
  		 * @example
  		 * // node, commonjs
  		 * var CustomEvents = require('tui-code-snippet/customEvents/customEvents');
  		 */
  		function CustomEvents() {
  		  /**
  		     * @type {HandlerItem[]}
  		     */
  		  this.events = null;

  		  /**
  		     * only for checking specific context event was binded
  		     * @type {object[]}
  		     */
  		  this.contexts = null;
  		}

  		/**
  		 * Mixin custom events feature to specific constructor
  		 * @param {function} func - constructor
  		 * @example
  		 * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
  		 *
  		 * var model;
  		 * function Model() {
  		 *     this.name = '';
  		 * }
  		 * CustomEvents.mixin(Model);
  		 *
  		 * model = new Model();
  		 * model.on('change', function() { this.name = 'model'; }, this);
  		 * model.fire('change');
  		 * alert(model.name); // 'model';
  		 */
  		CustomEvents.mixin = function(func) {
  		  extend(func.prototype, CustomEvents.prototype);
  		};

  		/**
  		 * Get HandlerItem object
  		 * @param {function} handler - handler function
  		 * @param {object} [context] - context for handler
  		 * @returns {HandlerItem} HandlerItem object
  		 * @private
  		 */
  		CustomEvents.prototype._getHandlerItem = function(handler, context) {
  		  var item = {handler: handler};

  		  if (context) {
  		    item.context = context;
  		  }

  		  return item;
  		};

  		/**
  		 * Get event object safely
  		 * @param {string} [eventName] - create sub event map if not exist.
  		 * @returns {(object|array)} event object. if you supplied `eventName`
  		 *  parameter then make new array and return it
  		 * @private
  		 */
  		CustomEvents.prototype._safeEvent = function(eventName) {
  		  var events = this.events;
  		  var byName;

  		  if (!events) {
  		    events = this.events = {};
  		  }

  		  if (eventName) {
  		    byName = events[eventName];

  		    if (!byName) {
  		      byName = [];
  		      events[eventName] = byName;
  		    }

  		    events = byName;
  		  }

  		  return events;
  		};

  		/**
  		 * Get context array safely
  		 * @returns {array} context array
  		 * @private
  		 */
  		CustomEvents.prototype._safeContext = function() {
  		  var context = this.contexts;

  		  if (!context) {
  		    context = this.contexts = [];
  		  }

  		  return context;
  		};

  		/**
  		 * Get index of context
  		 * @param {object} ctx - context that used for bind custom event
  		 * @returns {number} index of context
  		 * @private
  		 */
  		CustomEvents.prototype._indexOfContext = function(ctx) {
  		  var context = this._safeContext();
  		  var index = 0;

  		  while (context[index]) {
  		    if (ctx === context[index][0]) {
  		      return index;
  		    }

  		    index += 1;
  		  }

  		  return -1;
  		};

  		/**
  		 * Memorize supplied context for recognize supplied object is context or
  		 *  name: handler pair object when off()
  		 * @param {object} ctx - context object to memorize
  		 * @private
  		 */
  		CustomEvents.prototype._memorizeContext = function(ctx) {
  		  var context, index;

  		  if (!isExisty(ctx)) {
  		    return;
  		  }

  		  context = this._safeContext();
  		  index = this._indexOfContext(ctx);

  		  if (index > -1) {
  		    context[index][1] += 1;
  		  } else {
  		    context.push([ctx, 1]);
  		  }
  		};

  		/**
  		 * Forget supplied context object
  		 * @param {object} ctx - context object to forget
  		 * @private
  		 */
  		CustomEvents.prototype._forgetContext = function(ctx) {
  		  var context, contextIndex;

  		  if (!isExisty(ctx)) {
  		    return;
  		  }

  		  context = this._safeContext();
  		  contextIndex = this._indexOfContext(ctx);

  		  if (contextIndex > -1) {
  		    context[contextIndex][1] -= 1;

  		    if (context[contextIndex][1] <= 0) {
  		      context.splice(contextIndex, 1);
  		    }
  		  }
  		};

  		/**
  		 * Bind event handler
  		 * @param {(string|{name:string, handler:function})} eventName - custom
  		 *  event name or an object {eventName: handler}
  		 * @param {(function|object)} [handler] - handler function or context
  		 * @param {object} [context] - context for binding
  		 * @private
  		 */
  		CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
  		  var events = this._safeEvent(eventName);
  		  this._memorizeContext(context);
  		  events.push(this._getHandlerItem(handler, context));
  		};

  		/**
  		 * Bind event handlers
  		 * @param {(string|{name:string, handler:function})} eventName - custom
  		 *  event name or an object {eventName: handler}
  		 * @param {(function|object)} [handler] - handler function or context
  		 * @param {object} [context] - context for binding
  		 * //-- #1. Get Module --//
  		 * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
  		 *
  		 * //-- #2. Use method --//
  		 * // # 2.1 Basic Usage
  		 * CustomEvents.on('onload', handler);
  		 *
  		 * // # 2.2 With context
  		 * CustomEvents.on('onload', handler, myObj);
  		 *
  		 * // # 2.3 Bind by object that name, handler pairs
  		 * CustomEvents.on({
  		 *     'play': handler,
  		 *     'pause': handler2
  		 * });
  		 *
  		 * // # 2.4 Bind by object that name, handler pairs with context object
  		 * CustomEvents.on({
  		 *     'play': handler
  		 * }, myObj);
  		 */
  		CustomEvents.prototype.on = function(eventName, handler, context) {
  		  var self = this;

  		  if (isString(eventName)) {
  		    // [syntax 1, 2]
  		    eventName = eventName.split(R_EVENTNAME_SPLIT);
  		    forEach(eventName, function(name) {
  		      self._bindEvent(name, handler, context);
  		    });
  		  } else if (isObject(eventName)) {
  		    // [syntax 3, 4]
  		    context = handler;
  		    forEach(eventName, function(func, name) {
  		      self.on(name, func, context);
  		    });
  		  }
  		};

  		/**
  		 * Bind one-shot event handlers
  		 * @param {(string|{name:string,handler:function})} eventName - custom
  		 *  event name or an object {eventName: handler}
  		 * @param {function|object} [handler] - handler function or context
  		 * @param {object} [context] - context for binding
  		 */
  		CustomEvents.prototype.once = function(eventName, handler, context) {
  		  var self = this;

  		  if (isObject(eventName)) {
  		    context = handler;
  		    forEach(eventName, function(func, name) {
  		      self.once(name, func, context);
  		    });

  		    return;
  		  }

  		  function onceHandler() { // eslint-disable-line require-jsdoc
  		    handler.apply(context, arguments);
  		    self.off(eventName, onceHandler, context);
  		  }

  		  this.on(eventName, onceHandler, context);
  		};

  		/**
  		 * Splice supplied array by callback result
  		 * @param {array} arr - array to splice
  		 * @param {function} predicate - function return boolean
  		 * @private
  		 */
  		CustomEvents.prototype._spliceMatches = function(arr, predicate) {
  		  var i = 0;
  		  var len;

  		  if (!isArray(arr)) {
  		    return;
  		  }

  		  for (len = arr.length; i < len; i += 1) {
  		    if (predicate(arr[i]) === true) {
  		      arr.splice(i, 1);
  		      len -= 1;
  		      i -= 1;
  		    }
  		  }
  		};

  		/**
  		 * Get matcher for unbind specific handler events
  		 * @param {function} handler - handler function
  		 * @returns {function} handler matcher
  		 * @private
  		 */
  		CustomEvents.prototype._matchHandler = function(handler) {
  		  var self = this;

  		  return function(item) {
  		    var needRemove = handler === item.handler;

  		    if (needRemove) {
  		      self._forgetContext(item.context);
  		    }

  		    return needRemove;
  		  };
  		};

  		/**
  		 * Get matcher for unbind specific context events
  		 * @param {object} context - context
  		 * @returns {function} object matcher
  		 * @private
  		 */
  		CustomEvents.prototype._matchContext = function(context) {
  		  var self = this;

  		  return function(item) {
  		    var needRemove = context === item.context;

  		    if (needRemove) {
  		      self._forgetContext(item.context);
  		    }

  		    return needRemove;
  		  };
  		};

  		/**
  		 * Get matcher for unbind specific hander, context pair events
  		 * @param {function} handler - handler function
  		 * @param {object} context - context
  		 * @returns {function} handler, context matcher
  		 * @private
  		 */
  		CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
  		  var self = this;

  		  return function(item) {
  		    var matchHandler = (handler === item.handler);
  		    var matchContext = (context === item.context);
  		    var needRemove = (matchHandler && matchContext);

  		    if (needRemove) {
  		      self._forgetContext(item.context);
  		    }

  		    return needRemove;
  		  };
  		};

  		/**
  		 * Unbind event by event name
  		 * @param {string} eventName - custom event name to unbind
  		 * @param {function} [handler] - handler function
  		 * @private
  		 */
  		CustomEvents.prototype._offByEventName = function(eventName, handler) {
  		  var self = this;
  		  var andByHandler = isFunction(handler);
  		  var matchHandler = self._matchHandler(handler);

  		  eventName = eventName.split(R_EVENTNAME_SPLIT);

  		  forEach(eventName, function(name) {
  		    var handlerItems = self._safeEvent(name);

  		    if (andByHandler) {
  		      self._spliceMatches(handlerItems, matchHandler);
  		    } else {
  		      forEach(handlerItems, function(item) {
  		        self._forgetContext(item.context);
  		      });

  		      self.events[name] = [];
  		    }
  		  });
  		};

  		/**
  		 * Unbind event by handler function
  		 * @param {function} handler - handler function
  		 * @private
  		 */
  		CustomEvents.prototype._offByHandler = function(handler) {
  		  var self = this;
  		  var matchHandler = this._matchHandler(handler);

  		  forEach(this._safeEvent(), function(handlerItems) {
  		    self._spliceMatches(handlerItems, matchHandler);
  		  });
  		};

  		/**
  		 * Unbind event by object(name: handler pair object or context object)
  		 * @param {object} obj - context or {name: handler} pair object
  		 * @param {function} handler - handler function
  		 * @private
  		 */
  		CustomEvents.prototype._offByObject = function(obj, handler) {
  		  var self = this;
  		  var matchFunc;

  		  if (this._indexOfContext(obj) < 0) {
  		    forEach(obj, function(func, name) {
  		      self.off(name, func);
  		    });
  		  } else if (isString(handler)) {
  		    matchFunc = this._matchContext(obj);

  		    self._spliceMatches(this._safeEvent(handler), matchFunc);
  		  } else if (isFunction(handler)) {
  		    matchFunc = this._matchHandlerAndContext(handler, obj);

  		    forEach(this._safeEvent(), function(handlerItems) {
  		      self._spliceMatches(handlerItems, matchFunc);
  		    });
  		  } else {
  		    matchFunc = this._matchContext(obj);

  		    forEach(this._safeEvent(), function(handlerItems) {
  		      self._spliceMatches(handlerItems, matchFunc);
  		    });
  		  }
  		};

  		/**
  		 * Unbind custom events
  		 * @param {(string|object|function)} eventName - event name or context or
  		 *  {name: handler} pair object or handler function
  		 * @param {(function)} handler - handler function
  		 * @example
  		 * //-- #1. Get Module --//
  		 * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
  		 *
  		 * //-- #2. Use method --//
  		 * // # 2.1 off by event name
  		 * CustomEvents.off('onload');
  		 *
  		 * // # 2.2 off by event name and handler
  		 * CustomEvents.off('play', handler);
  		 *
  		 * // # 2.3 off by handler
  		 * CustomEvents.off(handler);
  		 *
  		 * // # 2.4 off by context
  		 * CustomEvents.off(myObj);
  		 *
  		 * // # 2.5 off by context and handler
  		 * CustomEvents.off(myObj, handler);
  		 *
  		 * // # 2.6 off by context and event name
  		 * CustomEvents.off(myObj, 'onload');
  		 *
  		 * // # 2.7 off by an Object.<string, function> that is {eventName: handler}
  		 * CustomEvents.off({
  		 *   'play': handler,
  		 *   'pause': handler2
  		 * });
  		 *
  		 * // # 2.8 off the all events
  		 * CustomEvents.off();
  		 */
  		CustomEvents.prototype.off = function(eventName, handler) {
  		  if (isString(eventName)) {
  		    // [syntax 1, 2]
  		    this._offByEventName(eventName, handler);
  		  } else if (!arguments.length) {
  		    // [syntax 8]
  		    this.events = {};
  		    this.contexts = [];
  		  } else if (isFunction(eventName)) {
  		    // [syntax 3]
  		    this._offByHandler(eventName);
  		  } else if (isObject(eventName)) {
  		    // [syntax 4, 5, 6]
  		    this._offByObject(eventName, handler);
  		  }
  		};

  		/**
  		 * Fire custom event
  		 * @param {string} eventName - name of custom event
  		 */
  		CustomEvents.prototype.fire = function(eventName) {  // eslint-disable-line
  		  this.invoke.apply(this, arguments);
  		};

  		/**
  		 * Fire a event and returns the result of operation 'boolean AND' with all
  		 *  listener's results.
  		 *
  		 * So, It is different from {@link CustomEvents#fire}.
  		 *
  		 * In service code, use this as a before event in component level usually
  		 *  for notifying that the event is cancelable.
  		 * @param {string} eventName - Custom event name
  		 * @param {...*} data - Data for event
  		 * @returns {boolean} The result of operation 'boolean AND'
  		 * @example
  		 * var map = new Map();
  		 * map.on({
  		 *     'beforeZoom': function() {
  		 *         // It should cancel the 'zoom' event by some conditions.
  		 *         if (that.disabled && this.getState()) {
  		 *             return false;
  		 *         }
  		 *         return true;
  		 *     }
  		 * });
  		 *
  		 * if (this.invoke('beforeZoom')) {    // check the result of 'beforeZoom'
  		 *     // if true,
  		 *     // doSomething
  		 * }
  		 */
  		CustomEvents.prototype.invoke = function(eventName) {
  		  var events, args, index, item;

  		  if (!this.hasListener(eventName)) {
  		    return true;
  		  }

  		  events = this._safeEvent(eventName);
  		  args = Array.prototype.slice.call(arguments, 1);
  		  index = 0;

  		  while (events[index]) {
  		    item = events[index];

  		    if (item.handler.apply(item.context, args) === false) {
  		      return false;
  		    }

  		    index += 1;
  		  }

  		  return true;
  		};

  		/**
  		 * Return whether at least one of the handlers is registered in the given
  		 *  event name.
  		 * @param {string} eventName - Custom event name
  		 * @returns {boolean} Is there at least one handler in event name?
  		 */
  		CustomEvents.prototype.hasListener = function(eventName) {
  		  return this.getListenerLength(eventName) > 0;
  		};

  		/**
  		 * Return a count of events registered.
  		 * @param {string} eventName - Custom event name
  		 * @returns {number} number of event
  		 */
  		CustomEvents.prototype.getListenerLength = function(eventName) {
  		  var events = this._safeEvent(eventName);

  		  return events.length;
  		};

  		module.exports = CustomEvents;


  		/***/ }),
  		/* 9 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview
  		 * This module provides a function to make a constructor
  		 * that can inherit from the other constructors like the CLASS easily.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var inherit = __webpack_require__(27);
  		var extend = __webpack_require__(2);

  		/**
  		 * @module defineClass
  		 */

  		/**
  		 * Help a constructor to be defined and to inherit from the other constructors
  		 * @param {*} [parent] Parent constructor
  		 * @param {Object} props Members of constructor
  		 *  @param {Function} props.init Initialization method
  		 *  @param {Object} [props.static] Static members of constructor
  		 * @returns {*} Constructor
  		 * @memberof module:defineClass
  		 * @example
  		 * var defineClass = require('tui-code-snippet/defineClass/defineClass'); // node, commonjs
  		 *
  		 * //-- #2. Use property --//
  		 * var Parent = defineClass({
  		 *     init: function() { // constuructor
  		 *         this.name = 'made by def';
  		 *     },
  		 *     method: function() {
  		 *         // ...
  		 *     },
  		 *     static: {
  		 *         staticMethod: function() {
  		 *              // ...
  		 *         }
  		 *     }
  		 * });
  		 *
  		 * var Child = defineClass(Parent, {
  		 *     childMethod: function() {}
  		 * });
  		 *
  		 * Parent.staticMethod();
  		 *
  		 * var parentInstance = new Parent();
  		 * console.log(parentInstance.name); //made by def
  		 * parentInstance.staticMethod(); // Error
  		 *
  		 * var childInstance = new Child();
  		 * childInstance.method();
  		 * childInstance.childMethod();
  		 */
  		function defineClass(parent, props) {
  		  var obj;

  		  if (!props) {
  		    props = parent;
  		    parent = null;
  		  }

  		  obj = props.init || function() {};

  		  if (parent) {
  		    inherit(obj, parent);
  		  }

  		  if (props.hasOwnProperty('static')) {
  		    extend(obj, props['static']);
  		    delete props['static'];
  		  }

  		  extend(obj.prototype, props);

  		  return obj;
  		}

  		module.exports = defineClass;


  		/***/ }),
  		/* 10 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Bind DOM events
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var isString = __webpack_require__(6);
  		var forEach = __webpack_require__(4);

  		var safeEvent = __webpack_require__(17);

  		/**
  		 * Bind DOM events.
  		 * @param {HTMLElement} element - element to bind events
  		 * @param {(string|object)} types - Space splitted events names or eventName:handler object
  		 * @param {(function|object)} handler - handler function or context for handler method
  		 * @param {object} [context] context - context for handler method.
  		 * @memberof module:domEvent
  		 * @example
  		 * var div = document.querySelector('div');
  		 * 
  		 * // Bind one event to an element.
  		 * on(div, 'click', toggle);
  		 * 
  		 * // Bind multiple events with a same handler to multiple elements at once.
  		 * // Use event names splitted by a space.
  		 * on(div, 'mouseenter mouseleave', changeColor);
  		 * 
  		 * // Bind multiple events with different handlers to an element at once.
  		 * // Use an object which of key is an event name and value is a handler function.
  		 * on(div, {
  		 *   keydown: highlight,
  		 *   keyup: dehighlight
  		 * });
  		 * 
  		 * // Set a context for handler method.
  		 * var name = 'global';
  		 * var repository = {name: 'CodeSnippet'};
  		 * on(div, 'drag', function() {
  		 *  console.log(this.name);
  		 * }, repository);
  		 * // Result when you drag a div: "CodeSnippet"
  		 */
  		function on(element, types, handler, context) {
  		  if (isString(types)) {
  		    forEach(types.split(/\s+/g), function(type) {
  		      bindEvent(element, type, handler, context);
  		    });

  		    return;
  		  }

  		  forEach(types, function(func, type) {
  		    bindEvent(element, type, func, handler);
  		  });
  		}

  		/**
  		 * Bind DOM events
  		 * @param {HTMLElement} element - element to bind events
  		 * @param {string} type - events name
  		 * @param {function} handler - handler function or context for handler method
  		 * @param {object} [context] context - context for handler method.
  		 * @private
  		 */
  		function bindEvent(element, type, handler, context) {
  		  /**
  		     * Event handler
  		     * @param {Event} e - event object
  		     */
  		  function eventHandler(e) {
  		    handler.call(context || element, e || window.event);
  		  }

  		  if ('addEventListener' in element) {
  		    element.addEventListener(type, eventHandler);
  		  } else if ('attachEvent' in element) {
  		    element.attachEvent('on' + type, eventHandler);
  		  }
  		  memorizeHandler(element, type, handler, eventHandler);
  		}

  		/**
  		 * Memorize DOM event handler for unbinding.
  		 * @param {HTMLElement} element - element to bind events
  		 * @param {string} type - events name
  		 * @param {function} handler - handler function that user passed at on() use
  		 * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features
  		 * @private
  		 */
  		function memorizeHandler(element, type, handler, wrappedHandler) {
  		  var events = safeEvent(element, type);
  		  var existInEvents = false;

  		  forEach(events, function(obj) {
  		    if (obj.handler === handler) {
  		      existInEvents = true;

  		      return false;
  		    }

  		    return true;
  		  });

  		  if (!existInEvents) {
  		    events.push({
  		      handler: handler,
  		      wrappedHandler: wrappedHandler
  		    });
  		  }
  		}

  		module.exports = on;


  		/***/ }),
  		/* 11 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Unbind DOM events
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var isString = __webpack_require__(6);
  		var forEach = __webpack_require__(4);

  		var safeEvent = __webpack_require__(17);

  		/**
  		 * Unbind DOM events
  		 * If a handler function is not passed, remove all events of that type.
  		 * @param {HTMLElement} element - element to unbind events
  		 * @param {(string|object)} types - Space splitted events names or eventName:handler object
  		 * @param {function} [handler] - handler function
  		 * @memberof module:domEvent
  		 * @example
  		 * // Following the example of domEvent#on
  		 * 
  		 * // Unbind one event from an element.
  		 * off(div, 'click', toggle);
  		 * 
  		 * // Unbind multiple events with a same handler from multiple elements at once.
  		 * // Use event names splitted by a space.
  		 * off(element, 'mouseenter mouseleave', changeColor);
  		 * 
  		 * // Unbind multiple events with different handlers from an element at once.
  		 * // Use an object which of key is an event name and value is a handler function.
  		 * off(div, {
  		 *   keydown: highlight,
  		 *   keyup: dehighlight
  		 * });
  		 * 
  		 * // Unbind events without handlers.
  		 * off(div, 'drag');
  		 */
  		function off(element, types, handler) {
  		  if (isString(types)) {
  		    forEach(types.split(/\s+/g), function(type) {
  		      unbindEvent(element, type, handler);
  		    });

  		    return;
  		  }

  		  forEach(types, function(func, type) {
  		    unbindEvent(element, type, func);
  		  });
  		}

  		/**
  		 * Unbind DOM events
  		 * If a handler function is not passed, remove all events of that type.
  		 * @param {HTMLElement} element - element to unbind events
  		 * @param {string} type - events name
  		 * @param {function} [handler] - handler function
  		 * @private
  		 */
  		function unbindEvent(element, type, handler) {
  		  var events = safeEvent(element, type);
  		  var index;

  		  if (!handler) {
  		    forEach(events, function(item) {
  		      removeHandler(element, type, item.wrappedHandler);
  		    });
  		    events.splice(0, events.length);
  		  } else {
  		    forEach(events, function(item, idx) {
  		      if (handler === item.handler) {
  		        removeHandler(element, type, item.wrappedHandler);
  		        index = idx;

  		        return false;
  		      }

  		      return true;
  		    });
  		    events.splice(index, 1);
  		  }
  		}

  		/**
  		 * Remove an event handler
  		 * @param {HTMLElement} element - An element to remove an event
  		 * @param {string} type - event type
  		 * @param {function} handler - event handler
  		 * @private
  		 */
  		function removeHandler(element, type, handler) {
  		  if ('removeEventListener' in element) {
  		    element.removeEventListener(type, handler);
  		  } else if ('detachEvent' in element) {
  		    element.detachEvent('on' + type, handler);
  		  }
  		}

  		module.exports = off;


  		/***/ }),
  		/* 12 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Find parent element recursively
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var matches = __webpack_require__(30);

  		/**
  		 * Find parent element recursively
  		 * @param {HTMLElement} element - base element to start find
  		 * @param {string} selector - selector string for find
  		 * @returns {HTMLElement} - element finded or null
  		 * @memberof module:domUtil
  		 */
  		function closest(element, selector) {
  		  var parent = element.parentNode;

  		  if (matches(element, selector)) {
  		    return element;
  		  }

  		  while (parent && parent !== document) {
  		    if (matches(parent, selector)) {
  		      return parent;
  		    }

  		    parent = parent.parentNode;
  		  }

  		  return null;
  		}

  		module.exports = closest;


  		/***/ }),
  		/* 13 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Remove element from parent node.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		/**
  		 * Remove element from parent node.
  		 * @param {HTMLElement} element - element to remove.
  		 * @memberof module:domUtil
  		 */
  		function removeElement(element) {
  		  if (element && element.parentNode) {
  		    element.parentNode.removeChild(element);
  		  }
  		}

  		module.exports = removeElement;


  		/***/ }),
  		/* 14 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Check whether the given variable is a instance of HTMLNode or not.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		/**
  		 * Check whether the given variable is a instance of HTMLNode or not.
  		 * If the given variables is a instance of HTMLNode, return true.
  		 * @param {*} html - Target for checking
  		 * @returns {boolean} Is HTMLNode ?
  		 * @memberof module:type
  		 */
  		function isHTMLNode(html) {
  		  if (typeof HTMLElement === 'object') {
  		    return (html && (html instanceof HTMLElement || !!html.nodeType));
  		  }

  		  return !!(html && html.nodeType);
  		}

  		module.exports = isHTMLNode;


  		/***/ }),
  		/* 15 */
  		/***/ (function(module, exports, __webpack_require__) {


  		var inArray = __webpack_require__(0);
  		var forEachArray = __webpack_require__(1);
  		var sendHostname = __webpack_require__(35);

  		var uniqueId = 0;

  		/**
  		 * Utils
  		 * @namespace util
  		 * @ignore
  		 */
  		var utils = {
  		  /**
  		   * Returns unique id
  		   * @returns {number}
  		   */
  		  getUniqueId: function() {
  		    uniqueId += 1;

  		    return uniqueId;
  		  },

  		  /**
  		   * Convert a value to meet the format
  		   * @param {number|string} value
  		   * @param {string} format - ex) hh, h, mm, m
  		   * @returns {string}
  		   */
  		  formatTime: function(value, format) {
  		    var PADDING_ZERO_TYPES = ['hh', 'mm'];
  		    value = String(value);

  		    return inArray(format, PADDING_ZERO_TYPES) >= 0 && value.length === 1 ? '0' + value : value;
  		  },

  		  /**
  		   * Get meridiem hour
  		   * @param {number} hour - Original hour
  		   * @returns {number} Converted meridiem hour
  		   */
  		  getMeridiemHour: function(hour) {
  		    hour %= 12;

  		    if (hour === 0) {
  		      hour = 12;
  		    }

  		    return hour;
  		  },

  		  /**
  		   * Returns range arr
  		   * @param {number} start - Start value
  		   * @param {number} end - End value
  		   * @param {number} [step] - Step value
  		   * @returns {Array}
  		   */
  		  getRangeArr: function(start, end, step) {
  		    var arr = [];
  		    var i;

  		    step = step || 1;

  		    if (start > end) {
  		      for (i = end; i >= start; i -= step) {
  		        arr.push(i);
  		      }
  		    } else {
  		      for (i = start; i <= end; i += step) {
  		        arr.push(i);
  		      }
  		    }

  		    return arr;
  		  },

  		  /**
  		   * Returns array filled with selected value
  		   * @param {number} start - Start index of array to fill
  		   * @param {number} end - End index of array to fill
  		   * @param {number} value - Value to be filled
  		   * @param {Array} [target] - Array to fill
  		   * @returns {Array}
  		   */
  		  fill: function(start, end, value, target) {
  		    var arr = target || [];
  		    var replaceEnd = Math.min(arr.length - 1, end);
  		    var i;

  		    for (i = start; i <= replaceEnd; i += 1) {
  		      arr[i] = value;
  		    }

  		    for (i = replaceEnd; i <= end; i += 1) {
  		      arr.push(value);
  		    }

  		    return arr;
  		  },

  		  /**
  		   * Get a target element
  		   * @param {Event} ev Event object
  		   * @returns {HTMLElement} An event target element
  		   */

  		  getTarget: function(ev) {
  		    return ev.target || ev.srcElement;
  		  },

  		  /**
  		   * send host name
  		   * @ignore
  		   */
  		  sendHostName: function() {
  		    sendHostname('time-picker', 'UA-129987462-1');
  		  },

  		  /**
  		   * Get disabled minute array
  		   * @param {Array} enableRanges array of object which contains range
  		   */
  		  getDisabledMinuteArr: function(enableRanges, minuteStep) {
  		    var arr = this.fill(0, Math.floor(60 / minuteStep) - 2, false);

  		    function setDisabled(enableRange) {
  		      var beginDisabledMinute = Math.ceil(enableRange.begin / minuteStep);
  		      var endDisabledMinute = Math.floor(enableRange.end / minuteStep);

  		      arr = this.fill(beginDisabledMinute, endDisabledMinute, true, arr);
  		    }

  		    forEachArray(enableRanges, setDisabled.bind(this));

  		    return arr;
  		  },

  		  /**
  		   * Set disabled on target element
  		   * @param {HTMLInputElement} el target element
  		   * @param {boolean} isDisabled target element
  		   */
  		  setDisabled: function(el, isDisabled) {
  		    el.disabled = isDisabled;
  		  }
  		};

  		module.exports = utils;


  		/***/ }),
  		/* 16 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Execute the provided callback once for each property of object which actually exist.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		/**
  		 * Execute the provided callback once for each property of object which actually exist.
  		 * If the callback function returns false, the loop will be stopped.
  		 * Callback function(iteratee) is invoked with three arguments:
  		 *  1) The value of the property
  		 *  2) The name of the property
  		 *  3) The object being traversed
  		 * @param {Object} obj The object that will be traversed
  		 * @param {function} iteratee  Callback function
  		 * @param {Object} [context] Context(this) of callback function
  		 * @memberof module:collection
  		 * @example
  		 * var forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); // node, commonjs
  		 *
  		 * var sum = 0;
  		 *
  		 * forEachOwnProperties({a:1,b:2,c:3}, function(value){
  		 *     sum += value;
  		 * });
  		 * alert(sum); // 6
  		 */
  		function forEachOwnProperties(obj, iteratee, context) {
  		  var key;

  		  context = context || null;

  		  for (key in obj) {
  		    if (obj.hasOwnProperty(key)) {
  		      if (iteratee.call(context, obj[key], key, obj) === false) {
  		        break;
  		      }
  		    }
  		  }
  		}

  		module.exports = forEachOwnProperties;


  		/***/ }),
  		/* 17 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Get event collection for specific HTML element
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var EVENT_KEY = '_feEventKey';

  		/**
  		 * Get event collection for specific HTML element
  		 * @param {HTMLElement} element - HTML element
  		 * @param {string} type - event type
  		 * @returns {array}
  		 * @private
  		 */
  		function safeEvent(element, type) {
  		  var events = element[EVENT_KEY];
  		  var handlers;

  		  if (!events) {
  		    events = element[EVENT_KEY] = {};
  		  }

  		  handlers = events[type];
  		  if (!handlers) {
  		    handlers = events[type] = [];
  		  }

  		  return handlers;
  		}

  		module.exports = safeEvent;


  		/***/ }),
  		/* 18 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Get HTML element's design classes.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var isUndefined = __webpack_require__(5);

  		/**
  		 * Get HTML element's design classes.
  		 * @param {(HTMLElement|SVGElement)} element target element
  		 * @returns {string} element css class name
  		 * @memberof module:domUtil
  		 */
  		function getClass(element) {
  		  if (!element || !element.className) {
  		    return '';
  		  }

  		  if (isUndefined(element.className.baseVal)) {
  		    return element.className;
  		  }

  		  return element.className.baseVal;
  		}

  		module.exports = getClass;


  		/***/ }),
  		/* 19 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Set className value
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var isArray = __webpack_require__(3);
  		var isUndefined = __webpack_require__(5);

  		/**
  		 * Set className value
  		 * @param {(HTMLElement|SVGElement)} element - target element
  		 * @param {(string|string[])} cssClass - class names
  		 * @private
  		 */
  		function setClassName(element, cssClass) {
  		  cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;

  		  cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

  		  if (isUndefined(element.className.baseVal)) {
  		    element.className = cssClass;

  		    return;
  		  }

  		  element.className.baseVal = cssClass;
  		}

  		module.exports = setClassName;


  		/***/ }),
  		/* 20 */
  		/***/ (function(module, exports, __webpack_require__) {


  		__webpack_require__(21);

  		module.exports = __webpack_require__(22);


  		/***/ }),
  		/* 21 */
  		/***/ (function(module, exports, __webpack_require__) {

  		// extracted by mini-css-extract-plugin

  		/***/ }),
  		/* 22 */
  		/***/ (function(module, exports, __webpack_require__) {


  		var inArray = __webpack_require__(0);
  		var forEachArray = __webpack_require__(1);
  		var CustomEvents = __webpack_require__(8);
  		var defineClass = __webpack_require__(9);
  		var extend = __webpack_require__(2);
  		var on = __webpack_require__(10);
  		var off = __webpack_require__(11);
  		var addClass = __webpack_require__(29);
  		var closest = __webpack_require__(12);
  		var removeElement = __webpack_require__(13);
  		var removeClass = __webpack_require__(32);
  		var isHTMLNode = __webpack_require__(14);
  		var isNumber = __webpack_require__(33);

  		var Spinbox = __webpack_require__(34);
  		var Selectbox = __webpack_require__(38);
  		var util = __webpack_require__(15);
  		var localeTexts = __webpack_require__(40);
  		var tmpl = __webpack_require__(41);
  		var meridiemTmpl = __webpack_require__(42);

  		var SELECTOR_HOUR_ELEMENT = '.tui-timepicker-hour';
  		var SELECTOR_MINUTE_ELEMENT = '.tui-timepicker-minute';
  		var SELECTOR_MERIDIEM_ELEMENT = '.tui-timepicker-meridiem';
  		var CLASS_NAME_LEFT_MERIDIEM = 'tui-has-left';
  		var CLASS_NAME_HIDDEN = 'tui-hidden';
  		var CLASS_NAME_CHECKED = 'tui-timepicker-meridiem-checked';
  		var INPUT_TYPE_SPINBOX = 'spinbox';
  		var INPUT_TYPE_SELECTBOX = 'selectbox';

  		var START_NUMBER_OF_TIME = 0;
  		var END_NUMBER_OF_MINUTE = 59;
  		var END_NUMBER_OF_HOUR = 23;
  		var END_NUMBER_OF_HOUR_WITH_MERIDIEM = 12;

  		/**
  		 * Merge default options
  		 * @ignore
  		 * @param {object} options - options
  		 * @returns {object} Merged options
  		 */
  		var mergeDefaultOptions = function(options) {
  		  return extend(
  		    {
  		      language: 'en',
  		      initialHour: 0,
  		      initialMinute: 0,
  		      showMeridiem: true,
  		      inputType: 'selectbox',
  		      hourStep: 1,
  		      minuteStep: 1,
  		      meridiemPosition: 'right',
  		      format: 'h:m',
  		      disabledHours: [],
  		      disabledMinutes: {},
  		      usageStatistics: true
  		    },
  		    options
  		  );
  		};

  		/**
  		 * @class
  		 * @param {string|HTMLElement} container - Container element or selector
  		 * @param {Object} [options] - Options for initialization
  		 * @param {number} [options.initialHour = 0] - Initial setting value of hour
  		 * @param {number} [options.initialMinute = 0] - Initial setting value of minute
  		 * @param {number} [options.hourStep = 1] - Step value of hour
  		 * @param {number} [options.minuteStep = 1] - Step value of minute
  		 * @param {string} [options.inputType = 'selectbox'] - 'selectbox' or 'spinbox'
  		 * @param {string} [options.format = 'h:m'] - hour, minute format for display
  		 * @param {boolean} [options.showMeridiem = true] - Show meridiem expression?
  		 * @param {Array} [options.disabledHours = []] - Registered Hours is disabled.
  		 * @param {Object} [options.disabledMinutes = {}] - Registered Minutes of selected hours is disabled.
  		 * @param {Object} [options.disabledMinutes.hour] - Key must be hour(number).
  		 *                 Value is array which contains only true or false and must be 60 of length
  		 * @param {string} [options.meridiemPosition = 'right'] - Set location of the meridiem element.
  		 *                 If this option set 'left', the meridiem element is created in front of the hour element.
  		 * @param {string} [options.language = 'en'] Set locale texts
  		 * @param {Boolean} [options.usageStatistics=true|false] send hostname to google analytics [default value is true]
  		 * @example
  		 * // ES6
  		 * import TimePicker from 'tui-time-picker';
  		 *
  		 * // CommonJS
  		 * const TimePicker = require('tui-time-picker');
  		 *
  		 * // Browser
  		 * const TimePicker = tui.TimePicker;
  		 *
  		 * const timepicker = new TimePicker('#timepicker-container', {
  		 *     initialHour: 15,
  		 *     initialMinute: 13,
  		 *     inputType: 'selectbox',
  		 *     showMeridiem: false
  		 * });
  		 */
  		var TimePicker = defineClass(
  		  /** @lends TimePicker.prototype */ {
  		    static: {
  		      /**
  		       * Locale text data
  		       * @type {object}
  		       * @memberof TimePicker
  		       * @static
  		       * @example
  		       * TimePicker.localeTexts['customKey'] = {
  		       *     am: 'a.m.',
  		       *     pm: 'p.m.'
  		       * };
  		       *
  		       * const instance = new TimePicker('#timepicker-container', {
  		       *     language: 'customKey',
  		       * });
  		       */
  		      localeTexts: localeTexts
  		    },
  		    init: function(container, options) {
  		      options = mergeDefaultOptions(options);

  		      /**
  		       * @type {number}
  		       * @private
  		       */
  		      this.id = util.getUniqueId();

  		      /**
  		       * @type {HTMLElement}
  		       * @private
  		       */
  		      this.container = isHTMLNode(container) ? container : document.querySelector(container);

  		      /**
  		       * @type {HTMLElement}
  		       * @private
  		       */
  		      this.element = null;

  		      /**
  		       * @type {HTMLElement}
  		       * @private
  		       */
  		      this.meridiemElement = null;

  		      /**
  		       * @type {HTMLElement}
  		       * @private
  		       */
  		      this.amEl = null;

  		      /**
  		       * @type {HTMLElement}
  		       * @private
  		       */
  		      this.pmEl = null;

  		      /**
  		       * @type {boolean}
  		       * @private
  		       */
  		      this.showMeridiem = options.showMeridiem;

  		      /**
  		       * Meridiem postion
  		       * @type {'left'|'right'}
  		       * @private
  		       */
  		      this.meridiemPosition = options.meridiemPosition;

  		      /**
  		       * @type {Spinbox|Selectbox}
  		       * @private
  		       */
  		      this.hourInput = null;

  		      /**
  		       * @type {Spinbox|Selectbox}
  		       * @private
  		       */
  		      this.minuteInput = null;

  		      /**
  		       * @type {number}
  		       * @private
  		       */
  		      this.hour = options.initialHour;

  		      /**
  		       * @type {number}
  		       * @private
  		       */
  		      this.minute = options.initialMinute;

  		      /**
  		       * @type {number}
  		       * @private
  		       */
  		      this.hourStep = options.hourStep;

  		      /**
  		       * @type {number}
  		       * @private
  		       */
  		      this.minuteStep = options.minuteStep;

  		      /**
  		       * @type {Array}
  		       * @private
  		       */
  		      this.disabledHours = options.disabledHours;

  		      /**
  		       * @type {Object}
  		       * @private
  		       */
  		      this.disabledMinutes = options.disabledMinutes;

  		      /**
  		       * TimePicker inputType
  		       * @type {'spinbox'|'selectbox'}
  		       * @private
  		       */
  		      this.inputType = options.inputType;

  		      /**
  		       * Locale text for meridiem
  		       * @type {string}
  		       * @private
  		       */
  		      this.localeText = localeTexts[options.language];

  		      /**
  		       * Time format for output
  		       * @type {string}
  		       * @private
  		       */
  		      this.format = this.getValidTimeFormat(options.format);

  		      this.render();
  		      this.setEvents();

  		      if (options.usageStatistics) {
  		        util.sendHostName();
  		      }
  		    },

  		    /**
  		     * Set event handlers to selectors, container
  		     * @private
  		     */
  		    setEvents: function() {
  		      this.hourInput.on('change', this.onChangeTimeInput, this);
  		      this.minuteInput.on('change', this.onChangeTimeInput, this);

  		      if (this.showMeridiem) {
  		        if (this.inputType === INPUT_TYPE_SELECTBOX) {
  		          on(this.meridiemElement.querySelector('select'), 'change', this.onChangeMeridiem, this);
  		        } else if (this.inputType === INPUT_TYPE_SPINBOX) {
  		          on(this.meridiemElement, 'click', this.onChangeMeridiem, this);
  		        }
  		      }
  		    },

  		    /**
  		     * Remove events
  		     * @private
  		     */
  		    removeEvents: function() {
  		      this.off();

  		      this.hourInput.destroy();
  		      this.minuteInput.destroy();

  		      if (this.showMeridiem) {
  		        if (this.inputType === INPUT_TYPE_SELECTBOX) {
  		          off(this.meridiemElement.querySelector('select'), 'change', this.onChangeMeridiem, this);
  		        } else if (this.inputType === INPUT_TYPE_SPINBOX) {
  		          off(this.meridiemElement, 'click', this.onChangeMeridiem, this);
  		        }
  		      }
  		    },

  		    /**
  		     * Render element
  		     * @private
  		     */
  		    render: function() {
  		      var context = {
  		        showMeridiem: this.showMeridiem,
  		        isSpinbox: this.inputType === 'spinbox'
  		      };

  		      if (this.showMeridiem) {
  		        extend(context, {
  		          meridiemElement: this.makeMeridiemHTML()
  		        });
  		      }

  		      if (this.element) {
  		        removeElement(this.element);
  		      }
  		      this.container.innerHTML = tmpl(context);
  		      this.element = this.container.firstChild;

  		      this.renderTimeInputs();

  		      if (this.showMeridiem) {
  		        this.setMeridiemElement();
  		      }
  		    },

  		    /**
  		     * Set meridiem element on timepicker
  		     * @private
  		     */
  		    setMeridiemElement: function() {
  		      if (this.meridiemPosition === 'left') {
  		        addClass(this.element, CLASS_NAME_LEFT_MERIDIEM);
  		      }
  		      this.meridiemElement = this.element.querySelector(SELECTOR_MERIDIEM_ELEMENT);
  		      this.amEl = this.meridiemElement.querySelector('[value="AM"]');
  		      this.pmEl = this.meridiemElement.querySelector('[value="PM"]');
  		      this.syncToMeridiemElements();
  		    },

  		    /**
  		     * Make html for meridiem element
  		     * @returns {HTMLElement} Meridiem element
  		     * @private
  		     */
  		    makeMeridiemHTML: function() {
  		      var localeText = this.localeText;

  		      return meridiemTmpl({
  		        am: localeText.am,
  		        pm: localeText.pm,
  		        radioId: this.id,
  		        isSpinbox: this.inputType === 'spinbox'
  		      });
  		    },

  		    /**
  		     * Render time selectors
  		     * @private
  		     */
  		    renderTimeInputs: function() {
  		      var hour = this.hour;
  		      var showMeridiem = this.showMeridiem;
  		      var hourElement = this.element.querySelector(SELECTOR_HOUR_ELEMENT);
  		      var minuteElement = this.element.querySelector(SELECTOR_MINUTE_ELEMENT);
  		      var BoxComponent = this.inputType.toLowerCase() === 'selectbox' ? Selectbox : Spinbox;
  		      var formatExplode = this.format.split(':');
  		      var hourItems = this.getHourItems();

  		      if (showMeridiem) {
  		        hour = util.getMeridiemHour(hour);
  		      }

  		      this.hourInput = new BoxComponent(hourElement, {
  		        initialValue: hour,
  		        items: hourItems,
  		        format: formatExplode[0],
  		        disabledItems: this.makeDisabledStatItems(hourItems)
  		      });

  		      this.minuteInput = new BoxComponent(minuteElement, {
  		        initialValue: this.minute,
  		        items: this.getMinuteItems(),
  		        format: formatExplode[1]
  		      });
  		    },

  		    makeDisabledStatItems: function(hourItems) {
  		      var result = [];
  		      var disabledHours = this.disabledHours.slice();

  		      if (this.showMeridiem) {
  		        disabledHours = this.meridiemableTime(disabledHours);
  		      }

  		      forEachArray(hourItems, function(hour) {
  		        result.push(inArray(hour, disabledHours) >= 0);
  		      });

  		      return result;
  		    },

  		    meridiemableTime: function(disabledHours) {
  		      var diffHour = 0;
  		      var startHour = 0;
  		      var endHour = 11;
  		      var result = [];

  		      if (this.hour >= 12) {
  		        diffHour = 12;
  		        startHour = 12;
  		        endHour = 23;
  		      }

  		      forEachArray(disabledHours, function(hour) {
  		        if (hour >= startHour && hour <= endHour) {
  		          result.push(hour - diffHour === 0 ? 12 : hour - diffHour);
  		        }
  		      });

  		      return result;
  		    },

  		    /**
  		     * Return formatted format.
  		     * @param {string} format - format option
  		     * @returns {string}
  		     * @private
  		     */
  		    getValidTimeFormat: function(format) {
  		      if (!format.match(/^[h]{1,2}:[m]{1,2}$/i)) {
  		        return 'h:m';
  		      }

  		      return format.toLowerCase();
  		    },

  		    /**
  		     * Initialize meridiem elements
  		     * @private
  		     */
  		    syncToMeridiemElements: function() {
  		      var selectedEl = this.hour >= 12 ? this.pmEl : this.amEl;
  		      var notSelectedEl = selectedEl === this.pmEl ? this.amEl : this.pmEl;

  		      selectedEl.setAttribute('selected', true);
  		      selectedEl.setAttribute('checked', true);
  		      addClass(selectedEl, CLASS_NAME_CHECKED);
  		      notSelectedEl.removeAttribute('selected');
  		      notSelectedEl.removeAttribute('checked');
  		      removeClass(notSelectedEl, CLASS_NAME_CHECKED);
  		    },

  		    /**
  		     * Set values in spinboxes from time
  		     * @private
  		     */
  		    syncToInputs: function() {
  		      var hour = this.hour;
  		      var minute = this.minute;

  		      if (this.showMeridiem) {
  		        hour = util.getMeridiemHour(hour);
  		      }

  		      this.hourInput.setValue(hour, true);
  		      this.minuteInput.setValue(minute, true);
  		    },

  		    /**
  		     * DOM event handler
  		     * @param {Event} ev - Change event on meridiem element
  		     * @private
  		     */
  		    onChangeMeridiem: function(ev) {
  		      var hour = this.hour;
  		      var target = util.getTarget(ev);

  		      if (target.value && closest(target, SELECTOR_MERIDIEM_ELEMENT)) {
  		        hour = this.to24Hour(target.value === 'PM', hour);
  		        this.setTime(hour, this.minute);
  		        this.setDisabledHours();
  		        this.setDisabledMinutes(hour);
  		      }
  		    },

  		    /**
  		     * Time change event handler
  		     * @private
  		     */
  		    onChangeTimeInput: function() {
  		      var hour = this.hourInput.getValue();
  		      var minute = this.minuteInput.getValue();
  		      var isPM = this.hour >= 12;

  		      if (this.showMeridiem) {
  		        hour = this.to24Hour(isPM, hour);
  		      }
  		      this.setTime(hour, minute);
  		      this.setDisabledMinutes(hour);
  		    },

  		    /**
  		     * 12Hour-expression to 24Hour-expression
  		     * @param {boolean} isPM - Is pm?
  		     * @param {number} hour - Hour
  		     * @returns {number}
  		     * @private
  		     */
  		    to24Hour: function(isPM, hour) {
  		      hour %= 12;
  		      if (isPM) {
  		        hour += 12;
  		      }

  		      return hour;
  		    },

  		    setDisabledHours: function() {
  		      var hourItems = this.getHourItems();
  		      var disabledItems = this.makeDisabledStatItems(hourItems);

  		      this.hourInput.setDisabledItems(disabledItems);
  		    },

  		    setDisabledMinutes: function(hour) {
  		      var disabledItems;
  		      disabledItems = this.disabledMinutes[hour] || [];

  		      this.minuteInput.setDisabledItems(disabledItems);
  		    },

  		    /**
  		     * Get items of hour
  		     * @returns {array} Hour item list
  		     * @private
  		     */
  		    getHourItems: function() {
  		      var step = this.hourStep;

  		      return this.showMeridiem ? util.getRangeArr(1, 12, step) : util.getRangeArr(0, 23, step);
  		    },

  		    /**
  		     * Get items of minute
  		     * @returns {array} Minute item list
  		     * @private
  		     */
  		    getMinuteItems: function() {
  		      return util.getRangeArr(0, 59, this.minuteStep);
  		    },

  		    /**
  		     * Whether the hour and minute are in valid items or not
  		     * @param {number} hour - Hour value
  		     * @param {number} minute - Minute value
  		     * @returns {boolean} State
  		     * @private
  		     */
  		    validItems: function(hour, minute) {
  		      if (!isNumber(hour) || !isNumber(minute)) {
  		        return false;
  		      }

  		      if (this.showMeridiem) {
  		        hour = util.getMeridiemHour(hour);
  		      }

  		      return inArray(hour, this.getHourItems()) > -1 && inArray(minute, this.getMinuteItems()) > -1;
  		    },

  		    /**
  		     * Set step of hour
  		     * @param {array} step - Step to create items of hour
  		     */
  		    setHourStep: function(step) {
  		      this.hourStep = step;
  		      this.hourInput.fire('changeItems', this.getHourItems());
  		    },

  		    /**
  		     * Get step of hour
  		     * @returns {number} Step of hour
  		     */
  		    getHourStep: function() {
  		      return this.hourStep;
  		    },

  		    /**
  		     * Set step of minute
  		     * @param {number} step - Step to create items of minute
  		     */
  		    setMinuteStep: function(step) {
  		      this.minuteStep = step;
  		      this.minuteInput.fire('changeItems', this.getMinuteItems());
  		    },

  		    /**
  		     * Get step of minute
  		     * @returns {number} Step of minute
  		     */
  		    getMinuteStep: function() {
  		      return this.minuteStep;
  		    },

  		    /**
  		     * Show time picker element
  		     */
  		    show: function() {
  		      removeClass(this.element, CLASS_NAME_HIDDEN);
  		    },

  		    /**
  		     * Hide time picker element
  		     */
  		    hide: function() {
  		      addClass(this.element, CLASS_NAME_HIDDEN);
  		    },

  		    /**
  		     * Set hour
  		     * @param {number} hour for time picker - (0~23)
  		     * @returns {boolean} result of set time
  		     */
  		    setHour: function(hour) {
  		      return this.setTime(hour, this.minute);
  		    },

  		    /**
  		     * Set minute
  		     * @param {number} minute for time picker
  		     * @returns {boolean} result of set time
  		     */
  		    setMinute: function(minute) {
  		      return this.setTime(this.hour, minute);
  		    },

  		    /**
  		     * Set time
  		     * @param {number} hour for time picker - (0~23)
  		     * @param {number} minute for time picker
  		     * @param {boolean} [silent] if it set true, 'change' event will not be fired.
  		     */
  		    setTime: function(hour, minute, silent) {
  		      if (!this.validItems(hour, minute)) {
  		        return;
  		      }

  		      this.hour = hour;
  		      this.minute = minute;

  		      this.syncToInputs();
  		      if (this.showMeridiem) {
  		        this.syncToMeridiemElements();
  		      }

  		      /**
  		       * Change event - TimePicker
  		       * @event TimePicker#change
  		       * @type {object} event - Event object
  		       * @property {number} hour - changed hour
  		       * @property {number} minute - changed minute
  		       * @example
  		       * timepicker.on('change', (e) => {
  		       *   console.log(e.hour, e.minute);
  		       * });
  		       */
  		      if (!silent) {
  		        this.fire('change', {
  		          hour: this.hour,
  		          minute: this.minute
  		        });
  		      }
  		    },

  		    /**
  		     * Set selectable range
  		     * @param {Object} begin - Contain begin hour and minute of range
  		     * @param {number} begin.hour - begin hour of range
  		     * @param {number} begin.minute - begin minute of range
  		     * @param {Object} [end] - Contain end hour and minute of range
  		     * @param {number} end.hour - end hour of range
  		     * @param {number} end.minute - end minute of range
  		     */
  		    setRange: function(begin, end) {
  		      var beginHour = begin.hour;
  		      var beginMin = begin.minute;
  		      var endHour, endMin;

  		      if (!this.isValidRange(begin, end)) {
  		        return;
  		      }

  		      if (end) {
  		        endHour = end.hour;
  		        endMin = end.minute;
  		      }

  		      this.setRangeHour(beginHour, endHour);
  		      this.setRangeMinute(beginHour, beginMin, endHour, endMin);

  		      this.applyRange(beginHour, beginMin, endHour);
  		    },

  		    /**
  		     * Set selectable range on hour
  		     * @param {number} beginHour - begin hour of range
  		     * @param {number} [endHour] - end hour of range
  		     * @private
  		     */
  		    setRangeHour: function(beginHour, endHour) {
  		      var disabledHours = util.getRangeArr(START_NUMBER_OF_TIME, beginHour - 1);

  		      if (endHour) {
  		        disabledHours = disabledHours.concat(util.getRangeArr(endHour + 1, END_NUMBER_OF_HOUR));
  		      }

  		      this.disabledHours = disabledHours.slice();
  		    },

  		    /**
  		     * Set selectable range on minute
  		     * @param {number} beginHour - begin hour of range
  		     * @param {number} beginMin - begin minute of range
  		     * @param {number} [endHour] - end hour of range
  		     * @param {number} [endMin] - end minute of range
  		     * @private
  		     */
  		    setRangeMinute: function(beginHour, beginMin, endHour, endMin) {
  		      var disabledMinRanges = [];

  		      if (!beginHour && !beginMin) {
  		        return;
  		      }

  		      disabledMinRanges.push({
  		        begin: START_NUMBER_OF_TIME,
  		        end: beginMin
  		      });

  		      if (endHour && endMin) {
  		        disabledMinRanges.push({
  		          begin: endMin,
  		          end: END_NUMBER_OF_MINUTE
  		        });

  		        if (beginHour === endHour) {
  		          this.disabledMinutes[beginHour] = util
  		            .getDisabledMinuteArr(disabledMinRanges, this.minuteStep)
  		            .slice();

  		          return;
  		        }

  		        this.disabledMinutes[endHour] = util
  		          .getDisabledMinuteArr([disabledMinRanges[1]], this.minuteStep)
  		          .slice();
  		      }

  		      this.disabledMinutes[beginHour] = util
  		        .getDisabledMinuteArr([disabledMinRanges[0]], this.minuteStep)
  		        .slice();
  		    },

  		    /**
  		     * Apply range
  		     * @param {number} beginHour - begin hour of range
  		     * @param {number} beginMin - begin minute of range
  		     * @param {number} [endHour] - end hour of range
  		     * @private
  		     */
  		    // eslint-disable-next-line complexity
  		    applyRange: function(beginHour, beginMin, endHour) {
  		      var targetMinuteIndex = Math.ceil(beginMin / this.minuteStep);
  		      var targetHour = beginHour;
  		      var targetMinute = targetMinuteIndex * this.minuteStep;
  		      var diffFromSelectableMinute;

  		      if (this.isLaterThanSetTime(beginHour, beginMin)) {
  		        if (this.disabledMinutes[targetHour][targetMinuteIndex]) {
  		          diffFromSelectableMinute =
  		            this.disabledMinutes[targetHour]
  		              .slice(targetMinuteIndex)
  		              .findIndex(function(isMinuteDisabled) {
  		                return !isMinuteDisabled;
  		              }) * this.minuteStep;

  		          targetMinute =
  		            diffFromSelectableMinute >= 0 ? targetMinute + diffFromSelectableMinute : 60;
  		        }

  		        if ((this.hourStep !== 1 && beginHour % this.hourStep !== 1) || targetMinute >= 60) {
  		          targetHour = beginHour + (beginHour % this.hourStep) + 1;
  		          targetMinute = 0;
  		        }

  		        this.setTime(targetHour, targetMinute);
  		      }

  		      this.setDisabledHours();
  		      this.setDisabledMinutes(this.hour);

  		      if (this.showMeridiem) {
  		        this.syncToMeridiemElements();

  		        util.setDisabled(this.amEl, beginHour >= END_NUMBER_OF_HOUR_WITH_MERIDIEM);
  		        util.setDisabled(this.pmEl, endHour < END_NUMBER_OF_HOUR_WITH_MERIDIEM);
  		      }
  		    },

  		    /**
  		     * Reset minute selectable range
  		     */
  		    resetMinuteRange: function() {
  		      var i;

  		      this.disabledMinutes = {};

  		      for (i = 0; i <= END_NUMBER_OF_HOUR; i += 1) {
  		        this.setDisabledMinutes(this.hour);
  		      }
  		    },

  		    /**
  		     * Whether the given range a valid range
  		     * @param {Object} begin - Contain begin hour and minute of range
  		     * @param {number} begin.hour - begin hour of range
  		     * @param {number} begin.minute - begin minute of range
  		     * @param {Object} [end] - Contain end hour and minute of range
  		     * @param {number} end.hour - end hour of range
  		     * @param {number} end.minute - end minute of range
  		     * @returns {boolean} result of range validation
  		     * @private
  		     */
  		    isValidRange: function(begin, end) {
  		      var beginHour = begin.hour;
  		      var beginMin = begin.minute;
  		      var endHour, endMin;

  		      if (!this.isValidTime(beginHour, beginMin)) {
  		        return false;
  		      }

  		      if (!end) {
  		        return true;
  		      }

  		      endHour = end.hour;
  		      endMin = end.minute;

  		      return this.isValidTime(endHour, endMin) && this.compareTimes(begin, end) > 0;
  		    },

  		    /**
  		     * Whether the given time a valid time
  		     * @param {number} hour - hour for validation
  		     * @param {number} minute - minute for validation
  		     * @returns {boolean} result of time validation
  		     * @private
  		     */
  		    isValidTime: function(hour, minute) {
  		      return (
  		        hour >= START_NUMBER_OF_TIME &&
  		        hour <= END_NUMBER_OF_HOUR &&
  		        minute >= START_NUMBER_OF_TIME &&
  		        minute <= END_NUMBER_OF_MINUTE
  		      );
  		    },

  		    /**
  		     * Compare given time with set time
  		     * @param {number} hour - given hour
  		     * @param {number} minute - given minute
  		     * @returns {boolean} result of compare
  		     * @private
  		     */
  		    isLaterThanSetTime: function(hour, minute) {
  		      return hour > this.hour || (hour === this.hour && minute > this.minute);
  		    },

  		    /**
  		     * Compare two times
  		     * it returns
  		     *  0: when begin equals end
  		     *  positive: when end later than begin
  		     *  negative: when begin later than end
  		     * @param {Object} begin - Contain begin hour and minute of range
  		     * @param {number} begin.hour - begin hour of range
  		     * @param {number} begin.minute - begin minute of range
  		     * @param {Object} end - Contain end hour and minute of range
  		     * @param {number} end.hour - end hour of range
  		     * @param {number} end.minute - end minute of range
  		     * @returns {boolean} result of range validation
  		     * @private
  		     */
  		    compareTimes: function(begin, end) {
  		      var first = new Date(0);
  		      var second = new Date(0);

  		      first.setHours(begin.hour, begin.minute);
  		      second.setHours(end.hour, end.minute);

  		      return second.getTime() - first.getTime();
  		    },

  		    /**
  		     * Get hour
  		     * @returns {number} hour - (0~23)
  		     */
  		    getHour: function() {
  		      return this.hour;
  		    },

  		    /**
  		     * Get minute
  		     * @returns {number} minute
  		     */
  		    getMinute: function() {
  		      return this.minute;
  		    },

  		    /**
  		     * Change locale text of meridiem by language code
  		     * @param {string} language - Language code
  		     */
  		    changeLanguage: function(language) {
  		      this.localeText = localeTexts[language];
  		      this.render();
  		    },

  		    /**
  		     * Destroy
  		     */
  		    destroy: function() {
  		      this.removeEvents();
  		      removeElement(this.element);

  		      // eslint-disable-next-line max-len
  		      this.container = this.showMeridiem = this.hourInput = this.minuteInput = this.hour = this.minute = this.inputType = this.element = this.meridiemElement = this.amEl = this.pmEl = null;
  		    }
  		  }
  		);

  		CustomEvents.mixin(TimePicker);
  		module.exports = TimePicker;


  		/***/ }),
  		/* 23 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Check whether the given variable is existing or not.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var isUndefined = __webpack_require__(5);
  		var isNull = __webpack_require__(24);

  		/**
  		 * Check whether the given variable is existing or not.
  		 * If the given variable is not null and not undefined, returns true.
  		 * @param {*} param - Target for checking
  		 * @returns {boolean} Is existy?
  		 * @memberof module:type
  		 * @example
  		 * var isExisty = require('tui-code-snippet/type/isExisty'); // node, commonjs
  		 *
  		 * isExisty(''); //true
  		 * isExisty(0); //true
  		 * isExisty([]); //true
  		 * isExisty({}); //true
  		 * isExisty(null); //false
  		 * isExisty(undefined); //false
  		*/
  		function isExisty(param) {
  		  return !isUndefined(param) && !isNull(param);
  		}

  		module.exports = isExisty;


  		/***/ }),
  		/* 24 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Check whether the given variable is null or not.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		/**
  		 * Check whether the given variable is null or not.
  		 * If the given variable(arguments[0]) is null, returns true.
  		 * @param {*} obj - Target for checking
  		 * @returns {boolean} Is null?
  		 * @memberof module:type
  		 */
  		function isNull(obj) {
  		  return obj === null;
  		}

  		module.exports = isNull;


  		/***/ }),
  		/* 25 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Check whether the given variable is an object or not.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		/**
  		 * Check whether the given variable is an object or not.
  		 * If the given variable is an object, return true.
  		 * @param {*} obj - Target for checking
  		 * @returns {boolean} Is object?
  		 * @memberof module:type
  		 */
  		function isObject(obj) {
  		  return obj === Object(obj);
  		}

  		module.exports = isObject;


  		/***/ }),
  		/* 26 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Check whether the given variable is a function or not.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		/**
  		 * Check whether the given variable is a function or not.
  		 * If the given variable is a function, return true.
  		 * @param {*} obj - Target for checking
  		 * @returns {boolean} Is function?
  		 * @memberof module:type
  		 */
  		function isFunction(obj) {
  		  return obj instanceof Function;
  		}

  		module.exports = isFunction;


  		/***/ }),
  		/* 27 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Provide a simple inheritance in prototype-oriented.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var createObject = __webpack_require__(28);

  		/**
  		 * Provide a simple inheritance in prototype-oriented.
  		 * Caution :
  		 *  Don't overwrite the prototype of child constructor.
  		 *
  		 * @param {function} subType Child constructor
  		 * @param {function} superType Parent constructor
  		 * @memberof module:inheritance
  		 * @example
  		 * var inherit = require('tui-code-snippet/inheritance/inherit'); // node, commonjs
  		 *
  		 * // Parent constructor
  		 * function Animal(leg) {
  		 *     this.leg = leg;
  		 * }
  		 * Animal.prototype.growl = function() {
  		 *     // ...
  		 * };
  		 *
  		 * // Child constructor
  		 * function Person(name) {
  		 *     this.name = name;
  		 * }
  		 *
  		 * // Inheritance
  		 * inherit(Person, Animal);
  		 *
  		 * // After this inheritance, please use only the extending of property.
  		 * // Do not overwrite prototype.
  		 * Person.prototype.walk = function(direction) {
  		 *     // ...
  		 * };
  		 */
  		function inherit(subType, superType) {
  		  var prototype = createObject(superType.prototype);
  		  prototype.constructor = subType;
  		  subType.prototype = prototype;
  		}

  		module.exports = inherit;


  		/***/ }),
  		/* 28 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Create a new object with the specified prototype object and properties.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		/**
  		 * @module inheritance
  		 */

  		/**
  		 * Create a new object with the specified prototype object and properties.
  		 * @param {Object} obj This object will be a prototype of the newly-created object.
  		 * @returns {Object}
  		 * @memberof module:inheritance
  		 */
  		function createObject(obj) {
  		  function F() {} // eslint-disable-line require-jsdoc
  		  F.prototype = obj;

  		  return new F();
  		}

  		module.exports = createObject;


  		/***/ }),
  		/* 29 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Add css class to element
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var forEach = __webpack_require__(4);
  		var inArray = __webpack_require__(0);
  		var getClass = __webpack_require__(18);
  		var setClassName = __webpack_require__(19);

  		/**
  		 * domUtil module
  		 * @module domUtil
  		 */

  		/**
  		 * Add css class to element
  		 * @param {(HTMLElement|SVGElement)} element - target element
  		 * @param {...string} cssClass - css classes to add
  		 * @memberof module:domUtil
  		 */
  		function addClass(element) {
  		  var cssClass = Array.prototype.slice.call(arguments, 1);
  		  var classList = element.classList;
  		  var newClass = [];
  		  var origin;

  		  if (classList) {
  		    forEach(cssClass, function(name) {
  		      element.classList.add(name);
  		    });

  		    return;
  		  }

  		  origin = getClass(element);

  		  if (origin) {
  		    cssClass = [].concat(origin.split(/\s+/), cssClass);
  		  }

  		  forEach(cssClass, function(cls) {
  		    if (inArray(cls, newClass) < 0) {
  		      newClass.push(cls);
  		    }
  		  });

  		  setClassName(element, newClass);
  		}

  		module.exports = addClass;


  		/***/ }),
  		/* 30 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Check element match selector
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var inArray = __webpack_require__(0);
  		var toArray = __webpack_require__(31);

  		var elProto = Element.prototype;
  		var matchSelector = elProto.matches ||
  		    elProto.webkitMatchesSelector ||
  		    elProto.mozMatchesSelector ||
  		    elProto.msMatchesSelector ||
  		    function(selector) {
  		      var doc = this.document || this.ownerDocument;

  		      return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;
  		    };

  		/**
  		 * Check element match selector
  		 * @param {HTMLElement} element - element to check
  		 * @param {string} selector - selector to check
  		 * @returns {boolean} is selector matched to element?
  		 * @memberof module:domUtil
  		 */
  		function matches(element, selector) {
  		  return matchSelector.call(element, selector);
  		}

  		module.exports = matches;


  		/***/ }),
  		/* 31 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Transform the Array-like object to Array.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var forEachArray = __webpack_require__(1);

  		/**
  		 * Transform the Array-like object to Array.
  		 * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
  		 * @param {*} arrayLike Array-like object
  		 * @returns {Array} Array
  		 * @memberof module:collection
  		 * @example
  		 * var toArray = require('tui-code-snippet/collection/toArray'); // node, commonjs
  		 *
  		 * var arrayLike = {
  		 *     0: 'one',
  		 *     1: 'two',
  		 *     2: 'three',
  		 *     3: 'four',
  		 *     length: 4
  		 * };
  		 * var result = toArray(arrayLike);
  		 *
  		 * alert(result instanceof Array); // true
  		 * alert(result); // one,two,three,four
  		 */
  		function toArray(arrayLike) {
  		  var arr;
  		  try {
  		    arr = Array.prototype.slice.call(arrayLike);
  		  } catch (e) {
  		    arr = [];
  		    forEachArray(arrayLike, function(value) {
  		      arr.push(value);
  		    });
  		  }

  		  return arr;
  		}

  		module.exports = toArray;


  		/***/ }),
  		/* 32 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Remove css class from element
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var forEachArray = __webpack_require__(1);
  		var inArray = __webpack_require__(0);
  		var getClass = __webpack_require__(18);
  		var setClassName = __webpack_require__(19);

  		/**
  		 * Remove css class from element
  		 * @param {(HTMLElement|SVGElement)} element - target element
  		 * @param {...string} cssClass - css classes to remove
  		 * @memberof module:domUtil
  		 */
  		function removeClass(element) {
  		  var cssClass = Array.prototype.slice.call(arguments, 1);
  		  var classList = element.classList;
  		  var origin, newClass;

  		  if (classList) {
  		    forEachArray(cssClass, function(name) {
  		      classList.remove(name);
  		    });

  		    return;
  		  }

  		  origin = getClass(element).split(/\s+/);
  		  newClass = [];
  		  forEachArray(origin, function(name) {
  		    if (inArray(name, cssClass) < 0) {
  		      newClass.push(name);
  		    }
  		  });

  		  setClassName(element, newClass);
  		}

  		module.exports = removeClass;


  		/***/ }),
  		/* 33 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Check whether the given variable is a number or not.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		/**
  		 * Check whether the given variable is a number or not.
  		 * If the given variable is a number, return true.
  		 * @param {*} obj - Target for checking
  		 * @returns {boolean} Is number?
  		 * @memberof module:type
  		 */
  		function isNumber(obj) {
  		  return typeof obj === 'number' || obj instanceof Number;
  		}

  		module.exports = isNumber;


  		/***/ }),
  		/* 34 */
  		/***/ (function(module, exports, __webpack_require__) {


  		var inArray = __webpack_require__(0);
  		var forEachArray = __webpack_require__(1);
  		var CustomEvents = __webpack_require__(8);
  		var defineClass = __webpack_require__(9);
  		var extend = __webpack_require__(2);
  		var on = __webpack_require__(10);
  		var off = __webpack_require__(11);
  		var closest = __webpack_require__(12);
  		var removeElement = __webpack_require__(13);
  		var isHTMLNode = __webpack_require__(14);

  		var util = __webpack_require__(15);
  		var tmpl = __webpack_require__(37);

  		var SELECTOR_UP_BUTTON = '.tui-timepicker-btn-up';
  		var SELECTOR_DOWN_BUTTON = '.tui-timepicker-btn-down';

  		/**
  		 * @class
  		 * @ignore
  		 * @param {String|HTMLElement} container - Container of spinbox or selector
  		 * @param {Object} [options] - Options for initialization
  		 * @param {number} [options.initialValue] - initial setting value
  		 * @param {Array.<number>} items - Items
  		 */
  		var Spinbox = defineClass(
  		  /** @lends Spinbox.prototype */ {
  		    init: function(container, options) {
  		      options = extend(
  		        {
  		          items: []
  		        },
  		        options
  		      );

  		      /**
  		       * @type {HTMLElement}
  		       * @private
  		       */
  		      this._container = isHTMLNode(container) ? container : document.querySelector(container);

  		      /**
  		       * Spinbox element
  		       * @type {HTMLElement}
  		       * @private
  		       */
  		      this._element = null;

  		      /**
  		       * @type {HTMLElement}
  		       * @private
  		       */
  		      this._inputElement = null;

  		      /**
  		       * Spinbox value items
  		       * @type {Array.<number>}
  		       * @private
  		       */
  		      this._items = options.items;

  		      /**
  		       * Selectbox disabled items info
  		       * @type {Array.<number>}
  		       * @private
  		       */
  		      this._disabledItems = options.disabledItems || [];

  		      /**
  		       * @type {number}
  		       * @private
  		       */
  		      this._selectedIndex = Math.max(0, inArray(options.initialValue, this._items));

  		      /**
  		       * Time format for output
  		       * @type {string}
  		       * @private
  		       */
  		      this._format = options.format;

  		      this._render();
  		      this._setEvents();
  		    },

  		    /**
  		     * Render spinbox
  		     * @private
  		     */
  		    _render: function() {
  		      var index = inArray(this.getValue(), this._items);
  		      var context;

  		      if (this._disabledItems[index]) {
  		        this._selectedIndex = this._findEnabledIndex();
  		      }
  		      context = {
  		        maxLength: this._getMaxLength(),
  		        initialValue: this.getValue(),
  		        format: this._format,
  		        formatTime: util.formatTime
  		      };

  		      this._container.innerHTML = tmpl(context);
  		      this._element = this._container.firstChild;
  		      this._inputElement = this._element.querySelector('input');
  		    },

  		    /**
  		     * Find the index of the enabled item
  		     * @returns {number} - find selected index
  		     * @private
  		     */
  		    _findEnabledIndex: function() {
  		      return inArray(false, this._disabledItems);
  		    },

  		    /**
  		     * Returns maxlength of value
  		     * @returns {number}
  		     * @private
  		     */
  		    _getMaxLength: function() {
  		      var lengths = [];

  		      forEachArray(this._items, function(item) {
  		        lengths.push(String(item).length);
  		      });

  		      return Math.max.apply(null, lengths);
  		    },

  		    /**
  		     * Set disabledItems
  		     * @param {object} disabledItems - disabled status of items
  		     */
  		    setDisabledItems: function(disabledItems) {
  		      this._disabledItems = disabledItems;
  		      this._changeToInputValue();
  		    },

  		    /**
  		     * Assign default events to up/down button
  		     * @private
  		     */
  		    _setEvents: function() {
  		      on(this._container, 'click', this._onClickHandler, this);
  		      on(this._inputElement, 'keydown', this._onKeydownInputElement, this);
  		      on(this._inputElement, 'change', this._onChangeHandler, this);

  		      this.on(
  		        'changeItems',
  		        function(items) {
  		          this._items = items;
  		          this._render();
  		        },
  		        this
  		      );
  		    },

  		    /**
  		     * Remove events to up/down button
  		     * @private
  		     */
  		    _removeEvents: function() {
  		      this.off();

  		      off(this._container, 'click', this._onClickHandler, this);
  		      off(this._inputElement, 'keydown', this._onKeydownInputElement, this);
  		      off(this._inputElement, 'change', this._onChangeHandler, this);
  		    },

  		    /**
  		     * Click event handler
  		     * @param {Event} ev - Change event on up/down buttons.
  		     */
  		    _onClickHandler: function(ev) {
  		      var target = util.getTarget(ev);

  		      if (closest(target, SELECTOR_DOWN_BUTTON)) {
  		        this._setNextValue(true);
  		      } else if (closest(target, SELECTOR_UP_BUTTON)) {
  		        this._setNextValue(false);
  		      }
  		    },

  		    /**
  		     * Set input value
  		     * @param {boolean} isDown - From down-action?
  		     * @private
  		     */
  		    _setNextValue: function(isDown) {
  		      var index = this._selectedIndex;

  		      if (isDown) {
  		        index = index ? index - 1 : this._items.length - 1;
  		      } else {
  		        index = index < this._items.length - 1 ? index + 1 : 0;
  		      }

  		      if (this._disabledItems[index]) {
  		        this._selectedIndex = index;
  		        this._setNextValue(isDown);
  		      } else {
  		        this.setValue(this._items[index]);
  		      }
  		    },

  		    /**
  		     * DOM(Input element) Keydown Event handler
  		     * @param {Event} ev event-object
  		     * @private
  		     */
  		    _onKeydownInputElement: function(ev) {
  		      var keyCode = ev.which || ev.keyCode;
  		      var isDown;

  		      if (closest(util.getTarget(ev), 'input')) {
  		        switch (keyCode) {
  		          case 38:
  		            isDown = false;
  		            break;
  		          case 40:
  		            isDown = true;
  		            break;
  		          default:
  		            return;
  		        }

  		        this._setNextValue(isDown);
  		      }
  		    },

  		    /**
  		     * DOM(Input element) Change Event handler
  		     * @param {Event} ev Change event on an input element.
  		     * @private
  		     */
  		    _onChangeHandler: function(ev) {
  		      if (closest(util.getTarget(ev), 'input')) {
  		        this._changeToInputValue();
  		      }
  		    },

  		    /**
  		     * Change value to input-box if it is valid.
  		     * @private
  		     * @param {boolean} silent prevents firing 'change' event if it is true.
  		     */
  		    _changeToInputValue: function(silent) {
  		      var newValue = Number(this._inputElement.value);
  		      var newIndex = inArray(newValue, this._items);

  		      if (this._disabledItems[newIndex]) {
  		        newIndex = this._findEnabledIndex();
  		        newValue = this._items[newIndex];
  		      } else if (newIndex === this._selectedIndex) {
  		        return;
  		      }

  		      if (newIndex === -1) {
  		        this.setValue(this._items[this._selectedIndex], silent);
  		      } else {
  		        this._selectedIndex = newIndex;

  		        if (!silent) {
  		          this.fire('change', {
  		            value: newValue
  		          });
  		        }
  		      }
  		    },

  		    /**
  		     * Set value to input-box.
  		     * @param {number} value - Value
  		     * @param {boolean} silent - prevents firing 'change' event if it is true.
  		     */
  		    setValue: function(value, silent) {
  		      this._inputElement.value = util.formatTime(value, this._format);
  		      this._changeToInputValue(silent);
  		    },

  		    /**
  		     * Returns current value
  		     * @returns {number}
  		     */
  		    getValue: function() {
  		      return this._items[this._selectedIndex];
  		    },

  		    /**
  		     * Destory
  		     */
  		    destroy: function() {
  		      this._removeEvents();
  		      removeElement(this._element);
  		      this._container = this._element = this._inputElement = this._items = this._selectedIndex = null;
  		    }
  		  }
  		);

  		CustomEvents.mixin(Spinbox);
  		module.exports = Spinbox;


  		/***/ }),
  		/* 35 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Send hostname on DOMContentLoaded.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var isUndefined = __webpack_require__(5);
  		var imagePing = __webpack_require__(36);

  		var ms7days = 7 * 24 * 60 * 60 * 1000;

  		/**
  		 * Check if the date has passed 7 days
  		 * @param {number} date - milliseconds
  		 * @returns {boolean}
  		 * @private
  		 */
  		function isExpired(date) {
  		  var now = new Date().getTime();

  		  return now - date > ms7days;
  		}

  		/**
  		 * Send hostname on DOMContentLoaded.
  		 * To prevent hostname set tui.usageStatistics to false.
  		 * @param {string} appName - application name
  		 * @param {string} trackingId - GA tracking ID
  		 * @ignore
  		 */
  		function sendHostname(appName, trackingId) {
  		  var url = 'https://www.google-analytics.com/collect';
  		  var hostname = location.hostname;
  		  var hitType = 'event';
  		  var eventCategory = 'use';
  		  var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';
  		  var date = window.localStorage.getItem(applicationKeyForStorage);

  		  // skip if the flag is defined and is set to false explicitly
  		  if (!isUndefined(window.tui) && window.tui.usageStatistics === false) {
  		    return;
  		  }

  		  // skip if not pass seven days old
  		  if (date && !isExpired(date)) {
  		    return;
  		  }

  		  window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());

  		  setTimeout(function() {
  		    if (document.readyState === 'interactive' || document.readyState === 'complete') {
  		      imagePing(url, {
  		        v: 1,
  		        t: hitType,
  		        tid: trackingId,
  		        cid: hostname,
  		        dp: hostname,
  		        dh: appName,
  		        el: appName,
  		        ec: eventCategory
  		      });
  		    }
  		  }, 1000);
  		}

  		module.exports = sendHostname;


  		/***/ }),
  		/* 36 */
  		/***/ (function(module, exports, __webpack_require__) {
  		/**
  		 * @fileoverview Request image ping.
  		 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  		 */



  		var forEachOwnProperties = __webpack_require__(16);

  		/**
  		 * @module request
  		 */

  		/**
  		 * Request image ping.
  		 * @param {String} url url for ping request
  		 * @param {Object} trackingInfo infos for make query string
  		 * @returns {HTMLElement}
  		 * @memberof module:request
  		 * @example
  		 * var imagePing = require('tui-code-snippet/request/imagePing'); // node, commonjs
  		 *
  		 * imagePing('https://www.google-analytics.com/collect', {
  		 *     v: 1,
  		 *     t: 'event',
  		 *     tid: 'trackingid',
  		 *     cid: 'cid',
  		 *     dp: 'dp',
  		 *     dh: 'dh'
  		 * });
  		 */
  		function imagePing(url, trackingInfo) {
  		  var trackingElement = document.createElement('img');
  		  var queryString = '';
  		  forEachOwnProperties(trackingInfo, function(value, key) {
  		    queryString += '&' + key + '=' + value;
  		  });
  		  queryString = queryString.substring(1);

  		  trackingElement.src = url + '?' + queryString;

  		  trackingElement.style.display = 'none';
  		  document.body.appendChild(trackingElement);
  		  document.body.removeChild(trackingElement);

  		  return trackingElement;
  		}

  		module.exports = imagePing;


  		/***/ }),
  		/* 37 */
  		/***/ (function(module, exports, __webpack_require__) {


  		var template = __webpack_require__(7);

  		module.exports = function(context) {
  		  var source =
  		      '<div class="tui-timepicker-btn-area">'
  		    + '  <input type="text" class="tui-timepicker-spinbox-input"'
  		    + '        maxlength="{{maxLength}}"'
  		    + '        size="{{maxLength}}"'
  		    + '        value="{{formatTime initialValue format}}"'
  		    + '        aria-label="TimePicker spinbox value">'
  		    + '  <button type="button" class="tui-timepicker-btn tui-timepicker-btn-up">'
  		    + '    <span class="tui-ico-t-btn">Increase</span>'
  		    + '  </button>'
  		    + '  <button type="button" class="tui-timepicker-btn tui-timepicker-btn-down">'
  		    + '    <span class="tui-ico-t-btn">Decrease</span>'
  		    + '  </button>'
  		    + '</div>';

  		  return template(source, context);
  		};



  		/***/ }),
  		/* 38 */
  		/***/ (function(module, exports, __webpack_require__) {


  		var inArray = __webpack_require__(0);
  		var CustomEvents = __webpack_require__(8);
  		var defineClass = __webpack_require__(9);
  		var extend = __webpack_require__(2);
  		var on = __webpack_require__(10);
  		var off = __webpack_require__(11);
  		var closest = __webpack_require__(12);
  		var removeElement = __webpack_require__(13);
  		var isHTMLNode = __webpack_require__(14);

  		var util = __webpack_require__(15);
  		var tmpl = __webpack_require__(39);

  		/**
  		 * @class
  		 * @ignore
  		 * @param {string|HTMLElement} container - Container element or selector
  		 * @param {object} options - Options
  		 * @param {Array.<number>} options.items - Items
  		 * @param {number} options.initialValue - Initial value
  		 */
  		var Selectbox = defineClass(
  		  /** @lends Selectbox.prototype */ {
  		    init: function(container, options) {
  		      options = extend(
  		        {
  		          items: []
  		        },
  		        options
  		      );

  		      /**
  		       * Container element
  		       * @type {HTMLElement}
  		       * @private
  		       */
  		      this._container = isHTMLNode(container) ? container : document.querySelector(container);

  		      /**
  		       * Selectbox items
  		       * @type {Array.<number>}
  		       * @private
  		       */
  		      this._items = options.items || [];

  		      /**
  		       * Selectbox disabled items info
  		       * @type {Array.<number>}
  		       * @private
  		       */
  		      this._disabledItems = options.disabledItems || [];

  		      /**
  		       * Selected index
  		       * @type {number}
  		       * @private
  		       */
  		      this._selectedIndex = Math.max(0, inArray(options.initialValue, this._items));

  		      /**
  		       * Time format for output
  		       * @type {string}
  		       * @private
  		       */
  		      this._format = options.format;

  		      /**
  		       * Select element
  		       * @type {HTMLElement}
  		       * @private
  		       */
  		      this._element = null;

  		      this._render();
  		      this._setEvents();
  		    },

  		    /**
  		     * Render selectbox
  		     * @private
  		     */
  		    _render: function() {
  		      var context;

  		      this._changeEnabledIndex();
  		      context = {
  		        items: this._items,
  		        format: this._format,
  		        initialValue: this.getValue(),
  		        disabledItems: this._disabledItems,
  		        formatTime: util.formatTime,
  		        equals: function(a, b) {
  		          return a === b;
  		        }
  		      };

  		      if (this._element) {
  		        this._removeElement();
  		      }

  		      this._container.innerHTML = tmpl(context);
  		      this._element = this._container.firstChild;
  		      on(this._element, 'change', this._onChangeHandler, this);
  		    },

  		    /**
  		     * Change the index of the enabled item
  		     * @private
  		     */
  		    _changeEnabledIndex: function() {
  		      var index = inArray(this.getValue(), this._items);
  		      if (this._disabledItems[index]) {
  		        this._selectedIndex = inArray(false, this._disabledItems);
  		      }
  		    },

  		    /**
  		     * Set disabledItems
  		     * @param {object} disabledItems - disabled status of items
  		     * @private
  		     */
  		    setDisabledItems: function(disabledItems) {
  		      this._disabledItems = disabledItems;
  		      this._render();
  		    },

  		    /**
  		     * Set events
  		     * @private
  		     */
  		    _setEvents: function() {
  		      this.on(
  		        'changeItems',
  		        function(items) {
  		          this._items = items;
  		          this._render();
  		        },
  		        this
  		      );
  		    },

  		    /**
  		     * Remove events
  		     * @private
  		     */
  		    _removeEvents: function() {
  		      this.off();
  		    },

  		    /**
  		     * Remove element
  		     * @private
  		     */
  		    _removeElement: function() {
  		      off(this._element, 'change', this._onChangeHandler, this);
  		      removeElement(this._element);
  		    },

  		    /**
  		     * Change event handler
  		     * @param {Event} ev Change event on a select element.
  		     * @private
  		     */
  		    _onChangeHandler: function(ev) {
  		      if (closest(util.getTarget(ev), 'select')) {
  		        this._setNewValue();
  		      }
  		    },

  		    /**
  		     * Set new value
  		     * @private
  		     * @param {boolean} silent prevents firing 'change' event if it is true.
  		     */
  		    _setNewValue: function(silent) {
  		      var newValue = Number(this._element.value);
  		      this._selectedIndex = inArray(newValue, this._items);
  		      if (!silent) {
  		        this.fire('change', {
  		          value: newValue
  		        });
  		      }
  		    },

  		    /**
  		     * Returns current value
  		     * @returns {number}
  		     */
  		    getValue: function() {
  		      return this._items[this._selectedIndex];
  		    },

  		    /**
  		     * Set value
  		     * @param {number} value - New value
  		     * @param {boolean} silent - prevents firing 'change' event if it is true.
  		     */
  		    setValue: function(value, silent) {
  		      var newIndex = inArray(value, this._items);

  		      if (newIndex > -1 && newIndex !== this._selectedIndex) {
  		        this._selectedIndex = newIndex;
  		        this._element.value = value;
  		        this._setNewValue(silent);
  		      }
  		    },

  		    /**
  		     * Destory
  		     */
  		    destroy: function() {
  		      this._removeEvents();
  		      this._removeElement();
  		      this._container = this._items = this._selectedIndex = this._element = null;
  		    }
  		  }
  		);

  		CustomEvents.mixin(Selectbox);
  		module.exports = Selectbox;


  		/***/ }),
  		/* 39 */
  		/***/ (function(module, exports, __webpack_require__) {


  		var template = __webpack_require__(7);

  		module.exports = function(context) {
  		  var source =
  		      '<select class="tui-timepicker-select" aria-label="Time">'
  		    + '  {{each items}}'
  		    + '    {{if equals initialValue @this}}'
  		    + '      <option value="{{@this}}" selected {{if disabledItems[@index]}}disabled{{/if}}>{{formatTime @this format}}</option>'
  		    + '    {{else}}'
  		    + '      <option value="{{@this}}" {{if disabledItems[@index]}}disabled{{/if}}>{{formatTime @this format}}</option>'
  		    + '    {{/if}}'
  		    + '  {{/each}}'
  		    + '</select>';

  		  return template(source, context);
  		};



  		/***/ }),
  		/* 40 */
  		/***/ (function(module, exports, __webpack_require__) {


  		module.exports = {
  		  en: {
  		    am: 'AM',
  		    pm: 'PM'
  		  },
  		  ko: {
  		    am: 'ì˜¤ì „',
  		    pm: 'ì˜¤í›„'
  		  }
  		};


  		/***/ }),
  		/* 41 */
  		/***/ (function(module, exports, __webpack_require__) {


  		var template = __webpack_require__(7);

  		module.exports = function(context) {
  		  var source =
  		      '<div class="tui-timepicker">'
  		    + '  <div class="tui-timepicker-body">'
  		    + '    <div class="tui-timepicker-row">'
  		    + '      {{if isSpinbox}}'
  		    + '        <div class="tui-timepicker-column tui-timepicker-spinbox tui-timepicker-hour"></div>'
  		    + '        <span class="tui-timepicker-column tui-timepicker-colon"><span class="tui-ico-colon">:</span></span>'
  		    + '        <div class="tui-timepicker-column tui-timepicker-spinbox tui-timepicker-minute"></div>'
  		    + '        {{if showMeridiem}}'
  		    + '          {{meridiemElement}}'
  		    + '        {{/if}}'
  		    + '      {{else}}'
  		    + '        <div class="tui-timepicker-column tui-timepicker-selectbox tui-timepicker-hour"></div>'
  		    + '        <span class="tui-timepicker-column tui-timepicker-colon"><span class="tui-ico-colon">:</span></span>'
  		    + '        <div class="tui-timepicker-column tui-timepicker-selectbox tui-timepicker-minute"></div>'
  		    + '        {{if showMeridiem}}'
  		    + '          {{meridiemElement}}'
  		    + '        {{/if}}'
  		    + '      {{/if}}'
  		    + '    </div>'
  		    + '  </div>'
  		    + '</div>';

  		  return template(source, context);
  		};



  		/***/ }),
  		/* 42 */
  		/***/ (function(module, exports, __webpack_require__) {


  		var template = __webpack_require__(7);

  		module.exports = function(context) {
  		  var source =
  		      '{{if isSpinbox}}'
  		    + '  <div class="tui-timepicker-column tui-timepicker-checkbox tui-timepicker-meridiem">'
  		    + '    <div class="tui-timepicker-check-area">'
  		    + '      <ul class="tui-timepicker-check-lst">'
  		    + '        <li class="tui-timepicker-check">'
  		    + '          <div class="tui-timepicker-radio">'
  		    + '            <input type="radio"'
  		    + '                  name="optionsRadios-{{radioId}}"'
  		    + '                  value="AM"'
  		    + '                  class="tui-timepicker-radio-am"'
  		    + '                  id="tui-timepicker-radio-am-{{radioId}}">'
  		    + '            <label for="tui-timepicker-radio-am-{{radioId}}" class="tui-timepicker-radio-label">'
  		    + '              <span class="tui-timepicker-input-radio"></span>{{am}}'
  		    + '            </label>'
  		    + '          </div>'
  		    + '        </li>'
  		    + '        <li class="tui-timepicker-check">'
  		    + '          <div class="tui-timepicker-radio">'
  		    + '            <input type="radio"'
  		    + '                  name="optionsRadios-{{radioId}}"'
  		    + '                  value="PM"'
  		    + '                  class="tui-timepicker-radio-pm"'
  		    + '                  id="tui-timepicker-radio-pm-{{radioId}}">'
  		    + '            <label for="tui-timepicker-radio-pm-{{radioId}}" class="tui-timepicker-radio-label">'
  		    + '              <span class="tui-timepicker-input-radio"></span>{{pm}}'
  		    + '            </label>'
  		    + '          </div>'
  		    + '        </li>'
  		    + '      </ul>'
  		    + '    </div>'
  		    + '  </div>'
  		    + '{{else}}'
  		    + '  <div class="tui-timepicker-column tui-timepicker-selectbox tui-is-add-picker tui-timepicker-meridiem">'
  		    + '    <select class="tui-timepicker-select" aria-label="AM/PM">'
  		    + '      <option value="AM">{{am}}</option>'
  		    + '      <option value="PM">{{pm}}</option>'
  		    + '    </select>'
  		    + '  </div>'
  		    + '{{/if}}';

  		  return template(source, context);
  		};



  		/***/ })
  		/******/ ]);
  		}); 
  	} (tuiTimePicker));
  	return tuiTimePicker.exports;
  }

  /*!
   * TOAST UI Date Picker
   * @version 4.3.3
   * @author NHN Cloud. FE Development Lab <dl_javascript@nhn.com>
   * @license MIT
   */

  (function (module, exports) {
  	(function webpackUniversalModuleDefinition(root, factory) {
  		module.exports = factory(requireTuiTimePicker());
  	})(window, function(__WEBPACK_EXTERNAL_MODULE__43__) {
  	return /******/ (function(modules) { // webpackBootstrap
  	/******/ 	// The module cache
  	/******/ 	var installedModules = {};
  	/******/
  	/******/ 	// The require function
  	/******/ 	function __webpack_require__(moduleId) {
  	/******/
  	/******/ 		// Check if module is in cache
  	/******/ 		if(installedModules[moduleId]) {
  	/******/ 			return installedModules[moduleId].exports;
  	/******/ 		}
  	/******/ 		// Create a new module (and put it into the cache)
  	/******/ 		var module = installedModules[moduleId] = {
  	/******/ 			i: moduleId,
  	/******/ 			l: false,
  	/******/ 			exports: {}
  	/******/ 		};
  	/******/
  	/******/ 		// Execute the module function
  	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  	/******/
  	/******/ 		// Flag the module as loaded
  	/******/ 		module.l = true;
  	/******/
  	/******/ 		// Return the exports of the module
  	/******/ 		return module.exports;
  	/******/ 	}
  	/******/
  	/******/
  	/******/ 	// expose the modules object (__webpack_modules__)
  	/******/ 	__webpack_require__.m = modules;
  	/******/
  	/******/ 	// expose the module cache
  	/******/ 	__webpack_require__.c = installedModules;
  	/******/
  	/******/ 	// define getter function for harmony exports
  	/******/ 	__webpack_require__.d = function(exports, name, getter) {
  	/******/ 		if(!__webpack_require__.o(exports, name)) {
  	/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
  	/******/ 		}
  	/******/ 	};
  	/******/
  	/******/ 	// define __esModule on exports
  	/******/ 	__webpack_require__.r = function(exports) {
  	/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  	/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  	/******/ 		}
  	/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
  	/******/ 	};
  	/******/
  	/******/ 	// create a fake namespace object
  	/******/ 	// mode & 1: value is a module id, require it
  	/******/ 	// mode & 2: merge all properties of value into the ns
  	/******/ 	// mode & 4: return value when already ns object
  	/******/ 	// mode & 8|1: behave like require
  	/******/ 	__webpack_require__.t = function(value, mode) {
  	/******/ 		if(mode & 1) value = __webpack_require__(value);
  	/******/ 		if(mode & 8) return value;
  	/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
  	/******/ 		var ns = Object.create(null);
  	/******/ 		__webpack_require__.r(ns);
  	/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
  	/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
  	/******/ 		return ns;
  	/******/ 	};
  	/******/
  	/******/ 	// getDefaultExport function for compatibility with non-harmony modules
  	/******/ 	__webpack_require__.n = function(module) {
  	/******/ 		var getter = module && module.__esModule ?
  	/******/ 			function getDefault() { return module['default']; } :
  	/******/ 			function getModuleExports() { return module; };
  	/******/ 		__webpack_require__.d(getter, 'a', getter);
  	/******/ 		return getter;
  	/******/ 	};
  	/******/
  	/******/ 	// Object.prototype.hasOwnProperty.call
  	/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  	/******/
  	/******/ 	// __webpack_public_path__
  	/******/ 	__webpack_require__.p = "dist";
  	/******/
  	/******/
  	/******/ 	// Load entry module and return exports
  	/******/ 	return __webpack_require__(__webpack_require__.s = 34);
  	/******/ })
  	/************************************************************************/
  	/******/ ([
  	/* 0 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview
  	 * This module provides a function to make a constructor
  	 * that can inherit from the other constructors like the CLASS easily.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var inherit = __webpack_require__(35);
  	var extend = __webpack_require__(7);

  	/**
  	 * @module defineClass
  	 */

  	/**
  	 * Help a constructor to be defined and to inherit from the other constructors
  	 * @param {*} [parent] Parent constructor
  	 * @param {Object} props Members of constructor
  	 *  @param {Function} props.init Initialization method
  	 *  @param {Object} [props.static] Static members of constructor
  	 * @returns {*} Constructor
  	 * @memberof module:defineClass
  	 * @example
  	 * var defineClass = require('tui-code-snippet/defineClass/defineClass'); // node, commonjs
  	 *
  	 * //-- #2. Use property --//
  	 * var Parent = defineClass({
  	 *     init: function() { // constuructor
  	 *         this.name = 'made by def';
  	 *     },
  	 *     method: function() {
  	 *         // ...
  	 *     },
  	 *     static: {
  	 *         staticMethod: function() {
  	 *              // ...
  	 *         }
  	 *     }
  	 * });
  	 *
  	 * var Child = defineClass(Parent, {
  	 *     childMethod: function() {}
  	 * });
  	 *
  	 * Parent.staticMethod();
  	 *
  	 * var parentInstance = new Parent();
  	 * console.log(parentInstance.name); //made by def
  	 * parentInstance.staticMethod(); // Error
  	 *
  	 * var childInstance = new Child();
  	 * childInstance.method();
  	 * childInstance.childMethod();
  	 */
  	function defineClass(parent, props) {
  	  var obj;

  	  if (!props) {
  	    props = parent;
  	    parent = null;
  	  }

  	  obj = props.init || function() {};

  	  if (parent) {
  	    inherit(obj, parent);
  	  }

  	  if (props.hasOwnProperty('static')) {
  	    extend(obj, props['static']);
  	    delete props['static'];
  	  }

  	  extend(obj.prototype, props);

  	  return obj;
  	}

  	module.exports = defineClass;


  	/***/ }),
  	/* 1 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Constants of date-picker
  	 */



  	module.exports = {
  	  TYPE_DATE: 'date',
  	  TYPE_MONTH: 'month',
  	  TYPE_YEAR: 'year',
  	  TYPE_HOUR: 'hour',
  	  TYPE_MINUTE: 'minute',
  	  TYPE_MERIDIEM: 'meridiem',
  	  MIN_DATE: new Date(1900, 0, 1),
  	  MAX_DATE: new Date(2999, 11, 31),

  	  DEFAULT_LANGUAGE_TYPE: 'en',

  	  CLASS_NAME_SELECTED: 'tui-is-selected',

  	  CLASS_NAME_PREV_MONTH_BTN: 'tui-calendar-btn-prev-month',
  	  CLASS_NAME_PREV_YEAR_BTN: 'tui-calendar-btn-prev-year',
  	  CLASS_NAME_NEXT_YEAR_BTN: 'tui-calendar-btn-next-year',
  	  CLASS_NAME_NEXT_MONTH_BTN: 'tui-calendar-btn-next-month',
  	  CLASS_NAME_TITLE_TODAY: 'tui-calendar-title-today',

  	  DEFAULT_WEEK_START_DAY: 'Sun',
  	  WEEK_START_DAY_MAP: {
  	    sun: 0,
  	    mon: 1,
  	    tue: 2,
  	    wed: 3,
  	    thu: 4,
  	    fri: 5,
  	    sat: 6
  	  }
  	};


  	/***/ }),
  	/* 2 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * Execute the provided callback once for each element present
  	 * in the array(or Array-like object) in ascending order.
  	 * If the callback function returns false, the loop will be stopped.
  	 * Callback function(iteratee) is invoked with three arguments:
  	 *  1) The value of the element
  	 *  2) The index of the element
  	 *  3) The array(or Array-like object) being traversed
  	 * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed
  	 * @param {function} iteratee Callback function
  	 * @param {Object} [context] Context(this) of callback function
  	 * @memberof module:collection
  	 * @example
  	 * var forEachArray = require('tui-code-snippet/collection/forEachArray'); // node, commonjs
  	 *
  	 * var sum = 0;
  	 *
  	 * forEachArray([1,2,3], function(value){
  	 *     sum += value;
  	 * });
  	 * alert(sum); // 6
  	 */
  	function forEachArray(arr, iteratee, context) {
  	  var index = 0;
  	  var len = arr.length;

  	  context = context || null;

  	  for (; index < len; index += 1) {
  	    if (iteratee.call(context, arr[index], index, arr) === false) {
  	      break;
  	    }
  	  }
  	}

  	module.exports = forEachArray;


  	/***/ }),
  	/* 3 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/* eslint-disable complexity */
  	/**
  	 * @fileoverview Returns the first index at which a given element can be found in the array.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var isArray = __webpack_require__(6);

  	/**
  	 * @module array
  	 */

  	/**
  	 * Returns the first index at which a given element can be found in the array
  	 * from start index(default 0), or -1 if it is not present.
  	 * It compares searchElement to elements of the Array using strict equality
  	 * (the same method used by the ===, or triple-equals, operator).
  	 * @param {*} searchElement Element to locate in the array
  	 * @param {Array} array Array that will be traversed.
  	 * @param {number} startIndex Start index in array for searching (default 0)
  	 * @returns {number} the First index at which a given element, or -1 if it is not present
  	 * @memberof module:array
  	 * @example
  	 * var inArray = require('tui-code-snippet/array/inArray'); // node, commonjs
  	 *
  	 * var arr = ['one', 'two', 'three', 'four'];
  	 * var idx1 = inArray('one', arr, 3); // -1
  	 * var idx2 = inArray('one', arr); // 0
  	 */
  	function inArray(searchElement, array, startIndex) {
  	  var i;
  	  var length;
  	  startIndex = startIndex || 0;

  	  if (!isArray(array)) {
  	    return -1;
  	  }

  	  if (Array.prototype.indexOf) {
  	    return Array.prototype.indexOf.call(array, searchElement, startIndex);
  	  }

  	  length = array.length;
  	  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
  	    if (array[i] === searchElement) {
  	      return i;
  	    }
  	  }

  	  return -1;
  	}

  	module.exports = inArray;


  	/***/ }),
  	/* 4 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Utils for Datepicker component
  	 */



  	var forEachArray = __webpack_require__(2);
  	var isHTMLNode = __webpack_require__(46);
  	var sendHostname = __webpack_require__(47);

  	var currentId = 0;

  	var utils = {
  	  /**
  	   * Get a target element
  	   * @param {Event} ev Event object
  	   * @returns {HTMLElement} An event target element
  	   */
  	  getTarget: function(ev) {
  	    return ev.target || ev.srcElement;
  	  },

  	  /**
  	   * Return the same element with an element or a matched element searched by a selector.
  	   * @param {HTMLElement|string} param HTMLElement or selector
  	   * @returns {HTMLElement} A matched element
  	   */
  	  getElement: function(param) {
  	    return isHTMLNode(param) ? param : document.querySelector(param);
  	  },

  	  /**
  	   * Get a selector of the element.
  	   * @param {HTMLElement} elem An element
  	   * @returns {string}
  	   */
  	  getSelector: function(elem) {
  	    var selector = '';
  	    if (elem.id) {
  	      selector = '#' + elem.id;
  	    } else if (elem.className) {
  	      selector = '.' + elem.className.split(' ')[0];
  	    }

  	    return selector;
  	  },

  	  /**
  	   * Create an unique id.
  	   * @returns {number}
  	   */
  	  generateId: function() {
  	    currentId += 1;

  	    return currentId;
  	  },

  	  /**
  	   * Create a new array with all elements that pass the test implemented by the provided function.
  	   * @param {Array} arr - Array that will be traversed
  	   * @param {function} iteratee - iteratee callback function
  	   * @returns {Array}
  	   */
  	  filter: function(arr, iteratee) {
  	    var result = [];

  	    forEachArray(arr, function(item) {
  	      if (iteratee(item)) {
  	        result.push(item);
  	      }
  	    });

  	    return result;
  	  },

  	  /**
  	   * Send hostname for GA
  	   * @ignore
  	   */
  	  sendHostName: function() {
  	    sendHostname('date-picker', 'UA-129987462-1');
  	  }
  	};

  	module.exports = utils;


  	/***/ }),
  	/* 5 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Utils for DatePicker component
  	 */



  	var isDate = __webpack_require__(28);
  	var isNumber = __webpack_require__(15);

  	var constants = __webpack_require__(1);

  	var TYPE_DATE = constants.TYPE_DATE;
  	var TYPE_MONTH = constants.TYPE_MONTH;
  	var TYPE_YEAR = constants.TYPE_YEAR;

  	/**
  	 * Utils of calendar
  	 * @namespace dateUtil
  	 * @ignore
  	 */
  	var utils = {
  	  /**
  	   * Get weeks count by paramenter
  	   * @param {number} year A year
  	   * @param {number} month A month
  	   * @returns {number} Weeks count (4~6)
  	   **/
  	  getWeeksCount: function(year, month) {
  	    var firstDay = utils.getFirstDay(year, month),
  	      lastDate = utils.getLastDayInMonth(year, month);

  	    return Math.ceil((firstDay + lastDate) / 7);
  	  },

  	  /**
  	   * @param {Date} date - Date instance
  	   * @returns {boolean}
  	   */
  	  isValidDate: function(date) {
  	    return isDate(date) && !isNaN(date.getTime());
  	  },

  	  /**
  	   * Get which day is first by parameters that include year and month information.
  	   * @param {number} year A year
  	   * @param {number} month A month
  	   * @returns {number} (0~6)
  	   */
  	  getFirstDay: function(year, month) {
  	    return new Date(year, month - 1, 1).getDay();
  	  },

  	  /**
  	   * Get timestamp of the first day.
  	   * @param {number} year A year
  	   * @param {number} month A month
  	   * @returns {number} timestamp
  	   */
  	  getFirstDayTimestamp: function(year, month) {
  	    return new Date(year, month, 1).getTime();
  	  },

  	  /**
  	   * Get last date by parameters that include year and month information.
  	   * @param {number} year A year
  	   * @param {number} month A month
  	   * @returns {number} (1~31)
  	   */
  	  getLastDayInMonth: function(year, month) {
  	    return new Date(year, month, 0).getDate();
  	  },

  	  /**
  	   * Chagne number 0~9 to '00~09'
  	   * @param {number} number number
  	   * @returns {string}
  	   * @example
  	   *  dateUtil.prependLeadingZero(0); //  '00'
  	   *  dateUtil.prependLeadingZero(9); //  '09'
  	   *  dateUtil.prependLeadingZero(12); //  '12'
  	   */
  	  prependLeadingZero: function(number) {
  	    var prefix = '';

  	    if (number < 10) {
  	      prefix = '0';
  	    }

  	    return prefix + number;
  	  },

  	  /**
  	   * Get meridiem hour
  	   * @param {number} hour - Original hour
  	   * @returns {number} Converted meridiem hour
  	   */
  	  getMeridiemHour: function(hour) {
  	    hour %= 12;

  	    if (hour === 0) {
  	      hour = 12;
  	    }

  	    return hour;
  	  },

  	  /**
  	   * Returns number or default
  	   * @param {*} any - Any value
  	   * @param {number} defaultNumber - Default number
  	   * @throws Will throw an error if the defaultNumber is invalid.
  	   * @returns {number}
  	   */
  	  getSafeNumber: function(any, defaultNumber) {
  	    if (isNaN(defaultNumber) || !isNumber(defaultNumber)) {
  	      throw Error('The defaultNumber must be a valid number.');
  	    }
  	    if (isNaN(any)) {
  	      return defaultNumber;
  	    }

  	    return Number(any);
  	  },

  	  /**
  	   * Return date of the week
  	   * @param {number} year - Year
  	   * @param {number} month - Month
  	   * @param {number} weekNumber - Week number (0~5)
  	   * @param {number} dayNumber - Day number (0: sunday, 1: monday, ....)
  	   * @returns {number}
  	   */
  	  getDateOfWeek: function(year, month, weekNumber, dayNumber) {
  	    var firstDayOfMonth = new Date(year, month - 1).getDay();
  	    var dateOffset = firstDayOfMonth - dayNumber - 1;

  	    return new Date(year, month - 1, weekNumber * 7 - dateOffset);
  	  },

  	  /**
  	   * Returns range arr
  	   * @param {number} start - Start value
  	   * @param {number} end - End value
  	   * @returns {Array}
  	   */
  	  getRangeArr: function(start, end) {
  	    var arr = [];
  	    var i;

  	    if (start > end) {
  	      for (i = end; i >= start; i -= 1) {
  	        arr.push(i);
  	      }
  	    } else {
  	      for (i = start; i <= end; i += 1) {
  	        arr.push(i);
  	      }
  	    }

  	    return arr;
  	  },

  	  /**
  	   * Returns cloned date with the start of a unit of time
  	   * @param {Date|number} date - Original date
  	   * @param {string} [type = TYPE_DATE] - Unit type
  	   * @throws {Error}
  	   * @returns {Date}
  	   */
  	  cloneWithStartOf: function(date, type) {
  	    type = type || TYPE_DATE;
  	    date = new Date(date);

  	    // Does not consider time-level yet.
  	    date.setHours(0, 0, 0, 0);

  	    switch (type) {
  	      case TYPE_DATE:
  	        break;
  	      case TYPE_MONTH:
  	        date.setDate(1);
  	        break;
  	      case TYPE_YEAR:
  	        date.setMonth(0, 1);
  	        break;
  	      default:
  	        throw Error('Unsupported type: ' + type);
  	    }

  	    return date;
  	  },

  	  /**
  	   * Returns cloned date with the end of a unit of time
  	   * @param {Date|number} date - Original date
  	   * @param {string} [type = TYPE_DATE] - Unit type
  	   * @throws {Error}
  	   * @returns {Date}
  	   */
  	  cloneWithEndOf: function(date, type) {
  	    type = type || TYPE_DATE;
  	    date = new Date(date);

  	    // Does not consider time-level yet.
  	    date.setHours(23, 59, 59, 999);

  	    switch (type) {
  	      case TYPE_DATE:
  	        break;
  	      case TYPE_MONTH:
  	        date.setMonth(date.getMonth() + 1, 0);
  	        break;
  	      case TYPE_YEAR:
  	        date.setMonth(11, 31);
  	        break;
  	      default:
  	        throw Error('Unsupported type: ' + type);
  	    }

  	    return date;
  	  },

  	  /**
  	   * Compare two dates
  	   * @param {Date|number} dateA - Date
  	   * @param {Date|number} dateB - Date
  	   * @param {string} [cmpLevel] - Comparing level
  	   * @returns {number}
  	   */
  	  compare: function(dateA, dateB, cmpLevel) {
  	    var aTimestamp, bTimestamp;

  	    if (!(utils.isValidDate(dateA) && utils.isValidDate(dateB))) {
  	      return NaN;
  	    }

  	    if (!cmpLevel) {
  	      aTimestamp = dateA.getTime();
  	      bTimestamp = dateB.getTime();
  	    } else {
  	      aTimestamp = utils.cloneWithStartOf(dateA, cmpLevel).getTime();
  	      bTimestamp = utils.cloneWithStartOf(dateB, cmpLevel).getTime();
  	    }

  	    if (aTimestamp > bTimestamp) {
  	      return 1;
  	    }

  	    return aTimestamp === bTimestamp ? 0 : -1;
  	  },

  	  /**
  	   * Returns whether two dates are same
  	   * @param {Date|number} dateA - Date
  	   * @param {Date|number} dateB - Date
  	   * @param {string} [cmpLevel] - Comparing level
  	   * @returns {boolean}
  	   */
  	  isSame: function(dateA, dateB, cmpLevel) {
  	    return utils.compare(dateA, dateB, cmpLevel) === 0;
  	  },

  	  /**
  	   * Returns whether the target is in range
  	   * @param {Date|number} start - Range start
  	   * @param {Date|number} end - Range end
  	   * @param {Date|number} target - Target
  	   * @param {string} [cmpLevel = TYPE_DATE] - Comparing level
  	   * @returns {boolean}
  	   */
  	  inRange: function(start, end, target, cmpLevel) {
  	    return utils.compare(start, target, cmpLevel) < 1 && utils.compare(end, target, cmpLevel) > -1;
  	  }
  	};

  	module.exports = utils;


  	/***/ }),
  	/* 6 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Check whether the given variable is an instance of Array or not.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * Check whether the given variable is an instance of Array or not.
  	 * If the given variable is an instance of Array, return true.
  	 * @param {*} obj - Target for checking
  	 * @returns {boolean} Is array instance?
  	 * @memberof module:type
  	 */
  	function isArray(obj) {
  	  return obj instanceof Array;
  	}

  	module.exports = isArray;


  	/***/ }),
  	/* 7 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Extend the target object from other objects.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * @module object
  	 */

  	/**
  	 * Extend the target object from other objects.
  	 * @param {object} target - Object that will be extended
  	 * @param {...object} objects - Objects as sources
  	 * @returns {object} Extended object
  	 * @memberof module:object
  	 */
  	function extend(target, objects) { // eslint-disable-line no-unused-vars
  	  var hasOwnProp = Object.prototype.hasOwnProperty;
  	  var source, prop, i, len;

  	  for (i = 1, len = arguments.length; i < len; i += 1) {
  	    source = arguments[i];
  	    for (prop in source) {
  	      if (hasOwnProp.call(source, prop)) {
  	        target[prop] = source[prop];
  	      }
  	    }
  	  }

  	  return target;
  	}

  	module.exports = extend;


  	/***/ }),
  	/* 8 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview This module provides some functions for custom events. And it is implemented in the observer design pattern.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var extend = __webpack_require__(7);
  	var isExisty = __webpack_require__(37);
  	var isString = __webpack_require__(13);
  	var isObject = __webpack_require__(22);
  	var isArray = __webpack_require__(6);
  	var isFunction = __webpack_require__(39);
  	var forEach = __webpack_require__(9);

  	var R_EVENTNAME_SPLIT = /\s+/g;

  	/**
  	 * @class
  	 * @example
  	 * // node, commonjs
  	 * var CustomEvents = require('tui-code-snippet/customEvents/customEvents');
  	 */
  	function CustomEvents() {
  	  /**
  	     * @type {HandlerItem[]}
  	     */
  	  this.events = null;

  	  /**
  	     * only for checking specific context event was binded
  	     * @type {object[]}
  	     */
  	  this.contexts = null;
  	}

  	/**
  	 * Mixin custom events feature to specific constructor
  	 * @param {function} func - constructor
  	 * @example
  	 * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
  	 *
  	 * var model;
  	 * function Model() {
  	 *     this.name = '';
  	 * }
  	 * CustomEvents.mixin(Model);
  	 *
  	 * model = new Model();
  	 * model.on('change', function() { this.name = 'model'; }, this);
  	 * model.fire('change');
  	 * alert(model.name); // 'model';
  	 */
  	CustomEvents.mixin = function(func) {
  	  extend(func.prototype, CustomEvents.prototype);
  	};

  	/**
  	 * Get HandlerItem object
  	 * @param {function} handler - handler function
  	 * @param {object} [context] - context for handler
  	 * @returns {HandlerItem} HandlerItem object
  	 * @private
  	 */
  	CustomEvents.prototype._getHandlerItem = function(handler, context) {
  	  var item = {handler: handler};

  	  if (context) {
  	    item.context = context;
  	  }

  	  return item;
  	};

  	/**
  	 * Get event object safely
  	 * @param {string} [eventName] - create sub event map if not exist.
  	 * @returns {(object|array)} event object. if you supplied `eventName`
  	 *  parameter then make new array and return it
  	 * @private
  	 */
  	CustomEvents.prototype._safeEvent = function(eventName) {
  	  var events = this.events;
  	  var byName;

  	  if (!events) {
  	    events = this.events = {};
  	  }

  	  if (eventName) {
  	    byName = events[eventName];

  	    if (!byName) {
  	      byName = [];
  	      events[eventName] = byName;
  	    }

  	    events = byName;
  	  }

  	  return events;
  	};

  	/**
  	 * Get context array safely
  	 * @returns {array} context array
  	 * @private
  	 */
  	CustomEvents.prototype._safeContext = function() {
  	  var context = this.contexts;

  	  if (!context) {
  	    context = this.contexts = [];
  	  }

  	  return context;
  	};

  	/**
  	 * Get index of context
  	 * @param {object} ctx - context that used for bind custom event
  	 * @returns {number} index of context
  	 * @private
  	 */
  	CustomEvents.prototype._indexOfContext = function(ctx) {
  	  var context = this._safeContext();
  	  var index = 0;

  	  while (context[index]) {
  	    if (ctx === context[index][0]) {
  	      return index;
  	    }

  	    index += 1;
  	  }

  	  return -1;
  	};

  	/**
  	 * Memorize supplied context for recognize supplied object is context or
  	 *  name: handler pair object when off()
  	 * @param {object} ctx - context object to memorize
  	 * @private
  	 */
  	CustomEvents.prototype._memorizeContext = function(ctx) {
  	  var context, index;

  	  if (!isExisty(ctx)) {
  	    return;
  	  }

  	  context = this._safeContext();
  	  index = this._indexOfContext(ctx);

  	  if (index > -1) {
  	    context[index][1] += 1;
  	  } else {
  	    context.push([ctx, 1]);
  	  }
  	};

  	/**
  	 * Forget supplied context object
  	 * @param {object} ctx - context object to forget
  	 * @private
  	 */
  	CustomEvents.prototype._forgetContext = function(ctx) {
  	  var context, contextIndex;

  	  if (!isExisty(ctx)) {
  	    return;
  	  }

  	  context = this._safeContext();
  	  contextIndex = this._indexOfContext(ctx);

  	  if (contextIndex > -1) {
  	    context[contextIndex][1] -= 1;

  	    if (context[contextIndex][1] <= 0) {
  	      context.splice(contextIndex, 1);
  	    }
  	  }
  	};

  	/**
  	 * Bind event handler
  	 * @param {(string|{name:string, handler:function})} eventName - custom
  	 *  event name or an object {eventName: handler}
  	 * @param {(function|object)} [handler] - handler function or context
  	 * @param {object} [context] - context for binding
  	 * @private
  	 */
  	CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
  	  var events = this._safeEvent(eventName);
  	  this._memorizeContext(context);
  	  events.push(this._getHandlerItem(handler, context));
  	};

  	/**
  	 * Bind event handlers
  	 * @param {(string|{name:string, handler:function})} eventName - custom
  	 *  event name or an object {eventName: handler}
  	 * @param {(function|object)} [handler] - handler function or context
  	 * @param {object} [context] - context for binding
  	 * //-- #1. Get Module --//
  	 * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
  	 *
  	 * //-- #2. Use method --//
  	 * // # 2.1 Basic Usage
  	 * CustomEvents.on('onload', handler);
  	 *
  	 * // # 2.2 With context
  	 * CustomEvents.on('onload', handler, myObj);
  	 *
  	 * // # 2.3 Bind by object that name, handler pairs
  	 * CustomEvents.on({
  	 *     'play': handler,
  	 *     'pause': handler2
  	 * });
  	 *
  	 * // # 2.4 Bind by object that name, handler pairs with context object
  	 * CustomEvents.on({
  	 *     'play': handler
  	 * }, myObj);
  	 */
  	CustomEvents.prototype.on = function(eventName, handler, context) {
  	  var self = this;

  	  if (isString(eventName)) {
  	    // [syntax 1, 2]
  	    eventName = eventName.split(R_EVENTNAME_SPLIT);
  	    forEach(eventName, function(name) {
  	      self._bindEvent(name, handler, context);
  	    });
  	  } else if (isObject(eventName)) {
  	    // [syntax 3, 4]
  	    context = handler;
  	    forEach(eventName, function(func, name) {
  	      self.on(name, func, context);
  	    });
  	  }
  	};

  	/**
  	 * Bind one-shot event handlers
  	 * @param {(string|{name:string,handler:function})} eventName - custom
  	 *  event name or an object {eventName: handler}
  	 * @param {function|object} [handler] - handler function or context
  	 * @param {object} [context] - context for binding
  	 */
  	CustomEvents.prototype.once = function(eventName, handler, context) {
  	  var self = this;

  	  if (isObject(eventName)) {
  	    context = handler;
  	    forEach(eventName, function(func, name) {
  	      self.once(name, func, context);
  	    });

  	    return;
  	  }

  	  function onceHandler() { // eslint-disable-line require-jsdoc
  	    handler.apply(context, arguments);
  	    self.off(eventName, onceHandler, context);
  	  }

  	  this.on(eventName, onceHandler, context);
  	};

  	/**
  	 * Splice supplied array by callback result
  	 * @param {array} arr - array to splice
  	 * @param {function} predicate - function return boolean
  	 * @private
  	 */
  	CustomEvents.prototype._spliceMatches = function(arr, predicate) {
  	  var i = 0;
  	  var len;

  	  if (!isArray(arr)) {
  	    return;
  	  }

  	  for (len = arr.length; i < len; i += 1) {
  	    if (predicate(arr[i]) === true) {
  	      arr.splice(i, 1);
  	      len -= 1;
  	      i -= 1;
  	    }
  	  }
  	};

  	/**
  	 * Get matcher for unbind specific handler events
  	 * @param {function} handler - handler function
  	 * @returns {function} handler matcher
  	 * @private
  	 */
  	CustomEvents.prototype._matchHandler = function(handler) {
  	  var self = this;

  	  return function(item) {
  	    var needRemove = handler === item.handler;

  	    if (needRemove) {
  	      self._forgetContext(item.context);
  	    }

  	    return needRemove;
  	  };
  	};

  	/**
  	 * Get matcher for unbind specific context events
  	 * @param {object} context - context
  	 * @returns {function} object matcher
  	 * @private
  	 */
  	CustomEvents.prototype._matchContext = function(context) {
  	  var self = this;

  	  return function(item) {
  	    var needRemove = context === item.context;

  	    if (needRemove) {
  	      self._forgetContext(item.context);
  	    }

  	    return needRemove;
  	  };
  	};

  	/**
  	 * Get matcher for unbind specific hander, context pair events
  	 * @param {function} handler - handler function
  	 * @param {object} context - context
  	 * @returns {function} handler, context matcher
  	 * @private
  	 */
  	CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
  	  var self = this;

  	  return function(item) {
  	    var matchHandler = (handler === item.handler);
  	    var matchContext = (context === item.context);
  	    var needRemove = (matchHandler && matchContext);

  	    if (needRemove) {
  	      self._forgetContext(item.context);
  	    }

  	    return needRemove;
  	  };
  	};

  	/**
  	 * Unbind event by event name
  	 * @param {string} eventName - custom event name to unbind
  	 * @param {function} [handler] - handler function
  	 * @private
  	 */
  	CustomEvents.prototype._offByEventName = function(eventName, handler) {
  	  var self = this;
  	  var andByHandler = isFunction(handler);
  	  var matchHandler = self._matchHandler(handler);

  	  eventName = eventName.split(R_EVENTNAME_SPLIT);

  	  forEach(eventName, function(name) {
  	    var handlerItems = self._safeEvent(name);

  	    if (andByHandler) {
  	      self._spliceMatches(handlerItems, matchHandler);
  	    } else {
  	      forEach(handlerItems, function(item) {
  	        self._forgetContext(item.context);
  	      });

  	      self.events[name] = [];
  	    }
  	  });
  	};

  	/**
  	 * Unbind event by handler function
  	 * @param {function} handler - handler function
  	 * @private
  	 */
  	CustomEvents.prototype._offByHandler = function(handler) {
  	  var self = this;
  	  var matchHandler = this._matchHandler(handler);

  	  forEach(this._safeEvent(), function(handlerItems) {
  	    self._spliceMatches(handlerItems, matchHandler);
  	  });
  	};

  	/**
  	 * Unbind event by object(name: handler pair object or context object)
  	 * @param {object} obj - context or {name: handler} pair object
  	 * @param {function} handler - handler function
  	 * @private
  	 */
  	CustomEvents.prototype._offByObject = function(obj, handler) {
  	  var self = this;
  	  var matchFunc;

  	  if (this._indexOfContext(obj) < 0) {
  	    forEach(obj, function(func, name) {
  	      self.off(name, func);
  	    });
  	  } else if (isString(handler)) {
  	    matchFunc = this._matchContext(obj);

  	    self._spliceMatches(this._safeEvent(handler), matchFunc);
  	  } else if (isFunction(handler)) {
  	    matchFunc = this._matchHandlerAndContext(handler, obj);

  	    forEach(this._safeEvent(), function(handlerItems) {
  	      self._spliceMatches(handlerItems, matchFunc);
  	    });
  	  } else {
  	    matchFunc = this._matchContext(obj);

  	    forEach(this._safeEvent(), function(handlerItems) {
  	      self._spliceMatches(handlerItems, matchFunc);
  	    });
  	  }
  	};

  	/**
  	 * Unbind custom events
  	 * @param {(string|object|function)} eventName - event name or context or
  	 *  {name: handler} pair object or handler function
  	 * @param {(function)} handler - handler function
  	 * @example
  	 * //-- #1. Get Module --//
  	 * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
  	 *
  	 * //-- #2. Use method --//
  	 * // # 2.1 off by event name
  	 * CustomEvents.off('onload');
  	 *
  	 * // # 2.2 off by event name and handler
  	 * CustomEvents.off('play', handler);
  	 *
  	 * // # 2.3 off by handler
  	 * CustomEvents.off(handler);
  	 *
  	 * // # 2.4 off by context
  	 * CustomEvents.off(myObj);
  	 *
  	 * // # 2.5 off by context and handler
  	 * CustomEvents.off(myObj, handler);
  	 *
  	 * // # 2.6 off by context and event name
  	 * CustomEvents.off(myObj, 'onload');
  	 *
  	 * // # 2.7 off by an Object.<string, function> that is {eventName: handler}
  	 * CustomEvents.off({
  	 *   'play': handler,
  	 *   'pause': handler2
  	 * });
  	 *
  	 * // # 2.8 off the all events
  	 * CustomEvents.off();
  	 */
  	CustomEvents.prototype.off = function(eventName, handler) {
  	  if (isString(eventName)) {
  	    // [syntax 1, 2]
  	    this._offByEventName(eventName, handler);
  	  } else if (!arguments.length) {
  	    // [syntax 8]
  	    this.events = {};
  	    this.contexts = [];
  	  } else if (isFunction(eventName)) {
  	    // [syntax 3]
  	    this._offByHandler(eventName);
  	  } else if (isObject(eventName)) {
  	    // [syntax 4, 5, 6]
  	    this._offByObject(eventName, handler);
  	  }
  	};

  	/**
  	 * Fire custom event
  	 * @param {string} eventName - name of custom event
  	 */
  	CustomEvents.prototype.fire = function(eventName) {  // eslint-disable-line
  	  this.invoke.apply(this, arguments);
  	};

  	/**
  	 * Fire a event and returns the result of operation 'boolean AND' with all
  	 *  listener's results.
  	 *
  	 * So, It is different from {@link CustomEvents#fire}.
  	 *
  	 * In service code, use this as a before event in component level usually
  	 *  for notifying that the event is cancelable.
  	 * @param {string} eventName - Custom event name
  	 * @param {...*} data - Data for event
  	 * @returns {boolean} The result of operation 'boolean AND'
  	 * @example
  	 * var map = new Map();
  	 * map.on({
  	 *     'beforeZoom': function() {
  	 *         // It should cancel the 'zoom' event by some conditions.
  	 *         if (that.disabled && this.getState()) {
  	 *             return false;
  	 *         }
  	 *         return true;
  	 *     }
  	 * });
  	 *
  	 * if (this.invoke('beforeZoom')) {    // check the result of 'beforeZoom'
  	 *     // if true,
  	 *     // doSomething
  	 * }
  	 */
  	CustomEvents.prototype.invoke = function(eventName) {
  	  var events, args, index, item;

  	  if (!this.hasListener(eventName)) {
  	    return true;
  	  }

  	  events = this._safeEvent(eventName);
  	  args = Array.prototype.slice.call(arguments, 1);
  	  index = 0;

  	  while (events[index]) {
  	    item = events[index];

  	    if (item.handler.apply(item.context, args) === false) {
  	      return false;
  	    }

  	    index += 1;
  	  }

  	  return true;
  	};

  	/**
  	 * Return whether at least one of the handlers is registered in the given
  	 *  event name.
  	 * @param {string} eventName - Custom event name
  	 * @returns {boolean} Is there at least one handler in event name?
  	 */
  	CustomEvents.prototype.hasListener = function(eventName) {
  	  return this.getListenerLength(eventName) > 0;
  	};

  	/**
  	 * Return a count of events registered.
  	 * @param {string} eventName - Custom event name
  	 * @returns {number} number of event
  	 */
  	CustomEvents.prototype.getListenerLength = function(eventName) {
  	  var events = this._safeEvent(eventName);

  	  return events.length;
  	};

  	module.exports = CustomEvents;


  	/***/ }),
  	/* 9 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var isArray = __webpack_require__(6);
  	var forEachArray = __webpack_require__(2);
  	var forEachOwnProperties = __webpack_require__(23);

  	/**
  	 * @module collection
  	 */

  	/**
  	 * Execute the provided callback once for each property of object(or element of array) which actually exist.
  	 * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).
  	 * If the callback function returns false, the loop will be stopped.
  	 * Callback function(iteratee) is invoked with three arguments:
  	 *  1) The value of the property(or The value of the element)
  	 *  2) The name of the property(or The index of the element)
  	 *  3) The object being traversed
  	 * @param {Object} obj The object that will be traversed
  	 * @param {function} iteratee Callback function
  	 * @param {Object} [context] Context(this) of callback function
  	 * @memberof module:collection
  	 * @example
  	 * var forEach = require('tui-code-snippet/collection/forEach'); // node, commonjs
  	 *
  	 * var sum = 0;
  	 *
  	 * forEach([1,2,3], function(value){
  	 *     sum += value;
  	 * });
  	 * alert(sum); // 6
  	 *
  	 * // In case of Array-like object
  	 * var array = Array.prototype.slice.call(arrayLike); // change to array
  	 * forEach(array, function(value){
  	 *     sum += value;
  	 * });
  	 */
  	function forEach(obj, iteratee, context) {
  	  if (isArray(obj)) {
  	    forEachArray(obj, iteratee, context);
  	  } else {
  	    forEachOwnProperties(obj, iteratee, context);
  	  }
  	}

  	module.exports = forEach;


  	/***/ }),
  	/* 10 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Default locale texts
  	 */



  	module.exports = {
  	  en: {
  	    titles: {
  	      DD: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
  	      D: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  	      MMM: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  	      MMMM: [
  	        'January',
  	        'February',
  	        'March',
  	        'April',
  	        'May',
  	        'June',
  	        'July',
  	        'August',
  	        'September',
  	        'October',
  	        'November',
  	        'December'
  	      ]
  	    },
  	    titleFormat: 'MMMM yyyy',
  	    todayFormat: 'To\\d\\ay: DD, MMMM d, yyyy',
  	    time: 'Time',
  	    date: 'Date'
  	  },
  	  ko: {
  	    titles: {
  	      DD: ['ì¼ìš”ì¼', 'ì›”ìš”ì¼', 'í™”ìš”ì¼', 'ìˆ˜ìš”ì¼', 'ëª©ìš”ì¼', 'ê¸ˆìš”ì¼', 'í† ìš”ì¼'],
  	      D: ['ì¼', 'ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† '],
  	      MMM: ['1ì›”', '2ì›”', '3ì›”', '4ì›”', '5ì›”', '6ì›”', '7ì›”', '8ì›”', '9ì›”', '10ì›”', '11ì›”', '12ì›”'],
  	      MMMM: ['1ì›”', '2ì›”', '3ì›”', '4ì›”', '5ì›”', '6ì›”', '7ì›”', '8ì›”', '9ì›”', '10ì›”', '11ì›”', '12ì›”']
  	    },
  	    titleFormat: 'yyyy.MM',
  	    todayFormat: 'ì˜¤ëŠ˜: yyyy.MM.dd (D)',
  	    date: 'ë‚ ì§œ',
  	    time: 'ì‹œê°„'
  	  }
  	};


  	/***/ }),
  	/* 11 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Convert text by binding expressions with context.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var inArray = __webpack_require__(3);
  	var forEach = __webpack_require__(9);
  	var isArray = __webpack_require__(6);
  	var isString = __webpack_require__(13);
  	var extend = __webpack_require__(7);

  	// IE8 does not support capture groups.
  	var EXPRESSION_REGEXP = /{{\s?|\s?}}/g;
  	var BRACKET_NOTATION_REGEXP = /^[a-zA-Z0-9_@]+\[[a-zA-Z0-9_@"']+\]$/;
  	var BRACKET_REGEXP = /\[\s?|\s?\]/;
  	var DOT_NOTATION_REGEXP = /^[a-zA-Z_]+\.[a-zA-Z_]+$/;
  	var DOT_REGEXP = /\./;
  	var STRING_NOTATION_REGEXP = /^["']\w+["']$/;
  	var STRING_REGEXP = /"|'/g;
  	var NUMBER_REGEXP = /^-?\d+\.?\d*$/;

  	var EXPRESSION_INTERVAL = 2;

  	var BLOCK_HELPERS = {
  	  'if': handleIf,
  	  'each': handleEach,
  	  'with': handleWith
  	};

  	var isValidSplit = 'a'.split(/a/).length === 3;

  	/**
  	 * Split by RegExp. (Polyfill for IE8)
  	 * @param {string} text - text to be splitted\
  	 * @param {RegExp} regexp - regular expression
  	 * @returns {Array.<string>}
  	 */
  	var splitByRegExp = (function() {
  	  if (isValidSplit) {
  	    return function(text, regexp) {
  	      return text.split(regexp);
  	    };
  	  }

  	  return function(text, regexp) {
  	    var result = [];
  	    var prevIndex = 0;
  	    var match, index;

  	    if (!regexp.global) {
  	      regexp = new RegExp(regexp, 'g');
  	    }

  	    match = regexp.exec(text);
  	    while (match !== null) {
  	      index = match.index;
  	      result.push(text.slice(prevIndex, index));

  	      prevIndex = index + match[0].length;
  	      match = regexp.exec(text);
  	    }
  	    result.push(text.slice(prevIndex));

  	    return result;
  	  };
  	})();

  	/**
  	 * Find value in the context by an expression.
  	 * @param {string} exp - an expression
  	 * @param {object} context - context
  	 * @returns {*}
  	 * @private
  	 */
  	// eslint-disable-next-line complexity
  	function getValueFromContext(exp, context) {
  	  var splitedExps;
  	  var value = context[exp];

  	  if (exp === 'true') {
  	    value = true;
  	  } else if (exp === 'false') {
  	    value = false;
  	  } else if (STRING_NOTATION_REGEXP.test(exp)) {
  	    value = exp.replace(STRING_REGEXP, '');
  	  } else if (BRACKET_NOTATION_REGEXP.test(exp)) {
  	    splitedExps = exp.split(BRACKET_REGEXP);
  	    value = getValueFromContext(splitedExps[0], context)[getValueFromContext(splitedExps[1], context)];
  	  } else if (DOT_NOTATION_REGEXP.test(exp)) {
  	    splitedExps = exp.split(DOT_REGEXP);
  	    value = getValueFromContext(splitedExps[0], context)[splitedExps[1]];
  	  } else if (NUMBER_REGEXP.test(exp)) {
  	    value = parseFloat(exp);
  	  }

  	  return value;
  	}

  	/**
  	 * Extract elseif and else expressions.
  	 * @param {Array.<string>} ifExps - args of if expression
  	 * @param {Array.<string>} sourcesInsideBlock - sources inside if block
  	 * @returns {object} - exps: expressions of if, elseif, and else / sourcesInsideIf: sources inside if, elseif, and else block.
  	 * @private
  	 */
  	function extractElseif(ifExps, sourcesInsideBlock) {
  	  var exps = [ifExps];
  	  var sourcesInsideIf = [];
  	  var otherIfCount = 0;
  	  var start = 0;

  	  // eslint-disable-next-line complexity
  	  forEach(sourcesInsideBlock, function(source, index) {
  	    if (source.indexOf('if') === 0) {
  	      otherIfCount += 1;
  	    } else if (source === '/if') {
  	      otherIfCount -= 1;
  	    } else if (!otherIfCount && (source.indexOf('elseif') === 0 || source === 'else')) {
  	      exps.push(source === 'else' ? ['true'] : source.split(' ').slice(1));
  	      sourcesInsideIf.push(sourcesInsideBlock.slice(start, index));
  	      start = index + 1;
  	    }
  	  });

  	  sourcesInsideIf.push(sourcesInsideBlock.slice(start));

  	  return {
  	    exps: exps,
  	    sourcesInsideIf: sourcesInsideIf
  	  };
  	}

  	/**
  	 * Helper function for "if". 
  	 * @param {Array.<string>} exps - array of expressions split by spaces
  	 * @param {Array.<string>} sourcesInsideBlock - array of sources inside the if block
  	 * @param {object} context - context
  	 * @returns {string}
  	 * @private
  	 */
  	function handleIf(exps, sourcesInsideBlock, context) {
  	  var analyzed = extractElseif(exps, sourcesInsideBlock);
  	  var result = false;
  	  var compiledSource = '';

  	  forEach(analyzed.exps, function(exp, index) {
  	    result = handleExpression(exp, context);
  	    if (result) {
  	      compiledSource = compile(analyzed.sourcesInsideIf[index], context);
  	    }

  	    return !result;
  	  });

  	  return compiledSource;
  	}

  	/**
  	 * Helper function for "each".
  	 * @param {Array.<string>} exps - array of expressions split by spaces
  	 * @param {Array.<string>} sourcesInsideBlock - array of sources inside the each block
  	 * @param {object} context - context
  	 * @returns {string}
  	 * @private
  	 */
  	function handleEach(exps, sourcesInsideBlock, context) {
  	  var collection = handleExpression(exps, context);
  	  var additionalKey = isArray(collection) ? '@index' : '@key';
  	  var additionalContext = {};
  	  var result = '';

  	  forEach(collection, function(item, key) {
  	    additionalContext[additionalKey] = key;
  	    additionalContext['@this'] = item;
  	    extend(context, additionalContext);

  	    result += compile(sourcesInsideBlock.slice(), context);
  	  });

  	  return result;
  	}

  	/**
  	 * Helper function for "with ... as"
  	 * @param {Array.<string>} exps - array of expressions split by spaces
  	 * @param {Array.<string>} sourcesInsideBlock - array of sources inside the with block
  	 * @param {object} context - context
  	 * @returns {string}
  	 * @private
  	 */
  	function handleWith(exps, sourcesInsideBlock, context) {
  	  var asIndex = inArray('as', exps);
  	  var alias = exps[asIndex + 1];
  	  var result = handleExpression(exps.slice(0, asIndex), context);

  	  var additionalContext = {};
  	  additionalContext[alias] = result;

  	  return compile(sourcesInsideBlock, extend(context, additionalContext)) || '';
  	}

  	/**
  	 * Extract sources inside block in place.
  	 * @param {Array.<string>} sources - array of sources
  	 * @param {number} start - index of start block
  	 * @param {number} end - index of end block
  	 * @returns {Array.<string>}
  	 * @private
  	 */
  	function extractSourcesInsideBlock(sources, start, end) {
  	  var sourcesInsideBlock = sources.splice(start + 1, end - start);
  	  sourcesInsideBlock.pop();

  	  return sourcesInsideBlock;
  	}

  	/**
  	 * Handle block helper function
  	 * @param {string} helperKeyword - helper keyword (ex. if, each, with)
  	 * @param {Array.<string>} sourcesToEnd - array of sources after the starting block
  	 * @param {object} context - context
  	 * @returns {Array.<string>}
  	 * @private
  	 */
  	function handleBlockHelper(helperKeyword, sourcesToEnd, context) {
  	  var executeBlockHelper = BLOCK_HELPERS[helperKeyword];
  	  var helperCount = 1;
  	  var startBlockIndex = 0;
  	  var endBlockIndex;
  	  var index = startBlockIndex + EXPRESSION_INTERVAL;
  	  var expression = sourcesToEnd[index];

  	  while (helperCount && isString(expression)) {
  	    if (expression.indexOf(helperKeyword) === 0) {
  	      helperCount += 1;
  	    } else if (expression.indexOf('/' + helperKeyword) === 0) {
  	      helperCount -= 1;
  	      endBlockIndex = index;
  	    }

  	    index += EXPRESSION_INTERVAL;
  	    expression = sourcesToEnd[index];
  	  }

  	  if (helperCount) {
  	    throw Error(helperKeyword + ' needs {{/' + helperKeyword + '}} expression.');
  	  }

  	  sourcesToEnd[startBlockIndex] = executeBlockHelper(
  	    sourcesToEnd[startBlockIndex].split(' ').slice(1),
  	    extractSourcesInsideBlock(sourcesToEnd, startBlockIndex, endBlockIndex),
  	    context
  	  );

  	  return sourcesToEnd;
  	}

  	/**
  	 * Helper function for "custom helper".
  	 * If helper is not a function, return helper itself.
  	 * @param {Array.<string>} exps - array of expressions split by spaces (first element: helper)
  	 * @param {object} context - context
  	 * @returns {string}
  	 * @private
  	 */
  	function handleExpression(exps, context) {
  	  var result = getValueFromContext(exps[0], context);

  	  if (result instanceof Function) {
  	    return executeFunction(result, exps.slice(1), context);
  	  }

  	  return result;
  	}

  	/**
  	 * Execute a helper function.
  	 * @param {Function} helper - helper function
  	 * @param {Array.<string>} argExps - expressions of arguments
  	 * @param {object} context - context
  	 * @returns {string} - result of executing the function with arguments
  	 * @private
  	 */
  	function executeFunction(helper, argExps, context) {
  	  var args = [];
  	  forEach(argExps, function(exp) {
  	    args.push(getValueFromContext(exp, context));
  	  });

  	  return helper.apply(null, args);
  	}

  	/**
  	 * Get a result of compiling an expression with the context.
  	 * @param {Array.<string>} sources - array of sources split by regexp of expression.
  	 * @param {object} context - context
  	 * @returns {Array.<string>} - array of sources that bind with its context
  	 * @private
  	 */
  	function compile(sources, context) {
  	  var index = 1;
  	  var expression = sources[index];
  	  var exps, firstExp, result;

  	  while (isString(expression)) {
  	    exps = expression.split(' ');
  	    firstExp = exps[0];

  	    if (BLOCK_HELPERS[firstExp]) {
  	      result = handleBlockHelper(firstExp, sources.splice(index, sources.length - index), context);
  	      sources = sources.concat(result);
  	    } else {
  	      sources[index] = handleExpression(exps, context);
  	    }

  	    index += EXPRESSION_INTERVAL;
  	    expression = sources[index];
  	  }

  	  return sources.join('');
  	}

  	/**
  	 * Convert text by binding expressions with context.
  	 * <br>
  	 * If expression exists in the context, it will be replaced.
  	 * ex) '{{title}}' with context {title: 'Hello!'} is converted to 'Hello!'.
  	 * An array or object can be accessed using bracket and dot notation.
  	 * ex) '{{odds\[2\]}}' with context {odds: \[1, 3, 5\]} is converted to '5'.
  	 * ex) '{{evens\[first\]}}' with context {evens: \[2, 4\], first: 0} is converted to '2'.
  	 * ex) '{{project\["name"\]}}' and '{{project.name}}' with context {project: {name: 'CodeSnippet'}} is converted to 'CodeSnippet'.
  	 * <br>
  	 * If replaced expression is a function, next expressions will be arguments of the function.
  	 * ex) '{{add 1 2}}' with context {add: function(a, b) {return a + b;}} is converted to '3'.
  	 * <br>
  	 * It has 3 predefined block helpers '{{helper ...}} ... {{/helper}}': 'if', 'each', 'with ... as ...'.
  	 * 1) 'if' evaluates conditional statements. It can use with 'elseif' and 'else'.
  	 * 2) 'each' iterates an array or object. It provides '@index'(array), '@key'(object), and '@this'(current element).
  	 * 3) 'with ... as ...' provides an alias.
  	 * @param {string} text - text with expressions
  	 * @param {object} context - context
  	 * @returns {string} - text that bind with its context
  	 * @memberof module:domUtil
  	 * @example
  	 * var template = require('tui-code-snippet/domUtil/template');
  	 * 
  	 * var source = 
  	 *     '<h1>'
  	 *   +   '{{if isValidNumber title}}'
  	 *   +     '{{title}}th'
  	 *   +   '{{elseif isValidDate title}}'
  	 *   +     'Date: {{title}}'
  	 *   +   '{{/if}}'
  	 *   + '</h1>'
  	 *   + '{{each list}}'
  	 *   +   '{{with addOne @index as idx}}'
  	 *   +     '<p>{{idx}}: {{@this}}</p>'
  	 *   +   '{{/with}}'
  	 *   + '{{/each}}';
  	 * 
  	 * var context = {
  	 *   isValidDate: function(text) {
  	 *     return /^\d{4}-(0|1)\d-(0|1|2|3)\d$/.test(text);
  	 *   },
  	 *   isValidNumber: function(text) {
  	 *     return /^\d+$/.test(text);
  	 *   }
  	 *   title: '2019-11-25',
  	 *   list: ['Clean the room', 'Wash the dishes'],
  	 *   addOne: function(num) {
  	 *     return num + 1;
  	 *   }
  	 * };
  	 * 
  	 * var result = template(source, context);
  	 * console.log(result); // <h1>Date: 2019-11-25</h1><p>1: Clean the room</p><p>2: Wash the dishes</p>
  	 */
  	function template(text, context) {
  	  return compile(splitByRegExp(text, EXPRESSION_REGEXP), context);
  	}

  	module.exports = template;


  	/***/ }),
  	/* 12 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Check whether the given variable is undefined or not.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * Check whether the given variable is undefined or not.
  	 * If the given variable is undefined, returns true.
  	 * @param {*} obj - Target for checking
  	 * @returns {boolean} Is undefined?
  	 * @memberof module:type
  	 */
  	function isUndefined(obj) {
  	  return obj === undefined; // eslint-disable-line no-undefined
  	}

  	module.exports = isUndefined;


  	/***/ }),
  	/* 13 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Check whether the given variable is a string or not.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * Check whether the given variable is a string or not.
  	 * If the given variable is a string, return true.
  	 * @param {*} obj - Target for checking
  	 * @returns {boolean} Is string?
  	 * @memberof module:type
  	 */
  	function isString(obj) {
  	  return typeof obj === 'string' || obj instanceof String;
  	}

  	module.exports = isString;


  	/***/ }),
  	/* 14 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Remove element from parent node.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * Remove element from parent node.
  	 * @param {HTMLElement} element - element to remove.
  	 * @memberof module:domUtil
  	 */
  	function removeElement(element) {
  	  if (element && element.parentNode) {
  	    element.parentNode.removeChild(element);
  	  }
  	}

  	module.exports = removeElement;


  	/***/ }),
  	/* 15 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Check whether the given variable is a number or not.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * Check whether the given variable is a number or not.
  	 * If the given variable is a number, return true.
  	 * @param {*} obj - Target for checking
  	 * @returns {boolean} Is number?
  	 * @memberof module:type
  	 */
  	function isNumber(obj) {
  	  return typeof obj === 'number' || obj instanceof Number;
  	}

  	module.exports = isNumber;


  	/***/ }),
  	/* 16 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Add css class to element
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var forEach = __webpack_require__(9);
  	var inArray = __webpack_require__(3);
  	var getClass = __webpack_require__(17);
  	var setClassName = __webpack_require__(24);

  	/**
  	 * domUtil module
  	 * @module domUtil
  	 */

  	/**
  	 * Add css class to element
  	 * @param {(HTMLElement|SVGElement)} element - target element
  	 * @param {...string} cssClass - css classes to add
  	 * @memberof module:domUtil
  	 */
  	function addClass(element) {
  	  var cssClass = Array.prototype.slice.call(arguments, 1);
  	  var classList = element.classList;
  	  var newClass = [];
  	  var origin;

  	  if (classList) {
  	    forEach(cssClass, function(name) {
  	      element.classList.add(name);
  	    });

  	    return;
  	  }

  	  origin = getClass(element);

  	  if (origin) {
  	    cssClass = [].concat(origin.split(/\s+/), cssClass);
  	  }

  	  forEach(cssClass, function(cls) {
  	    if (inArray(cls, newClass) < 0) {
  	      newClass.push(cls);
  	    }
  	  });

  	  setClassName(element, newClass);
  	}

  	module.exports = addClass;


  	/***/ }),
  	/* 17 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Get HTML element's design classes.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var isUndefined = __webpack_require__(12);

  	/**
  	 * Get HTML element's design classes.
  	 * @param {(HTMLElement|SVGElement)} element target element
  	 * @returns {string} element css class name
  	 * @memberof module:domUtil
  	 */
  	function getClass(element) {
  	  if (!element || !element.className) {
  	    return '';
  	  }

  	  if (isUndefined(element.className.baseVal)) {
  	    return element.className;
  	  }

  	  return element.className.baseVal;
  	}

  	module.exports = getClass;


  	/***/ }),
  	/* 18 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Remove css class from element
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var forEachArray = __webpack_require__(2);
  	var inArray = __webpack_require__(3);
  	var getClass = __webpack_require__(17);
  	var setClassName = __webpack_require__(24);

  	/**
  	 * Remove css class from element
  	 * @param {(HTMLElement|SVGElement)} element - target element
  	 * @param {...string} cssClass - css classes to remove
  	 * @memberof module:domUtil
  	 */
  	function removeClass(element) {
  	  var cssClass = Array.prototype.slice.call(arguments, 1);
  	  var classList = element.classList;
  	  var origin, newClass;

  	  if (classList) {
  	    forEachArray(cssClass, function(name) {
  	      classList.remove(name);
  	    });

  	    return;
  	  }

  	  origin = getClass(element).split(/\s+/);
  	  newClass = [];
  	  forEachArray(origin, function(name) {
  	    if (inArray(name, cssClass) < 0) {
  	      newClass.push(name);
  	    }
  	  });

  	  setClassName(element, newClass);
  	}

  	module.exports = removeClass;


  	/***/ }),
  	/* 19 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Set mouse-touch event
  	 */



  	var on = __webpack_require__(31);
  	var off = __webpack_require__(33);

  	var mouseTouchEvent = {
  	  /**
  	   * Detect mobile browser
  	   * @type {boolean} Whether using Mobile browser
  	   * @private
  	   */
  	  _isMobile: (function() {
  	    return /Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(
  	      navigator.userAgent
  	    );
  	  })(),

  	  /**
  	   * Return a matched event type by a mouse event type
  	   * @param {string} type A mouse event type - mousedown, click
  	   * @returns {string}
  	   * @private
  	   */
  	  _getEventType: function(type) {
  	    if (this._isMobile) {
  	      if (type === 'mousedown') {
  	        type = 'touchstart';
  	      } else if (type === 'click') {
  	        type = 'touchend';
  	      }
  	    }

  	    return type;
  	  },

  	  /**
  	   * Bind touch or mouse events
  	   * @param {HTMLElement} element An element to bind
  	   * @param {string} type A mouse event type - mousedown, click
  	   * @param {Function} handler A handler function
  	   * @param {object} [context] A context for handler.
  	   */
  	  on: function(element, type, handler, context) {
  	    on(element, this._getEventType(type), handler, context);
  	  },

  	  /**
  	   * Unbind touch or mouse events
  	   * @param {HTMLElement} element - Target element
  	   * @param {string} type A mouse event type - mousedown, click
  	   * @param {Function} handler - Handler
  	   */
  	  off: function(element, type, handler) {
  	    off(element, this._getEventType(type), handler);
  	  }
  	};

  	module.exports = mouseTouchEvent;


  	/***/ }),
  	/* 20 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Layer base
  	 */



  	var defineClass = __webpack_require__(0);
  	var removeElement = __webpack_require__(14);

  	var localeText = __webpack_require__(10);
  	var DEFAULT_LANGUAGE_TYPE = __webpack_require__(1).DEFAULT_LANGUAGE_TYPE;

  	/**
  	 * @abstract
  	 * @class
  	 * @ignore
  	 * @param {string} language - Initial language
  	 * Layer base
  	 */
  	var LayerBase = defineClass(
  	  /** @lends LayerBase.prototype */ {
  	    init: function(language) {
  	      language = language || DEFAULT_LANGUAGE_TYPE;

  	      /**
  	       * Layer element
  	       * @type {HTMLElement}
  	       * @private
  	       */
  	      this._element = null;

  	      /**
  	       * Language type
  	       * @type {string}
  	       * @private
  	       */
  	      this._localeText = localeText[language];

  	      /**
  	       * Layer type
  	       * @type {string}
  	       * @private
  	       */
  	      this._type = 'base';
  	    },

  	    /**
  	     * Make context
  	     * @abstract
  	     * @throws {Error}
  	     * @returns {object}
  	     * @private
  	     */
  	    _makeContext: function() {
  	      throwOverrideError(this.getType(), '_makeContext');
  	    },

  	    /**
  	     * Render the layer element
  	     * @abstract
  	     * @throws {Error}
  	     */
  	    render: function() {
  	      throwOverrideError(this.getType(), 'render');
  	    },

  	    /**
  	     * Returns date elements
  	     * @abstract
  	     * @throws {Error}
  	     * @returns {HTMLElement[]}
  	     */
  	    getDateElements: function() {
  	      throwOverrideError(this.getType(), 'getDateElements');
  	    },

  	    /**
  	     * Returns layer type
  	     * @returns {string}
  	     */
  	    getType: function() {
  	      return this._type;
  	    },

  	    /**
  	     * Set language
  	     * @param {string} language - Language name
  	     */
  	    changeLanguage: function(language) {
  	      this._localeText = localeText[language];
  	    },

  	    /**
  	     * Remove elements
  	     */
  	    remove: function() {
  	      if (this._element) {
  	        removeElement(this._element);
  	      }
  	      this._element = null;
  	    }
  	  }
  	);

  	/**
  	 * Throw - method override error
  	 * @ignore
  	 * @param {string} layerType - Layer type
  	 * @param {string} methodName - Method name
  	 * @throws {Error}
  	 */
  	function throwOverrideError(layerType, methodName) {
  	  throw new Error(layerType + ' layer does not have the "' + methodName + '" method.');
  	}

  	module.exports = LayerBase;


  	/***/ }),
  	/* 21 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview DatePicker component
  	 */



  	var inArray = __webpack_require__(3);
  	var forEachArray = __webpack_require__(2);
  	var defineClass = __webpack_require__(0);
  	var CustomEvents = __webpack_require__(8);
  	var addClass = __webpack_require__(16);
  	var closest = __webpack_require__(25);
  	var getData = __webpack_require__(26);
  	var hasClass = __webpack_require__(27);
  	var removeClass = __webpack_require__(18);
  	var removeElement = __webpack_require__(14);
  	var extend = __webpack_require__(7);
  	var isArray = __webpack_require__(6);
  	var isDate = __webpack_require__(28);
  	var isNumber = __webpack_require__(15);
  	var isObject = __webpack_require__(22);

  	var TimePicker = __webpack_require__(43);

  	var Calendar = __webpack_require__(29);
  	var RangeModel = __webpack_require__(56);
  	var constants = __webpack_require__(1);
  	var localeTexts = __webpack_require__(10);
  	var dateUtil = __webpack_require__(5);
  	var util = __webpack_require__(4);
  	var mouseTouchEvent = __webpack_require__(19);
  	var tmpl = __webpack_require__(58);
  	var DatePickerInput = __webpack_require__(59);

  	var DEFAULT_WEEK_START_DAY = constants.DEFAULT_WEEK_START_DAY;
  	var DEFAULT_LANGUAGE_TYPE = constants.DEFAULT_LANGUAGE_TYPE;
  	var TYPE_DATE = constants.TYPE_DATE;
  	var TYPE_MONTH = constants.TYPE_MONTH;
  	var TYPE_YEAR = constants.TYPE_YEAR;
  	var CLASS_NAME_NEXT_YEAR_BTN = constants.CLASS_NAME_NEXT_YEAR_BTN;
  	var CLASS_NAME_NEXT_MONTH_BTN = constants.CLASS_NAME_NEXT_MONTH_BTN;
  	var CLASS_NAME_PREV_YEAR_BTN = constants.CLASS_NAME_PREV_YEAR_BTN;
  	var CLASS_NAME_PREV_MONTH_BTN = constants.CLASS_NAME_PREV_MONTH_BTN;
  	var CLASS_NAME_SELECTED = constants.CLASS_NAME_SELECTED;
  	var CLASS_NAME_TITLE_TODAY = constants.CLASS_NAME_TITLE_TODAY;

  	var CLASS_NAME_SELECTABLE = 'tui-is-selectable';
  	var CLASS_NAME_BLOCKED = 'tui-is-blocked';
  	var CLASS_NAME_CHECKED = 'tui-is-checked';
  	var CLASS_NAME_SELECTOR_BUTTON = 'tui-datepicker-selector-button';
  	var CLASS_NAME_TODAY = 'tui-calendar-today';
  	var CLASS_NAME_HIDDEN = 'tui-hidden';

  	var SELECTOR_BODY = '.tui-datepicker-body';
  	var SELECTOR_DATE_ICO = '.tui-ico-date';
  	var SELECTOR_CALENDAR_TITLE = '.tui-calendar-title';
  	var SELECTOR_CALENDAR_CONTAINER = '.tui-calendar-container';
  	var SELECTOR_TIMEPICKER_CONTAINER = '.tui-timepicker-container';

  	/**
  	 * Merge default option
  	 * @ignore
  	 * @param {object} option - DatePicker option
  	 * @returns {object}
  	 */
  	var mergeDefaultOption = function(option) {
  	  option = extend(
  	    {
  	      language: DEFAULT_LANGUAGE_TYPE,
  	      calendar: {},
  	      input: {
  	        element: null,
  	        format: null
  	      },
  	      timePicker: null,
  	      date: null,
  	      showAlways: false,
  	      type: TYPE_DATE,
  	      selectableRanges: null,
  	      openers: [],
  	      autoClose: true,
  	      usageStatistics: true,
  	      weekStartDay: DEFAULT_WEEK_START_DAY
  	    },
  	    option
  	  );

  	  option.selectableRanges = option.selectableRanges || [[constants.MIN_DATE, constants.MAX_DATE]];

  	  if (!isObject(option.calendar)) {
  	    throw new Error('Calendar option must be an object');
  	  }
  	  if (!isObject(option.input)) {
  	    throw new Error('Input option must be an object');
  	  }
  	  if (!isArray(option.selectableRanges)) {
  	    throw new Error('Selectable-ranges must be a 2d-array');
  	  }

  	  option.localeText = localeTexts[option.language];

  	  // override calendar option
  	  option.calendar.language = option.language;
  	  option.calendar.type = option.type;

  	  // @TODO: after v5.0.0, remove option.timepicker
  	  option.timePicker = option.timePicker || option.timepicker;

  	  return option;
  	};

  	/**
  	 * @class
  	 * @description
  	 * Create a date picker.
  	 * @see {@link /tutorial-example01-basic DatePicker example}
  	 * @param {HTMLElement|string} container - Container element or selector of DatePicker
  	 * @param {Object} [options] - Options
  	 *      @param {Date|number} [options.date = null] - Initial date. Set by a Date instance or a number(timestamp). (default: no initial date)
  	 *      @param {('date'|'month'|'year')} [options.type = 'date'] - DatePicker type. Determine whether to choose a date, month, or year.
  	 *      @param {string} [options.language='en'] - Language code. English('en') and Korean('ko') are provided as default. To set to the other languages, use {@link DatePicker#localeTexts DatePicker.localeTexts}.
  	 *      @param {object|boolean} [options.timePicker] - [TimePicker](https://nhn.github.io/tui.time-picker/latest) options. Refer to the [TimePicker instance's options](https://nhn.github.io/tui.time-picker/latest/TimePicker). To create the TimePicker without customization, set to true.
  	 *      @param {object} [options.calendar] - {@link Calendar} options. Refer to the {@link Calendar Calendar instance's options}.
  	 *      @param {object} [options.input] - Input option
  	 *      @param {HTMLElement|string} [options.input.element] - Input element or selector
  	 *      @param {string} [options.input.format = 'yyyy-mm-dd'] - Format of the Date string
  	 *      @param {Array.<Array.<Date|number>>} [options.selectableRanges = 1900/1/1 ~ 2999/12/31]
  	 *        - Ranges of selectable date. Set by Date instances or numbers(timestamp).
  	 *      @param {Array<HTMLElement|string>} [options.openers = []] - List of the openers to open the DatePicker (example - icon, button, etc.)
  	 *      @param {boolean} [options.showAlways = false] - Show the DatePicker always
  	 *      @param {boolean} [options.autoClose = true] - Close the DatePicker after clicking the date
  	 *      @param {boolean} [options.usageStatistics = true] - Send a hostname to Google Analytics (default: true)
  	 *      @param {string} [options.weekStartDay = 'Sun'] - Start of the week. 'Sun', 'Mon', ..., 'Sat'(default: 'Sun'(start on Sunday))
  	 * @example
  	 * // ES6
  	 * import DatePicker from 'tui-date-picker'
  	 *
  	 * // CommonJS
  	 * const DatePicker = require('tui-date-picker');
  	 *
  	 * // Browser
  	 * const DatePicker = tui.DatePicker;
  	 *
  	 * const range1 = [new Date(2015, 2, 1), new Date(2015, 3, 1)];
  	 * const range2 = [1465570800000, 1481266182155]; // timestamps
  	 *
  	 * const picker1 = new DatePicker('#datepicker-container1', {
  	 *     showAlways: true
  	 * });
  	 *
  	 * const picker2 = new DatePicker('#datepicker-container2', {
  	 *    showAlways: true,
  	 *    timePicker: true
  	 * });
  	 *
  	 * const picker3 = new DatePicker('#datepicker-container3', {
  	 *     language: 'ko',
  	 *     calendar: {
  	 *         showToday: true
  	 *     },
  	 *     timePicker: {
  	 *         showMeridiem: true,
  	 *         defaultHour: 13,
  	 *         defaultMinute: 24
  	 *     },
  	 *     input: {
  	 *         element: '#datepicker-input',
  	 *         format: 'yyyyë…„ MMì›” ddì¼ hh:mm A'
  	 *     }
  	 *     type: 'date',
  	 *     date: new Date(2015, 0, 1)
  	 *     selectableRanges: [range1, range2],
  	 *     openers: ['#opener'],
  	 *     weekStartDay: 'Mon',
  	 * });
  	 */
  	var DatePicker = defineClass(
  	  /** @lends DatePicker.prototype */ {
  	    static: {
  	      /**
  	       * Locale text data. English('en') and Korean('ko') are provided as default.
  	       * @type {object}
  	       * @memberof DatePicker
  	       * @static
  	       * @example
  	       * DatePicker.localeTexts['customKey'] = {
  	       *     titles: {
  	       *         // days
  	       *         DD: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
  	       *         // daysShort
  	       *         D: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  	       *         // months
  	       *         MMMM: [
  	       *             'January', 'February', 'March', 'April', 'May', 'June',
  	       *             'July', 'August', 'September', 'October', 'November', 'December'
  	       *         ],
  	       *         // monthsShort
  	       *         MMM: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
  	       *     },
  	       *     titleFormat: 'MMM yyyy',
  	       *     todayFormat: 'D, MMMM dd, yyyy',
  	       *     date: 'Date',
  	       *     time: 'Time'
  	       * };
  	       *
  	       * const datepicker = new DatePicker('#datepicker-container', {
  	       *     language: 'customKey'
  	       * });
  	       */
  	      localeTexts: localeTexts
  	    },
  	    init: function(container, options) {
  	      options = mergeDefaultOption(options);

  	      /**
  	       * Language type
  	       * @type {string}
  	       * @private
  	       */
  	      this._language = options.language;

  	      /**
  	       * DatePicker container
  	       * @type {HTMLElement}
  	       * @private
  	       */
  	      this._container = util.getElement(container);
  	      this._container.innerHTML = tmpl(
  	        extend(options, {
  	          isTab: options.timePicker && options.timePicker.layoutType === 'tab'
  	        })
  	      );

  	      /**
  	       * DatePicker element
  	       * @type {HTMLElement}
  	       * @private
  	       */
  	      this._element = this._container.firstChild;

  	      /**
  	       * Calendar instance
  	       * @type {Calendar}
  	       * @private
  	       */
  	      this._calendar = new Calendar(
  	        this._element.querySelector(SELECTOR_CALENDAR_CONTAINER),
  	        extend(options.calendar, {
  	          usageStatistics: options.usageStatistics,
  	          weekStartDay: options.weekStartDay
  	        })
  	      );

  	      /**
  	       * TimePicker instance
  	       * @type {TimePicker}
  	       * @private
  	       */
  	      this._timePicker = null;

  	      /**
  	       * DatePicker input
  	       * @type {DatePickerInput}
  	       * @private
  	       */
  	      this._datepickerInput = null;

  	      /**
  	       * Object having date values
  	       * @type {Date}
  	       * @private
  	       */
  	      this._date = null;

  	      /**
  	       * Selectable date-ranges model
  	       * @type {RangeModel}
  	       * @private
  	       */
  	      this._rangeModel = null;

  	      /**
  	       * openers - opener list
  	       * @type {Array}
  	       * @private
  	       */
  	      this._openers = [];

  	      /**
  	       * State of picker enable
  	       * @type {boolean}
  	       * @private
  	       */
  	      this._isEnabled = true;

  	      /**
  	       * ID of instance
  	       * @type {number}
  	       * @private
  	       */
  	      this._id = 'tui-datepicker-' + util.generateId();

  	      /**
  	       * DatePicker type
  	       * @type {TYPE_DATE|TYPE_MONTH|TYPE_YEAR}
  	       * @private
  	       */
  	      this._type = options.type;

  	      /**
  	       * Show always or not
  	       * @type {boolean}
  	       */
  	      this.showAlways = options.showAlways;

  	      /**
  	       * Close after select a date
  	       * @type {boolean}
  	       */
  	      this.autoClose = options.autoClose;

  	      this._initializeDatePicker(options);
  	    },

  	    /**
  	     * Initialize method
  	     * @param {Object} option - user option
  	     * @private
  	     */
  	    _initializeDatePicker: function(option) {
  	      this.setRanges(option.selectableRanges);
  	      this._setEvents();
  	      this._initTimePicker(option.timePicker, option.usageStatistics);
  	      this.setInput(option.input.element);
  	      this.setDateFormat(option.input.format);
  	      this.setDate(option.date);

  	      forEachArray(option.openers, this.addOpener, this);
  	      if (!this.showAlways) {
  	        this._hide();
  	      }

  	      if (this.getType() === TYPE_DATE) {
  	        addClass(this._element.querySelector(SELECTOR_BODY), 'tui-datepicker-type-date');
  	      }
  	    },

  	    /**
  	     * Set events on the date picker's element
  	     * @param {object} option - Constructor option
  	     * @private
  	     */
  	    _setEvents: function() {
  	      mouseTouchEvent.on(this._element, 'click', this._onClickHandler, this);
  	      this._calendar.on('draw', this._onDrawCalendar, this);
  	    },

  	    /**
  	     * Remove events on the date picker's element
  	     * @private
  	     */
  	    _removeEvents: function() {
  	      mouseTouchEvent.off(this._element, 'click', this._onClickHandler, this);
  	      this._calendar.off();
  	    },

  	    /**
  	     * Set events on the document
  	     * @private
  	     */
  	    _setDocumentEvents: function() {
  	      mouseTouchEvent.on(document, 'mousedown', this._onMousedownDocument, this);
  	    },

  	    /**
  	     * Remove events on the document
  	     * @private
  	     */
  	    _removeDocumentEvents: function() {
  	      mouseTouchEvent.off(document, 'mousedown', this._onMousedownDocument);
  	    },

  	    /**
  	     * Set events on the opener
  	     * @param {HTMLElement} opener An opener to bind the events
  	     * @private
  	     */
  	    _setOpenerEvents: function(opener) {
  	      mouseTouchEvent.on(opener, 'click', this.toggle, this);
  	    },

  	    /**
  	     * Remove events on the opener
  	     * @param {HTMLElement} opener An opener to unbind the events
  	     * @private
  	     */
  	    _removeOpenerEvents: function(opener) {
  	      mouseTouchEvent.off(opener, 'click', this.toggle);
  	    },

  	    /**
  	     * Set TimePicker instance
  	     * @param {object|boolean} opTimePicker - TimePicker instance options
  	     * @param {boolean} usageStatistics - GA tracking options
  	     * @private
  	     */
  	    _initTimePicker: function(opTimePicker, usageStatistics) {
  	      var layoutType;
  	      if (!opTimePicker) {
  	        return;
  	      }

  	      layoutType = opTimePicker.layoutType || '';

  	      if (isObject(opTimePicker)) {
  	        opTimePicker.usageStatistics = usageStatistics;
  	      } else {
  	        opTimePicker = {
  	          usageStatistics: usageStatistics
  	        };
  	      }

  	      this._timePicker = new TimePicker(
  	        this._element.querySelector(SELECTOR_TIMEPICKER_CONTAINER),
  	        opTimePicker
  	      );

  	      if (layoutType.toLowerCase() === 'tab') {
  	        this._timePicker.hide();
  	      }

  	      this._timePicker.on(
  	        'change',
  	        function(ev) {
  	          var prevDate;
  	          if (this._date) {
  	            prevDate = new Date(this._date);
  	            this.setDate(prevDate.setHours(ev.hour, ev.minute));
  	          }
  	        },
  	        this
  	      );
  	    },

  	    /**
  	     * Change picker's type by a selector button.
  	     * @param {HTMLElement} target A target element
  	     * @private
  	     */
  	    _changePicker: function(target) {
  	      var btnSelector = '.' + CLASS_NAME_SELECTOR_BUTTON;
  	      var selectedBtn = closest(target, btnSelector);
  	      var isDateElement = !!selectedBtn.querySelector(SELECTOR_DATE_ICO);

  	      if (isDateElement) {
  	        this._calendar.show();
  	        this._timePicker.hide();
  	      } else {
  	        this._calendar.hide();
  	        this._timePicker.show();
  	      }
  	      removeClass(this._element.querySelector('.' + CLASS_NAME_CHECKED), CLASS_NAME_CHECKED);
  	      addClass(selectedBtn, CLASS_NAME_CHECKED);
  	    },

  	    /**
  	     * Returns whether the element is opener
  	     * @param {string|HTMLElement} element - Element or selector
  	     * @returns {boolean}
  	     * @private
  	     */
  	    _isOpener: function(element) {
  	      var el = util.getElement(element);

  	      return inArray(el, this._openers) > -1;
  	    },

  	    /**
  	     * add/remove today-class-name to date element
  	     * @param {HTMLElement} el - date element
  	     * @private
  	     */
  	    _setTodayClassName: function(el) {
  	      var timestamp, isToday;

  	      if (this.getCalendarType() !== TYPE_DATE) {
  	        return;
  	      }

  	      timestamp = Number(getData(el, 'timestamp'));
  	      isToday = timestamp === new Date().setHours(0, 0, 0, 0);

  	      if (isToday) {
  	        addClass(el, CLASS_NAME_TODAY);
  	      } else {
  	        removeClass(el, CLASS_NAME_TODAY);
  	      }
  	    },

  	    /**
  	     * add/remove selectable-class-name to date element
  	     * @param {HTMLElement} el - date element
  	     * @private
  	     */
  	    _setSelectableClassName: function(el) {
  	      var elDate = new Date(Number(getData(el, 'timestamp')));

  	      if (this._isSelectableOnCalendar(elDate)) {
  	        addClass(el, CLASS_NAME_SELECTABLE);
  	        removeClass(el, CLASS_NAME_BLOCKED);
  	      } else {
  	        removeClass(el, CLASS_NAME_SELECTABLE);
  	        addClass(el, CLASS_NAME_BLOCKED);
  	      }
  	    },

  	    /**
  	     * add/remove selected-class-name to date element
  	     * @param {HTMLElement} el - date element
  	     * @private
  	     */
  	    _setSelectedClassName: function(el) {
  	      var elDate = new Date(Number(getData(el, 'timestamp')));

  	      if (this._isSelectedOnCalendar(elDate)) {
  	        addClass(el, CLASS_NAME_SELECTED);
  	      } else {
  	        removeClass(el, CLASS_NAME_SELECTED);
  	      }
  	    },

  	    /**
  	     * Returns whether the date is selectable on calendar
  	     * @param {Date} date - Date instance
  	     * @returns {boolean}
  	     * @private
  	     */
  	    _isSelectableOnCalendar: function(date) {
  	      var type = this.getCalendarType();
  	      var start = dateUtil.cloneWithStartOf(date, type).getTime();
  	      var end = dateUtil.cloneWithEndOf(date, type).getTime();

  	      return this._rangeModel.hasOverlap(start, end);
  	    },

  	    /**
  	     * Returns whether the date is selected on calendar
  	     * @param {Date} date - Date instance
  	     * @returns {boolean}
  	     * @private
  	     */
  	    _isSelectedOnCalendar: function(date) {
  	      var curDate = this.getDate();
  	      var calendarType = this.getCalendarType();

  	      return curDate && dateUtil.isSame(curDate, date, calendarType);
  	    },

  	    /**
  	     * Show the date picker element
  	     * @private
  	     */
  	    _show: function() {
  	      removeClass(this._element, CLASS_NAME_HIDDEN);
  	    },

  	    /**
  	     * Hide the date picker element
  	     * @private
  	     */
  	    _hide: function() {
  	      addClass(this._element, CLASS_NAME_HIDDEN);
  	    },

  	    /**
  	     * Set value a date-string of current this instance to input element
  	     * @private
  	     */
  	    _syncToInput: function() {
  	      if (!this._date) {
  	        return;
  	      }

  	      this._datepickerInput.setDate(this._date);
  	    },

  	    /**
  	     * Set date from input value
  	     * @param {boolean} [shouldRollback = false] - Should rollback from unselectable or error
  	     * @private
  	     */
  	    _syncFromInput: function(shouldRollback) {
  	      var isFailed = false;
  	      var date;

  	      try {
  	        date = this._datepickerInput.getDate();

  	        if (this.isSelectable(date)) {
  	          if (this._timePicker) {
  	            this._timePicker.setTime(date.getHours(), date.getMinutes());
  	          }
  	          this.setDate(date);
  	        } else {
  	          isFailed = true;
  	        }
  	      } catch (err) {
  	        this.fire('error', {
  	          type: 'ParsingError',
  	          message: err.message
  	        });
  	        isFailed = true;
  	      } finally {
  	        if (isFailed) {
  	          if (shouldRollback) {
  	            this._syncToInput();
  	          } else {
  	            this.setNull();
  	          }
  	        }
  	      }
  	    },

  	    /**
  	     * Event handler for mousedown of document<br>
  	     * - When click the out of layer, close the layer
  	     * @param {Event} ev - Event object
  	     * @private
  	     */
  	    _onMousedownDocument: function(ev) {
  	      var target = util.getTarget(ev);
  	      var selector = util.getSelector(target);
  	      var isContain = selector ? this._element.querySelector(selector) : false;
  	      var isInput = this._datepickerInput.is(target);
  	      var isInOpener = inArray(target, this._openers) > -1;
  	      var shouldClose = !(this.showAlways || isInput || isContain || isInOpener);

  	      if (shouldClose) {
  	        this.close();
  	      }
  	    },

  	    /**
  	     * Event handler for click of calendar
  	     * @param {Event} ev An event object
  	     * @private
  	     */
  	    _onClickHandler: function(ev) {
  	      var target = util.getTarget(ev);

  	      if (closest(target, '.' + CLASS_NAME_SELECTABLE)) {
  	        ev.preventDefault();
  	        this._updateDate(target);
  	      } else if (closest(target, '.' + CLASS_NAME_TITLE_TODAY)) {
  	        ev.preventDefault();
  	        this._updateDateToToday();
  	      } else if (closest(target, SELECTOR_CALENDAR_TITLE)) {
  	        this.drawUpperCalendar(this._date);
  	      } else if (closest(target, '.' + CLASS_NAME_SELECTOR_BUTTON)) {
  	        this._changePicker(target);
  	      }
  	    },

  	    /**
  	     * Update date to today
  	     * @private
  	     */
  	    _updateDateToToday: function() {
  	      this.setDate(Date.now());
  	      this.close();
  	    },

  	    /**
  	     * Update date from event-target
  	     * @param {HTMLElement} target An event target element
  	     * @private
  	     */
  	    _updateDate: function(target) {
  	      var timestamp = Number(getData(target, 'timestamp'));
  	      var newDate = new Date(timestamp);
  	      var timePicker = this._timePicker;
  	      var prevDate = this._date;
  	      var calendarType = this.getCalendarType();
  	      var pickerType = this.getType();

  	      if (calendarType !== pickerType) {
  	        this.drawLowerCalendar(newDate);
  	      } else {
  	        if (timePicker) {
  	          newDate.setHours(timePicker.getHour(), timePicker.getMinute());
  	        } else if (prevDate) {
  	          newDate.setHours(prevDate.getHours(), prevDate.getMinutes());
  	        }
  	        this.setDate(newDate);

  	        if (!this.showAlways && this.autoClose) {
  	          this.close();
  	        }
  	      }
  	    },

  	    /**
  	     * Event handler for 'draw'-custom event of calendar
  	     * @param {Object} eventData - custom event data
  	     * @see {@link Calendar#draw}
  	     * @private
  	     */
  	    _onDrawCalendar: function(eventData) {
  	      forEachArray(
  	        eventData.dateElements,
  	        function(el) {
  	          this._setTodayClassName(el);
  	          this._setSelectableClassName(el);
  	          this._setSelectedClassName(el);
  	        },
  	        this
  	      );
  	      this._setDisplayHeadButtons();

  	      /**
  	       * Occur after the calendar is drawn.
  	       * @event DatePicker#draw
  	       * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on datepicker.on()} to bind event handlers.
  	       * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off datepicker.off()} to unbind event handlers.
  	       * @see Refer to {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents from tui-code-snippet} for more methods. DatePicker mixes in the methods from CustomEvents.
  	       * @property {Date} date - Calendar date
  	       * @property {('date'|'month'|'year')} type - Calendar type
  	       * @property {HTMLElement[]} dateElements - elements for dates
  	       * @example
  	       * // bind the 'draw' event
  	       * datepicker.on('draw', (event) => {
  	       *     console.log(`Draw the ${event.type} calendar and its date is ${event.date}.`);
  	       * });
  	       *
  	       * // unbind the 'draw' event
  	       * datepicker.off('draw');
  	       */
  	      this.fire('draw', eventData);
  	    },

  	    /**
  	     * Hide useless buttons (next, next-year, prev, prev-year)
  	     * @see Don't save buttons reference. The buttons are rerendered every "calendar.draw".
  	     * @private
  	     */
  	    _setDisplayHeadButtons: function() {
  	      var customStep = 60; // 60 months = 5 years = 12 * 5
  	      var nextYearDate = this._calendar.getNextYearDate(
  	        this.getCalendarType() === TYPE_YEAR ? customStep : null
  	      );
  	      var prevYearDate = this._calendar.getPrevYearDate(
  	        this.getCalendarType() === TYPE_YEAR ? -customStep : null
  	      );
  	      var maxTimestamp = this._rangeModel.getMaximumValue();
  	      var minTimestamp = this._rangeModel.getMinimumValue();
  	      var nextYearBtn = this._element.querySelector('.' + CLASS_NAME_NEXT_YEAR_BTN);
  	      var prevYearBtn = this._element.querySelector('.' + CLASS_NAME_PREV_YEAR_BTN);
  	      var nextMonthDate, prevMonthDate, nextMonBtn, prevMonBtn;

  	      if (this.getCalendarType() === TYPE_DATE) {
  	        nextMonthDate = dateUtil.cloneWithStartOf(this._calendar.getNextDate(), TYPE_MONTH);
  	        prevMonthDate = dateUtil.cloneWithEndOf(this._calendar.getPrevDate(), TYPE_MONTH);

  	        nextMonBtn = this._element.querySelector('.' + CLASS_NAME_NEXT_MONTH_BTN);
  	        prevMonBtn = this._element.querySelector('.' + CLASS_NAME_PREV_MONTH_BTN);

  	        this._setDisplay(nextMonBtn, nextMonthDate.getTime() <= maxTimestamp);
  	        this._setDisplay(prevMonBtn, prevMonthDate.getTime() >= minTimestamp);

  	        prevYearDate.setDate(1);
  	        nextYearDate.setDate(1);
  	      } else {
  	        prevYearDate.setMonth(12, 0);
  	        nextYearDate.setMonth(0, 1);
  	      }

  	      this._setDisplay(nextYearBtn, nextYearDate.getTime() <= maxTimestamp);
  	      this._setDisplay(prevYearBtn, prevYearDate.getTime() >= minTimestamp);
  	    },

  	    /**
  	     * Set display show/hide by condition
  	     * @param {HTMLElement} el - An Element
  	     * @param {boolean} shouldShow - Condition
  	     * @private
  	     */
  	    _setDisplay: function(el, shouldShow) {
  	      if (el) {
  	        if (shouldShow) {
  	          removeClass(el, CLASS_NAME_HIDDEN);
  	        } else {
  	          addClass(el, CLASS_NAME_HIDDEN);
  	        }
  	      }
  	    },

  	    /**
  	     * Input change handler
  	     * @private
  	     * @throws {Error}
  	     */
  	    _onChangeInput: function() {
  	      this._syncFromInput(true);
  	    },

  	    /**
  	     * Returns whether the date is changed
  	     * @param {Date} date - Date
  	     * @returns {boolean}
  	     * @private
  	     */
  	    _isChanged: function(date) {
  	      var prevDate = this.getDate();

  	      return !prevDate || date.getTime() !== prevDate.getTime();
  	    },

  	    /**
  	     * Refresh datepicker
  	     * @private
  	     */
  	    _refreshFromRanges: function() {
  	      if (!this.isSelectable(this._date)) {
  	        this.setNull();
  	      } else {
  	        this._calendar.draw(); // view update
  	      }
  	    },

  	    /**
  	     * Return the current calendar's type.
  	     * @returns {('date'|'month'|'year')}
  	     */
  	    getCalendarType: function() {
  	      return this._calendar.getType();
  	    },

  	    /**
  	     * Return the date picker's type.
  	     * @returns {('date'|'month'|'year')}
  	     */
  	    getType: function() {
  	      return this._type;
  	    },

  	    /**
  	     * Return whether the date is selectable.
  	     * @param {Date} date - Date to check
  	     * @returns {boolean}
  	     */
  	    isSelectable: function(date) {
  	      var type = this.getType();
  	      var start, end;

  	      if (!dateUtil.isValidDate(date)) {
  	        return false;
  	      }
  	      start = dateUtil.cloneWithStartOf(date, type).getTime();
  	      end = dateUtil.cloneWithEndOf(date, type).getTime();

  	      return this._rangeModel.hasOverlap(start, end);
  	    },

  	    /**
  	     * Return whether the date is selected.
  	     * @param {Date} date - Date to check
  	     * @returns {boolean}
  	     */
  	    isSelected: function(date) {
  	      return dateUtil.isValidDate(date) && dateUtil.isSame(this._date, date, this.getType());
  	    },

  	    /**
  	     * Set selectable ranges. Previous ranges will be removed.
  	     * @param {Array.<Array<Date|number>>} ranges - Selectable ranges. Use Date instances or numbers(timestamp).
  	     * @example
  	     * datepicker.setRanges([
  	     *     [new Date(2017, 0, 1), new Date(2018, 0, 2)],
  	     *     [new Date(2015, 2, 3), new Date(2016, 4, 2)]
  	     * ]);
  	     */
  	    setRanges: function(ranges) {
  	      var result = [];
  	      forEachArray(ranges, function(range) {
  	        var start = new Date(range[0]).getTime();
  	        var end = new Date(range[1]).getTime();

  	        result.push([start, end]);
  	      });

  	      this._rangeModel = new RangeModel(result);
  	      this._refreshFromRanges();
  	    },

  	    /**
  	     * Set the calendar's type.
  	     * @param {('date'|'month'|'year')} type - Calendar type
  	     * @example
  	     * datepicker.setType('month');
  	     */
  	    setType: function(type) {
  	      this._type = type;
  	    },

  	    /**
  	     * Add a selectable range. Use Date instances or numbers(timestamp).
  	     * @param {Date|number} start - the start date
  	     * @param {Date|number} end - the end date
  	     * @example
  	     * const start = new Date(2015, 1, 3);
  	     * const end = new Date(2015, 2, 6);
  	     *
  	     * datepicker.addRange(start, end);
  	     */
  	    addRange: function(start, end) {
  	      start = new Date(start).getTime();
  	      end = new Date(end).getTime();

  	      this._rangeModel.add(start, end);
  	      this._refreshFromRanges();
  	    },

  	    /**
  	     * Remove a range. Use Date instances or numbers(timestamp).
  	     * @param {Date|number} start - the start date
  	     * @param {Date|number} end - the end date
  	     * @param {null|'date'|'month'|'year'} type - Range type. If falsy, start and end values are considered as timestamp
  	     * @example
  	     * const start = new Date(2015, 1, 3);
  	     * const end = new Date(2015, 2, 6);
  	     *
  	     * datepicker.removeRange(start, end);
  	     */
  	    removeRange: function(start, end, type) {
  	      start = new Date(start);
  	      end = new Date(end);

  	      if (type) {
  	        // @todo Consider time-range on timePicker
  	        start = dateUtil.cloneWithStartOf(start, type);
  	        end = dateUtil.cloneWithEndOf(end, type);
  	      }

  	      this._rangeModel.exclude(start.getTime(), end.getTime());
  	      this._refreshFromRanges();
  	    },

  	    /**
  	     * Add an opener.
  	     * @param {HTMLElement|string} opener - element or selector of opener
  	     */
  	    addOpener: function(opener) {
  	      opener = util.getElement(opener);

  	      if (!this._isOpener(opener)) {
  	        this._openers.push(opener);
  	        this._setOpenerEvents(opener);
  	      }
  	    },

  	    /**
  	     * Remove an opener.
  	     * @param {HTMLElement|string} opener - element or selector of opener
  	     */
  	    removeOpener: function(opener) {
  	      var index;

  	      opener = util.getElement(opener);
  	      index = inArray(opener, this._openers);

  	      if (index > -1) {
  	        this._removeOpenerEvents(opener);
  	        this._openers.splice(index, 1);
  	      }
  	    },

  	    /**
  	     * Remove all openers.
  	     */
  	    removeAllOpeners: function() {
  	      forEachArray(
  	        this._openers,
  	        function(opener) {
  	          this._removeOpenerEvents(opener);
  	        },
  	        this
  	      );
  	      this._openers = [];
  	    },

  	    /**
  	     * Open the date picker.
  	     * @example
  	     * datepicker.open();
  	     */
  	    open: function() {
  	      if (this.isOpened() || !this._isEnabled) {
  	        return;
  	      }

  	      this._calendar.draw({
  	        date: this._date,
  	        type: this._type
  	      });
  	      this._show();

  	      if (!this.showAlways) {
  	        this._setDocumentEvents();
  	      }

  	      /**
  	       * Occur after the date picker opens.
  	       * @event DatePicker#open
  	       * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on datepicker.on()} to bind event handlers.
  	       * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off datepicker.off()} to unbind event handlers.
  	       * @see Refer to {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents from tui-code-snippet} for more methods. DatePicker mixes in the methods from CustomEvents.
  	       * @example
  	       * // bind the 'open' event
  	       * datepicker.on('open', () => {
  	       *     alert('open');
  	       * });
  	       *
  	       * // unbind the 'open' event
  	       * datepicker.off('open');
  	       */
  	      this.fire('open');
  	    },

  	    /**
  	     * Raise the calendar type. (date -> month -> year)
  	     * @param {Date} [date] - Date to set
  	     */
  	    drawUpperCalendar: function(date) {
  	      var calendarType = this.getCalendarType();

  	      if (calendarType === TYPE_DATE) {
  	        this._calendar.draw({
  	          date: date,
  	          type: TYPE_MONTH
  	        });
  	      } else if (calendarType === TYPE_MONTH) {
  	        this._calendar.draw({
  	          date: date,
  	          type: TYPE_YEAR
  	        });
  	      }
  	    },

  	    /**
  	     * Lower the calendar type. (year -> month -> date)
  	     * @param {Date} [date] - Date to set
  	     */
  	    drawLowerCalendar: function(date) {
  	      var calendarType = this.getCalendarType();
  	      var pickerType = this.getType();
  	      var isLast = calendarType === pickerType;

  	      if (isLast) {
  	        return;
  	      }

  	      if (calendarType === TYPE_MONTH) {
  	        this._calendar.draw({
  	          date: date,
  	          type: TYPE_DATE
  	        });
  	      } else if (calendarType === TYPE_YEAR) {
  	        this._calendar.draw({
  	          date: date,
  	          type: TYPE_MONTH
  	        });
  	      }
  	    },

  	    /**
  	     * Close the date picker.
  	     * @exmaple
  	     * datepicker.close();
  	     */
  	    close: function() {
  	      if (!this.isOpened()) {
  	        return;
  	      }
  	      this._removeDocumentEvents();
  	      this._hide();

  	      /**
  	       * Occur after the date picker closes.
  	       * @event DatePicker#close
  	       * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on datepicker.on()} to bind event handlers.
  	       * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off datepicker.off()} to unbind event handlers.
  	       * @see Refer to {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents from tui-code-snippet} for more methods. DatePicker mixes in the methods from CustomEvents.
  	       * @example
  	       * // bind the 'close' event
  	       * datepicker.on('close', () => {
  	       *     alert('close');
  	       * });
  	       *
  	       * // unbind the 'close' event
  	       * datepicker.off('close');
  	       */
  	      this.fire('close');
  	    },

  	    /**
  	     * Toggle the date picker.
  	     * @example
  	     * datepicker.toggle();
  	     */
  	    toggle: function() {
  	      if (this.isOpened()) {
  	        this.close();
  	      } else {
  	        this.open();
  	      }
  	    },

  	    /**
  	     * Return the selected date.
  	     * @returns {?Date} - selected date
  	     * @example
  	     * // 2015-04-13
  	     * datepicker.getDate(); // new Date(2015, 3, 13)
  	     */
  	    getDate: function() {
  	      if (!this._date) {
  	        return null;
  	      }

  	      return new Date(this._date);
  	    },

  	    /**
  	     * Select the date.
  	     * @param {Date|number} date - Date instance or timestamp to set
  	     * @param {boolean} [silent] - Prevents firing 'change' event if it is true.
  	     * @example
  	     * datepicker.setDate(new Date()); // Set today
  	     */
  	    // eslint-disable-next-line complexity
  	    setDate: function(date, silent) {
  	      var isValidInput, newDate, shouldUpdate;

  	      if (date === null) {
  	        this.setNull();

  	        return;
  	      }

  	      isValidInput = isNumber(date) || isDate(date);
  	      newDate = new Date(date);
  	      shouldUpdate = isValidInput && this._isChanged(newDate) && this.isSelectable(newDate);

  	      if (shouldUpdate) {
  	        newDate = new Date(date);
  	        this._date = newDate;
  	        this._calendar.draw({ date: newDate });
  	        if (this._timePicker) {
  	          this._timePicker.setTime(newDate.getHours(), newDate.getMinutes(), true);
  	        }
  	        this._syncToInput();

  	        /**
  	         * Occur after the selected date is changed.
  	         * @event DatePicker#change
  	         * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on datepicker.on()} to bind event handlers.
  	         * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off datepicker.off()} to unbind event handlers.
  	         * @see Refer to {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents from tui-code-snippet} for more methods. DatePicker mixes in the methods from CustomEvents.
  	         * @example
  	         * // bind the 'change' event
  	         * datepicker.on('change', () => {
  	         *     console.log(`Selected date: ${datepicker.getDate()}`);
  	         * });
  	         *
  	         * // unbind the 'change' event
  	         * datepicker.off('change');
  	         */
  	        if (!silent) {
  	          this.fire('change');
  	        }
  	      }
  	    },

  	    /**
  	     * Set no date to be selected. (Selected date: null)
  	     */
  	    setNull: function() {
  	      var calendarDate = this._calendar.getDate();
  	      var isChagned = this._date !== null;

  	      this._date = null;

  	      if (this._datepickerInput) {
  	        this._datepickerInput.clearText();
  	      }
  	      if (this._timePicker) {
  	        this._timePicker.setTime(0, 0);
  	      }

  	      // View update
  	      if (!this.isSelectable(calendarDate)) {
  	        this._calendar.draw({
  	          date: new Date(this._rangeModel.getMinimumValue())
  	        });
  	      } else {
  	        this._calendar.draw();
  	      }

  	      if (isChagned) {
  	        this.fire('change');
  	      }
  	    },

  	    /**
  	     * Select the date by the date string format.
  	     * @param {String} [format] - Date string format
  	     * @example
  	     * datepicker.setDateFormat('yyyy-MM-dd');
  	     * datepicker.setDateFormat('MM-dd, yyyy');
  	     * datepicker.setDateFormat('yy/M/d');
  	     * datepicker.setDateFormat('yy/MM/dd');
  	     */
  	    setDateFormat: function(format) {
  	      this._datepickerInput.setFormat(format);
  	      this._syncToInput();
  	    },

  	    /**
  	     * Return whether the datepicker opens or not
  	     * @returns {boolean}
  	     * @example
  	     * datepicker.close();
  	     * datepicker.isOpened(); // false
  	     *
  	     * datepicker.open();
  	     * datepicker.isOpened(); // true
  	     */
  	    isOpened: function() {
  	      return !hasClass(this._element, CLASS_NAME_HIDDEN);
  	    },

  	    /**
  	     * Return the time picker instance
  	     * @returns {?TimePicker} - TimePicker instance
  	     * @see {@link https://nhn.github.io/tui.time-picker/latest tui-time-picker}
  	     * @example
  	     * const timePicker = this.getTimePicker();
  	     */
  	    getTimePicker: function() {
  	      return this._timePicker;
  	    },

  	    /**
  	     * Return the calendar instance.
  	     * @see {@link calendar Calendar}
  	     * @returns {Calendar}
  	     */
  	    getCalendar: function() {
  	      return this._calendar;
  	    },

  	    /**
  	     * Return the locale text object.
  	     * @see {@link DatePicker#localeTexts DatePicker.localeTexts}
  	     * @returns {object}
  	     */
  	    getLocaleText: function() {
  	      return localeTexts[this._language] || localeTexts[DEFAULT_LANGUAGE_TYPE];
  	    },

  	    /**
  	     * Set the input element
  	     * @param {string|HTMLElement} element - Input element or selector
  	     * @param {object} [options] - Input option
  	     * @param {string} [options.format = prevInput.format] - Format of the Date string in the input
  	     * @param {boolean} [options.syncFromInput = false] - Whether set the date from the input
  	     */
  	    setInput: function(element, options) {
  	      var prev = this._datepickerInput;
  	      var localeText = this.getLocaleText();
  	      var prevFormat;
  	      options = options || {};

  	      if (prev) {
  	        prevFormat = prev.getFormat();
  	        prev.destroy();
  	      }

  	      this._datepickerInput = new DatePickerInput(element, {
  	        format: options.format || prevFormat,
  	        id: this._id,
  	        localeText: localeText
  	      });

  	      this._datepickerInput.on(
  	        {
  	          change: this._onChangeInput,
  	          click: this.open
  	        },
  	        this
  	      );

  	      if (options.syncFromInput) {
  	        this._syncFromInput();
  	      } else {
  	        this._syncToInput();
  	      }
  	    },

  	    /**
  	     * Enable the date picker.
  	     */
  	    enable: function() {
  	      if (this._isEnabled) {
  	        return;
  	      }
  	      this._isEnabled = true;
  	      this._datepickerInput.enable();

  	      forEachArray(
  	        this._openers,
  	        function(opener) {
  	          opener.removeAttribute('disabled');
  	          this._setOpenerEvents(opener);
  	        },
  	        this
  	      );
  	    },

  	    /**
  	     * Disable the date picker.
  	     */
  	    disable: function() {
  	      if (!this._isEnabled) {
  	        return;
  	      }

  	      this._isEnabled = false;
  	      this.close();
  	      this._datepickerInput.disable();

  	      forEachArray(
  	        this._openers,
  	        function(opener) {
  	          opener.setAttribute('disabled', true);
  	          this._removeOpenerEvents(opener);
  	        },
  	        this
  	      );
  	    },

  	    /**
  	     * Return whether the date picker is disabled
  	     * @returns {boolean}
  	     */
  	    isDisabled: function() {
  	      // @todo this._isEnabled --> this._isDisabled
  	      return !this._isEnabled;
  	    },

  	    /**
  	     * Apply a CSS class to the date picker.
  	     * @param {string} className - Class name
  	     */
  	    addCssClass: function(className) {
  	      addClass(this._element, className);
  	    },

  	    /**
  	     * Remove a CSS class from the date picker.
  	     * @param {string} className - Class name
  	     */
  	    removeCssClass: function(className) {
  	      removeClass(this._element, className);
  	    },

  	    /**
  	     * Return the date elements on the calendar.
  	     * @returns {HTMLElement[]}
  	     */
  	    getDateElements: function() {
  	      return this._calendar.getDateElements();
  	    },

  	    /**
  	     * Return the first overlapped range from the point or range.
  	     * @param {Date|number} startDate - Start date to find overlapped range
  	     * @param {Date|number} endDate - End date to find overlapped range
  	     * @returns {Array.<Date>} - \[startDate, endDate]
  	     */
  	    findOverlappedRange: function(startDate, endDate) {
  	      var startTimestamp = new Date(startDate).getTime();
  	      var endTimestamp = new Date(endDate).getTime();
  	      var overlappedRange = this._rangeModel.findOverlappedRange(startTimestamp, endTimestamp);

  	      return [new Date(overlappedRange[0]), new Date(overlappedRange[1])];
  	    },

  	    /**
  	     * Change language.
  	     * @param {string} language - Language code. English('en') and Korean('ko') are provided as default.
  	     * @see To set to the other languages, use {@link DatePicker#localeTexts DatePicker.localeTexts}.
  	     */
  	    changeLanguage: function(language) {
  	      this._language = language;
  	      this._calendar.changeLanguage(this._language);
  	      this._datepickerInput.changeLocaleTitles(this.getLocaleText().titles);
  	      this.setDateFormat(this._datepickerInput.getFormat());

  	      if (this._timePicker) {
  	        this._timePicker.changeLanguage(this._language);
  	      }
  	    },

  	    /**
  	     * Destroy the date picker.
  	     */
  	    destroy: function() {
  	      this._removeDocumentEvents();
  	      this._calendar.destroy();
  	      if (this._timePicker) {
  	        this._timePicker.destroy();
  	      }
  	      if (this._datepickerInput) {
  	        this._datepickerInput.destroy();
  	      }
  	      this._removeEvents();
  	      removeElement(this._element);
  	      this.removeAllOpeners();

  	      this._calendar = this._timePicker = this._datepickerInput = this._container = this._element = this._date = this._rangeModel = this._openers = this._isEnabled = this._id = null;
  	    }
  	  }
  	);

  	CustomEvents.mixin(DatePicker);
  	module.exports = DatePicker;


  	/***/ }),
  	/* 22 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Check whether the given variable is an object or not.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * Check whether the given variable is an object or not.
  	 * If the given variable is an object, return true.
  	 * @param {*} obj - Target for checking
  	 * @returns {boolean} Is object?
  	 * @memberof module:type
  	 */
  	function isObject(obj) {
  	  return obj === Object(obj);
  	}

  	module.exports = isObject;


  	/***/ }),
  	/* 23 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Execute the provided callback once for each property of object which actually exist.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * Execute the provided callback once for each property of object which actually exist.
  	 * If the callback function returns false, the loop will be stopped.
  	 * Callback function(iteratee) is invoked with three arguments:
  	 *  1) The value of the property
  	 *  2) The name of the property
  	 *  3) The object being traversed
  	 * @param {Object} obj The object that will be traversed
  	 * @param {function} iteratee  Callback function
  	 * @param {Object} [context] Context(this) of callback function
  	 * @memberof module:collection
  	 * @example
  	 * var forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); // node, commonjs
  	 *
  	 * var sum = 0;
  	 *
  	 * forEachOwnProperties({a:1,b:2,c:3}, function(value){
  	 *     sum += value;
  	 * });
  	 * alert(sum); // 6
  	 */
  	function forEachOwnProperties(obj, iteratee, context) {
  	  var key;

  	  context = context || null;

  	  for (key in obj) {
  	    if (obj.hasOwnProperty(key)) {
  	      if (iteratee.call(context, obj[key], key, obj) === false) {
  	        break;
  	      }
  	    }
  	  }
  	}

  	module.exports = forEachOwnProperties;


  	/***/ }),
  	/* 24 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Set className value
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var isArray = __webpack_require__(6);
  	var isUndefined = __webpack_require__(12);

  	/**
  	 * Set className value
  	 * @param {(HTMLElement|SVGElement)} element - target element
  	 * @param {(string|string[])} cssClass - class names
  	 * @private
  	 */
  	function setClassName(element, cssClass) {
  	  cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;

  	  cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

  	  if (isUndefined(element.className.baseVal)) {
  	    element.className = cssClass;

  	    return;
  	  }

  	  element.className.baseVal = cssClass;
  	}

  	module.exports = setClassName;


  	/***/ }),
  	/* 25 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Find parent element recursively
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var matches = __webpack_require__(40);

  	/**
  	 * Find parent element recursively
  	 * @param {HTMLElement} element - base element to start find
  	 * @param {string} selector - selector string for find
  	 * @returns {HTMLElement} - element finded or null
  	 * @memberof module:domUtil
  	 */
  	function closest(element, selector) {
  	  var parent = element.parentNode;

  	  if (matches(element, selector)) {
  	    return element;
  	  }

  	  while (parent && parent !== document) {
  	    if (matches(parent, selector)) {
  	      return parent;
  	    }

  	    parent = parent.parentNode;
  	  }

  	  return null;
  	}

  	module.exports = closest;


  	/***/ }),
  	/* 26 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Get data value from data-attribute
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var convertToKebabCase = __webpack_require__(42);

  	/**
  	 * Get data value from data-attribute
  	 * @param {HTMLElement} element - target element
  	 * @param {string} key - key
  	 * @returns {string} value
  	 * @memberof module:domUtil
  	 */
  	function getData(element, key) {
  	  if (element.dataset) {
  	    return element.dataset[key];
  	  }

  	  return element.getAttribute('data-' + convertToKebabCase(key));
  	}

  	module.exports = getData;


  	/***/ }),
  	/* 27 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Check element has specific css class
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var inArray = __webpack_require__(3);
  	var getClass = __webpack_require__(17);

  	/**
  	 * Check element has specific css class
  	 * @param {(HTMLElement|SVGElement)} element - target element
  	 * @param {string} cssClass - css class
  	 * @returns {boolean}
  	 * @memberof module:domUtil
  	 */
  	function hasClass(element, cssClass) {
  	  var origin;

  	  if (element.classList) {
  	    return element.classList.contains(cssClass);
  	  }

  	  origin = getClass(element).split(/\s+/);

  	  return inArray(cssClass, origin) > -1;
  	}

  	module.exports = hasClass;


  	/***/ }),
  	/* 28 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Check whether the given variable is an instance of Date or not.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * Check whether the given variable is an instance of Date or not.
  	 * If the given variables is an instance of Date, return true.
  	 * @param {*} obj - Target for checking
  	 * @returns {boolean} Is an instance of Date?
  	 * @memberof module:type
  	 */
  	function isDate(obj) {
  	  return obj instanceof Date;
  	}

  	module.exports = isDate;


  	/***/ }),
  	/* 29 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Calendar component
  	 */



  	var defineClass = __webpack_require__(0);
  	var CustomEvents = __webpack_require__(8);
  	var addClass = __webpack_require__(16);
  	var hasClass = __webpack_require__(27);
  	var removeClass = __webpack_require__(18);
  	var removeElement = __webpack_require__(14);
  	var extend = __webpack_require__(7);

  	var Header = __webpack_require__(44);
  	var Body = __webpack_require__(49);
  	var localeTexts = __webpack_require__(10);
  	var constants = __webpack_require__(1);
  	var dateUtil = __webpack_require__(5);
  	var util = __webpack_require__(4);

  	var DEFAULT_WEEK_START_DAY = constants.DEFAULT_WEEK_START_DAY;
  	var DEFAULT_LANGUAGE_TYPE = constants.DEFAULT_LANGUAGE_TYPE;

  	var TYPE_DATE = constants.TYPE_DATE;
  	var TYPE_MONTH = constants.TYPE_MONTH;
  	var TYPE_YEAR = constants.TYPE_YEAR;

  	var CLASS_NAME_PREV_MONTH_BTN = constants.CLASS_NAME_PREV_MONTH_BTN;
  	var CLASS_NAME_PREV_YEAR_BTN = constants.CLASS_NAME_PREV_YEAR_BTN;
  	var CLASS_NAME_NEXT_YEAR_BTN = constants.CLASS_NAME_NEXT_YEAR_BTN;
  	var CLASS_NAME_NEXT_MONTH_BTN = constants.CLASS_NAME_NEXT_MONTH_BTN;

  	var CLASS_NAME_CALENDAR_MONTH = 'tui-calendar-month';
  	var CLASS_NAME_CALENDAR_YEAR = 'tui-calendar-year';
  	var CLASS_NAME_HIDDEN = 'tui-hidden';

  	var HEADER_SELECTOR = '.tui-calendar-header';
  	var BODY_SELECTOR = '.tui-calendar-body';

  	/**
  	 * @class
  	 * @description
  	 * Create a calendar by {@link DatePicker#createCalendar DatePicker.createCalendar()}.
  	 * @see {@link /tutorial-example07-calendar Calendar example}
  	 * @param {HTMLElement|string} container - Container or selector of the Calendar
  	 * @param {Object} [options] - Calendar options
  	 *     @param {Date} [options.date = new Date()] - Initial date (default: today)
  	 *     @param {('date'|'month'|'year')} [options.type = 'date'] - Calendar type. Determine whether to show a date, month, or year.
  	 *     @param {string} [options.language = 'en'] - Language code. English('en') and Korean('ko') are provided as default. To use the other languages, use {@link DatePicker#localeTexts DatePicker.localeTexts}.
  	 *     @param {boolean} [options.showToday = true] - Show today.
  	 *     @param {boolean} [options.showJumpButtons = false] - Show the yearly jump buttons (move to the previous and next year in 'date' Calendar)
  	 *     @param {boolean} [options.usageStatistics = true] - Send a hostname to Google Analytics (default: true)
  	 *     @param {string} [options.weekStartDay = 'Sun'] - Start of the week. 'Sun', 'Mon', ..., 'Sat'(default: 'Sun'(start on Sunday))
  	 * @example
  	 * //ES6
  	 * import DatePicker from 'tui-date-picker'
  	 *
  	 * // CommonJS
  	 * const DatePicker = require('tui-date-picker');
  	 *
  	 * // Browser
  	 * const DatePicker = tui.DatePicker;
  	 *
  	 * const calendar = DatePicker.createCalendar('#calendar-wrapper', {
  	 *     language: 'en',
  	 *     showToday: true,
  	 *     showJumpButtons: false,
  	 *     date: new Date(),
  	 *     type: 'date',
  	 *     weekStartDay: 'Mon',
  	 * });
  	 *
  	 * calendar.on('draw', (event) => {
  	 *     console.log(event.date);
  	 *     console.log(event.type);
  	 *     for (let i = 0, len = event.dateElements.length; i < len; i += 1) {
  	 *         const el = event.dateElements[i];
  	 *         const date = new Date(getData(el, 'timestamp'));
  	 *         console.log(date);
  	 *     }
  	 * });
  	 */
  	var Calendar = defineClass(
  	  /** @lends Calendar.prototype */ {
  	    static: {
  	      localeTexts: localeTexts
  	    },
  	    init: function(container, options) {
  	      options = extend(
  	        {
  	          language: DEFAULT_LANGUAGE_TYPE,
  	          showToday: true,
  	          showJumpButtons: false,
  	          date: new Date(),
  	          type: TYPE_DATE,
  	          usageStatistics: true,
  	          weekStartDay: DEFAULT_WEEK_START_DAY
  	        },
  	        options
  	      );

  	      /**
  	       * Container element
  	       * @type {HTMLElement}
  	       * @private
  	       */
  	      this._container = util.getElement(container);
  	      this._container.innerHTML =
  	        '<div class="tui-calendar">' +
  	        '    <div class="tui-calendar-header"></div>' +
  	        '    <div class="tui-calendar-body"></div>' +
  	        '</div>';

  	      /**
  	       * Wrapper element
  	       * @type {HTMLElement}
  	       * @private
  	       */
  	      this._element = this._container.firstChild;

  	      /**
  	       * Date
  	       * @type {Date}
  	       * @private
  	       */
  	      this._date = null;

  	      /**
  	       * Layer type
  	       * @type {string}
  	       * @private
  	       */
  	      this._type = null;

  	      /**
  	       * Header box
  	       * @type {Header}
  	       * @private
  	       */
  	      this._header = null;

  	      /**
  	       * Body box
  	       * @type {Body}
  	       * @private
  	       */
  	      this._body = null;

  	      this._initHeader(options);
  	      this._initBody(options);
  	      this.draw({
  	        date: options.date,
  	        type: options.type
  	      });

  	      if (options.usageStatistics) {
  	        util.sendHostName();
  	      }
  	    },

  	    /**
  	     * Initialize header
  	     * @param {object} options - Header options
  	     * @private
  	     */
  	    _initHeader: function(options) {
  	      var headerContainer = this._element.querySelector(HEADER_SELECTOR);

  	      this._header = new Header(headerContainer, options);
  	      this._header.on(
  	        'click',
  	        function(ev) {
  	          var target = util.getTarget(ev);
  	          if (hasClass(target, CLASS_NAME_PREV_MONTH_BTN)) {
  	            this.drawPrev();
  	          } else if (hasClass(target, CLASS_NAME_PREV_YEAR_BTN)) {
  	            this._onClickPrevYear();
  	          } else if (hasClass(target, CLASS_NAME_NEXT_MONTH_BTN)) {
  	            this.drawNext();
  	          } else if (hasClass(target, CLASS_NAME_NEXT_YEAR_BTN)) {
  	            this._onClickNextYear();
  	          }
  	        },
  	        this
  	      );
  	    },

  	    /**
  	     * Initialize body
  	     * @param {object} options - Body options
  	     * @private
  	     */
  	    _initBody: function(options) {
  	      var bodyContainer = this._element.querySelector(BODY_SELECTOR);

  	      this._body = new Body(bodyContainer, options);
  	    },

  	    /**
  	     * clickHandler - prev year button
  	     * @private
  	     */
  	    _onClickPrevYear: function() {
  	      if (this.getType() === TYPE_DATE) {
  	        this.draw({
  	          date: this._getRelativeDate(-12)
  	        });
  	      } else {
  	        this.drawPrev();
  	      }
  	    },

  	    /**
  	     * clickHandler - next year button
  	     * @private
  	     */
  	    _onClickNextYear: function() {
  	      if (this.getType() === TYPE_DATE) {
  	        this.draw({
  	          date: this._getRelativeDate(12)
  	        });
  	      } else {
  	        this.drawNext();
  	      }
  	    },

  	    /**
  	     * Returns whether the layer type is valid
  	     * @param {string} type - Layer type to check
  	     * @returns {boolean}
  	     * @private
  	     */
  	    _isValidType: function(type) {
  	      return type === TYPE_DATE || type === TYPE_MONTH || type === TYPE_YEAR;
  	    },

  	    /**
  	     * @param {Date} date - Date to draw
  	     * @param {string} type - Layer type to draw
  	     * @returns {boolean}
  	     * @private
  	     */
  	    _shouldUpdate: function(date, type) {
  	      var prevDate = this._date;

  	      if (!dateUtil.isValidDate(date)) {
  	        throw new Error('Invalid date');
  	      }

  	      if (!this._isValidType(type)) {
  	        throw new Error('Invalid layer type');
  	      }

  	      return (
  	        !prevDate ||
  	        prevDate.getFullYear() !== date.getFullYear() ||
  	        prevDate.getMonth() !== date.getMonth() ||
  	        this.getType() !== type
  	      );
  	    },

  	    /**
  	     * Render header & body elements
  	     * @private
  	     */
  	    _render: function() {
  	      var date = this._date;
  	      var type = this.getType();

  	      this._header.render(date, type);
  	      this._body.render(date, type);
  	      removeClass(this._element, CLASS_NAME_CALENDAR_MONTH, CLASS_NAME_CALENDAR_YEAR);

  	      switch (type) {
  	        case TYPE_MONTH:
  	          addClass(this._element, CLASS_NAME_CALENDAR_MONTH);
  	          break;
  	        case TYPE_YEAR:
  	          addClass(this._element, CLASS_NAME_CALENDAR_YEAR);
  	          break;
  	      }
  	    },

  	    /**
  	     * Returns relative date
  	     * @param {number} step - Month step
  	     * @returns {Date}
  	     * @private
  	     */
  	    _getRelativeDate: function(step) {
  	      var prev = this._date;

  	      return new Date(prev.getFullYear(), prev.getMonth() + step);
  	    },

  	    /**
  	     * Draw the calendar.
  	     * @param {Object} [options] - Draw options
  	     *   @param {Date} [options.date] - Date to set
  	     *   @param {('date'|'month'|'year')} [options.type = 'date'] - Calendar type. Determine whether to show a date, month, or year.
  	     * @example
  	     * calendar.draw();
  	     * calendar.draw({
  	     *     date: new Date()
  	     * });
  	     * calendar.draw({
  	     *     type: 'month'
  	     * });
  	     * calendar.draw({
  	     *     type: 'month',
  	     *     date: new Date()
  	     * });
  	     */
  	    draw: function(options) {
  	      var date, type;

  	      options = options || {};
  	      date = options.date || this._date;
  	      type = (options.type || this.getType()).toLowerCase();

  	      if (this._shouldUpdate(date, type)) {
  	        this._date = date;
  	        this._type = type;
  	        this._render();
  	      }

  	      /**
  	       * Occur after the calendar draws.
  	       * @event Calendar#draw
  	       * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on calendar.on()} to bind event handlers.
  	       * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off calendar.off()} to unbind event handlers.
  	       * @see Refer to {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents from tui-code-snippet} for more methods. Calendar mixes in the methods from CustomEvents.
  	       * @property {Date} date - Calendar date
  	       * @property {('date'|'month'|'year')} type - Calendar type
  	       * @property {HTMLElement[]} dateElements - elements for dates
  	       * @example
  	       * // bind the 'draw' event
  	       * calendar.on('draw', ({type, date}) => {
  	       *     console.log(`Draw the ${type} calendar and its date is ${date}.`);
  	       * });
  	       *
  	       * // unbind the 'draw' event
  	       * calendar.off('draw');
  	       */
  	      this.fire('draw', {
  	        date: this._date,
  	        type: type,
  	        dateElements: this._body.getDateElements()
  	      });
  	    },

  	    /**
  	     * Show the calendar.
  	     */
  	    show: function() {
  	      removeClass(this._element, CLASS_NAME_HIDDEN);
  	    },

  	    /**
  	     * Hide the calendar.
  	     */
  	    hide: function() {
  	      addClass(this._element, CLASS_NAME_HIDDEN);
  	    },

  	    /**
  	     * Draw the next page.
  	     */
  	    drawNext: function() {
  	      this.draw({
  	        date: this.getNextDate()
  	      });
  	    },

  	    /**
  	     * Draw the previous page.
  	     */
  	    drawPrev: function() {
  	      this.draw({
  	        date: this.getPrevDate()
  	      });
  	    },

  	    /**
  	     * Return the next date.
  	     * @returns {Date}
  	     */
  	    getNextDate: function() {
  	      if (this.getType() === TYPE_DATE) {
  	        return this._getRelativeDate(1);
  	      }

  	      return this.getNextYearDate();
  	    },

  	    /**
  	     * Return the previous date.
  	     * @returns {Date}
  	     */
  	    getPrevDate: function() {
  	      if (this.getType() === TYPE_DATE) {
  	        return this._getRelativeDate(-1);
  	      }

  	      return this.getPrevYearDate();
  	    },

  	    /**
  	     * Return the date a year later.
  	     * @param {number} [customStep] - custom step for getting relative date
  	     * @returns {Date}
  	     */
  	    getNextYearDate: function(customStep) {
  	      if (customStep) {
  	        return this._getRelativeDate(customStep);
  	      }

  	      switch (this.getType()) {
  	        case TYPE_DATE:
  	        case TYPE_MONTH:
  	          return this._getRelativeDate(12); // 12 months = 1 year
  	        case TYPE_YEAR:
  	          return this._getRelativeDate(108); // 108 months = 9 years = 12 * 9
  	        default:
  	          throw new Error('Unknown layer type');
  	      }
  	    },

  	    /**
  	     * Return the date a year previously.
  	     * @param {number} [customStep] - custom step for getting relative date
  	     * @returns {Date}
  	     */
  	    getPrevYearDate: function(customStep) {
  	      if (customStep) {
  	        return this._getRelativeDate(customStep);
  	      }

  	      switch (this.getType()) {
  	        case TYPE_DATE:
  	        case TYPE_MONTH:
  	          return this._getRelativeDate(-12); // 12 months = 1 year
  	        case TYPE_YEAR:
  	          return this._getRelativeDate(-108); // 108 months = 9 years = 12 * 9
  	        default:
  	          throw new Error('Unknown layer type');
  	      }
  	    },

  	    /**
  	     * Change language.
  	     * @param {string} language - Language code. English('en') and Korean('ko') are provided as default.
  	     * @see To set to the other languages, use {@link DatePicker#localeTexts DatePicker.localeTexts}.
  	     */
  	    changeLanguage: function(language) {
  	      this._header.changeLanguage(language);
  	      this._body.changeLanguage(language);
  	      this._render();
  	    },

  	    /**
  	     * Return the rendered date.
  	     * @returns {Date}
  	     */
  	    getDate: function() {
  	      return new Date(this._date);
  	    },

  	    /**
  	     * Return the calendar's type.
  	     * @returns {('date'|'month'|'year')}
  	     */
  	    getType: function() {
  	      return this._type;
  	    },

  	    /**
  	     * Returns HTML elements for dates.
  	     * @returns {HTMLElement[]}
  	     */
  	    getDateElements: function() {
  	      return this._body.getDateElements();
  	    },

  	    /**
  	     * Apply a CSS class to the calendar.
  	     * @param {string} className - Class name
  	     */
  	    addCssClass: function(className) {
  	      addClass(this._element, className);
  	    },

  	    /**
  	     * Remove a CSS class from the calendar.
  	     * @param {string} className - Class name
  	     */
  	    removeCssClass: function(className) {
  	      removeClass(this._element, className);
  	    },

  	    /**
  	     * Destroy the calendar.
  	     */
  	    destroy: function() {
  	      this._header.destroy();
  	      this._body.destroy();
  	      removeElement(this._element);

  	      this._type = this._date = this._container = this._element = this._header = this._body = null;
  	    }
  	  }
  	);

  	CustomEvents.mixin(Calendar);
  	module.exports = Calendar;


  	/***/ }),
  	/* 30 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Date <-> Text formatting module
  	 */



  	var inArray = __webpack_require__(3);
  	var forEachArray = __webpack_require__(2);
  	var defineClass = __webpack_require__(0);

  	var util = __webpack_require__(4);
  	var dateUtil = __webpack_require__(5);
  	var constants = __webpack_require__(1);
  	var localeTexts = __webpack_require__(10);

  	var rFormableKeys = /\\?(yyyy|yy|mmmm|mmm|mm|m|dd|d|hh|h|a)/gi;
  	var mapForConverting = {
  	  yyyy: {
  	    expression: '(\\d{4}|\\d{2})',
  	    type: constants.TYPE_YEAR
  	  },
  	  yy: {
  	    expression: '(\\d{4}|\\d{2})',
  	    type: constants.TYPE_YEAR
  	  },
  	  y: {
  	    expression: '(\\d{4}|\\d{2})',
  	    type: constants.TYPE_YEAR
  	  },
  	  M: {
  	    expression: '(1[012]|0[1-9]|[1-9])',
  	    type: constants.TYPE_MONTH
  	  },
  	  MM: {
  	    expression: '(1[012]|0[1-9]|[1-9])',
  	    type: constants.TYPE_MONTH
  	  },
  	  MMM: {
  	    expression: '(1[012]|0[1-9]|[1-9])',
  	    type: constants.TYPE_MONTH
  	  },
  	  MMMM: {
  	    expression: '(1[012]|0[1-9]|[1-9])',
  	    type: constants.TYPE_MONTH
  	  },
  	  mmm: {
  	    expression: '(1[012]|0[1-9]|[1-9])',
  	    type: constants.TYPE_MONTH
  	  },
  	  mmmm: {
  	    expression: '(1[012]|0[1-9]|[1-9])',
  	    type: constants.TYPE_MONTH
  	  },
  	  dd: {
  	    expression: '([12]\\d{1}|3[01]|0[1-9]|[1-9])',
  	    type: constants.TYPE_DATE
  	  },
  	  d: {
  	    expression: '([12]\\d{1}|3[01]|0[1-9]|[1-9])',
  	    type: constants.TYPE_DATE
  	  },
  	  D: {
  	    expression: '([12]\\d{1}|3[01]|0[1-9]|[1-9])',
  	    type: constants.TYPE_DATE
  	  },
  	  DD: {
  	    expression: '([12]\\d{1}|3[01]|0[1-9]|[1-9])',
  	    type: constants.TYPE_DATE
  	  },
  	  h: {
  	    expression: '(d{1}|0\\d{1}|1\\d{1}|2[0123])',
  	    type: constants.TYPE_HOUR
  	  },
  	  hh: {
  	    expression: '(d{1}|[01]\\d{1}|2[0123])',
  	    type: constants.TYPE_HOUR
  	  },
  	  H: {
  	    expression: '(d{1}|0\\d{1}|1\\d{1}|2[0123])',
  	    type: constants.TYPE_HOUR
  	  },
  	  HH: {
  	    expression: '(d{1}|[01]\\d{1}|2[0123])',
  	    type: constants.TYPE_HOUR
  	  },
  	  m: {
  	    expression: '(d{1}|[012345]\\d{1})',
  	    type: constants.TYPE_MINUTE
  	  },
  	  mm: {
  	    expression: '(d{1}|[012345]\\d{1})',
  	    type: constants.TYPE_MINUTE
  	  },
  	  a: {
  	    expression: '([ap]m)',
  	    type: constants.TYPE_MERIDIEM
  	  },
  	  A: {
  	    expression: '([ap]m)',
  	    type: constants.TYPE_MERIDIEM
  	  }
  	};

  	/**
  	 * @class
  	 * @ignore
  	 */
  	var DateTimeFormatter = defineClass(
  	  /** @lends DateTimeFormatter.prototype */ {
  	    init: function(rawStr, titles) {
  	      /**
  	       * @type {string}
  	       * @private
  	       */
  	      this._rawStr = rawStr;

  	      /**
  	       * @type {Array}
  	       * @private
  	       * @example
  	       *  rawStr = "yyyy-MM-dd" --> keyOrder = ['year', 'month', 'date']
  	       *  rawStr = "MM/dd, yyyy" --> keyOrder = ['month', 'date', 'year']
  	       */
  	      this._keyOrder = null;

  	      /**
  	       * @type {RegExp}
  	       * @private
  	       */
  	      this._regExp = null;

  	      /**
  	       * Titles
  	       * @type {object}
  	       * @private
  	       */
  	      this._titles = titles || localeTexts.en.titles;

  	      this._parseFormat();
  	    },

  	    /**
  	     * Parse initial format and make the keyOrder, regExp
  	     * @private
  	     */
  	    _parseFormat: function() {
  	      var regExpStr = '^';
  	      var matchedKeys = this._rawStr.match(rFormableKeys);
  	      var keyOrder = [];

  	      matchedKeys = util.filter(matchedKeys, function(key) {
  	        return key[0] !== '\\';
  	      });

  	      forEachArray(matchedKeys, function(key, index) {
  	        if (!/m/i.test(key)) {
  	          key = key.toLowerCase();
  	        }

  	        regExpStr += mapForConverting[key].expression + '[\\D\\s]*';
  	        keyOrder[index] = mapForConverting[key].type;
  	      });

  	      // This formatter does not allow additional numbers at the end of string.
  	      regExpStr += '$';

  	      this._keyOrder = keyOrder;

  	      this._regExp = new RegExp(regExpStr, 'gi');
  	    },

  	    /**
  	     * Parse string to dateHash
  	     * @param {string} str - Date string
  	     * @returns {Date}
  	     */
  	    parse: function(str) {
  	      var dateHash = {
  	        year: 0,
  	        month: 1,
  	        date: 1,
  	        hour: 0,
  	        minute: 0
  	      };
  	      var hasMeridiem = false;
  	      var isPM = false;
  	      var matched;

  	      this._regExp.lastIndex = 0;
  	      matched = this._regExp.exec(str);

  	      if (!matched) {
  	        throw Error('DateTimeFormatter: Not matched - "' + str + '"');
  	      }

  	      // eslint-disable-next-line complexity
  	      forEachArray(this._keyOrder, function(name, index) {
  	        var value = matched[index + 1];

  	        if (name === constants.TYPE_MERIDIEM && /[ap]m/i.test(value)) {
  	          hasMeridiem = true;
  	          isPM = /pm/i.test(value);
  	        } else {
  	          value = Number(value);

  	          if (value !== 0 && !value) {
  	            throw Error('DateTimeFormatter: Unknown value - ' + matched[index + 1]);
  	          }

  	          if (name === constants.TYPE_YEAR && value < 100) {
  	            value += 2000;
  	          }

  	          dateHash[name] = value;
  	        }
  	      });

  	      if (hasMeridiem) {
  	        isPM = isPM || dateHash.hour > 12;
  	        dateHash.hour %= 12;
  	        if (isPM) {
  	          dateHash.hour += 12;
  	        }
  	      }

  	      return new Date(
  	        dateHash.year,
  	        dateHash.month - 1,
  	        dateHash.date,
  	        dateHash.hour,
  	        dateHash.minute
  	      );
  	    },

  	    /**
  	     * Returns raw string of format
  	     * @returns {string}
  	     */
  	    getRawString: function() {
  	      return this._rawStr;
  	    },

  	    /**
  	     * Format date to string
  	     * @param {Date} dateObj - Date object
  	     * @returns {string}
  	     */
  	    format: function(dateObj) {
  	      var year = dateObj.getFullYear();
  	      var month = dateObj.getMonth() + 1;
  	      var dayInMonth = dateObj.getDate();
  	      var day = dateObj.getDay();
  	      var hour = dateObj.getHours();
  	      var minute = dateObj.getMinutes();
  	      var meridiem = 'a'; // Default value for unusing meridiem format
  	      var replaceMap;

  	      if (inArray(constants.TYPE_MERIDIEM, this._keyOrder) > -1) {
  	        meridiem = hour >= 12 ? 'pm' : 'am';
  	        hour = dateUtil.getMeridiemHour(hour);
  	      }

  	      replaceMap = {
  	        yyyy: year,
  	        yy: String(year).substr(2, 2),
  	        M: month,
  	        MM: dateUtil.prependLeadingZero(month),
  	        MMM: this._titles.MMM[month - 1],
  	        MMMM: this._titles.MMMM[month - 1],
  	        d: dayInMonth,
  	        dd: dateUtil.prependLeadingZero(dayInMonth),
  	        D: this._titles.D[day],
  	        DD: this._titles.DD[day],
  	        hh: dateUtil.prependLeadingZero(hour),
  	        h: hour,
  	        mm: dateUtil.prependLeadingZero(minute),
  	        m: minute,
  	        A: meridiem.toUpperCase(),
  	        a: meridiem
  	      };

  	      return this._rawStr.replace(rFormableKeys, function(key) {
  	        if (key[0] === '\\') {
  	          return key.substr(1);
  	        }

  	        return replaceMap[key] || replaceMap[key.toLowerCase()] || '';
  	      });
  	    }
  	  }
  	);

  	module.exports = DateTimeFormatter;


  	/***/ }),
  	/* 31 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Bind DOM events
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var isString = __webpack_require__(13);
  	var forEach = __webpack_require__(9);

  	var safeEvent = __webpack_require__(32);

  	/**
  	 * Bind DOM events.
  	 * @param {HTMLElement} element - element to bind events
  	 * @param {(string|object)} types - Space splitted events names or eventName:handler object
  	 * @param {(function|object)} handler - handler function or context for handler method
  	 * @param {object} [context] context - context for handler method.
  	 * @memberof module:domEvent
  	 * @example
  	 * var div = document.querySelector('div');
  	 * 
  	 * // Bind one event to an element.
  	 * on(div, 'click', toggle);
  	 * 
  	 * // Bind multiple events with a same handler to multiple elements at once.
  	 * // Use event names splitted by a space.
  	 * on(div, 'mouseenter mouseleave', changeColor);
  	 * 
  	 * // Bind multiple events with different handlers to an element at once.
  	 * // Use an object which of key is an event name and value is a handler function.
  	 * on(div, {
  	 *   keydown: highlight,
  	 *   keyup: dehighlight
  	 * });
  	 * 
  	 * // Set a context for handler method.
  	 * var name = 'global';
  	 * var repository = {name: 'CodeSnippet'};
  	 * on(div, 'drag', function() {
  	 *  console.log(this.name);
  	 * }, repository);
  	 * // Result when you drag a div: "CodeSnippet"
  	 */
  	function on(element, types, handler, context) {
  	  if (isString(types)) {
  	    forEach(types.split(/\s+/g), function(type) {
  	      bindEvent(element, type, handler, context);
  	    });

  	    return;
  	  }

  	  forEach(types, function(func, type) {
  	    bindEvent(element, type, func, handler);
  	  });
  	}

  	/**
  	 * Bind DOM events
  	 * @param {HTMLElement} element - element to bind events
  	 * @param {string} type - events name
  	 * @param {function} handler - handler function or context for handler method
  	 * @param {object} [context] context - context for handler method.
  	 * @private
  	 */
  	function bindEvent(element, type, handler, context) {
  	  /**
  	     * Event handler
  	     * @param {Event} e - event object
  	     */
  	  function eventHandler(e) {
  	    handler.call(context || element, e || window.event);
  	  }

  	  if ('addEventListener' in element) {
  	    element.addEventListener(type, eventHandler);
  	  } else if ('attachEvent' in element) {
  	    element.attachEvent('on' + type, eventHandler);
  	  }
  	  memorizeHandler(element, type, handler, eventHandler);
  	}

  	/**
  	 * Memorize DOM event handler for unbinding.
  	 * @param {HTMLElement} element - element to bind events
  	 * @param {string} type - events name
  	 * @param {function} handler - handler function that user passed at on() use
  	 * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features
  	 * @private
  	 */
  	function memorizeHandler(element, type, handler, wrappedHandler) {
  	  var events = safeEvent(element, type);
  	  var existInEvents = false;

  	  forEach(events, function(obj) {
  	    if (obj.handler === handler) {
  	      existInEvents = true;

  	      return false;
  	    }

  	    return true;
  	  });

  	  if (!existInEvents) {
  	    events.push({
  	      handler: handler,
  	      wrappedHandler: wrappedHandler
  	    });
  	  }
  	}

  	module.exports = on;


  	/***/ }),
  	/* 32 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Get event collection for specific HTML element
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var EVENT_KEY = '_feEventKey';

  	/**
  	 * Get event collection for specific HTML element
  	 * @param {HTMLElement} element - HTML element
  	 * @param {string} type - event type
  	 * @returns {array}
  	 * @private
  	 */
  	function safeEvent(element, type) {
  	  var events = element[EVENT_KEY];
  	  var handlers;

  	  if (!events) {
  	    events = element[EVENT_KEY] = {};
  	  }

  	  handlers = events[type];
  	  if (!handlers) {
  	    handlers = events[type] = [];
  	  }

  	  return handlers;
  	}

  	module.exports = safeEvent;


  	/***/ }),
  	/* 33 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Unbind DOM events
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var isString = __webpack_require__(13);
  	var forEach = __webpack_require__(9);

  	var safeEvent = __webpack_require__(32);

  	/**
  	 * Unbind DOM events
  	 * If a handler function is not passed, remove all events of that type.
  	 * @param {HTMLElement} element - element to unbind events
  	 * @param {(string|object)} types - Space splitted events names or eventName:handler object
  	 * @param {function} [handler] - handler function
  	 * @memberof module:domEvent
  	 * @example
  	 * // Following the example of domEvent#on
  	 * 
  	 * // Unbind one event from an element.
  	 * off(div, 'click', toggle);
  	 * 
  	 * // Unbind multiple events with a same handler from multiple elements at once.
  	 * // Use event names splitted by a space.
  	 * off(element, 'mouseenter mouseleave', changeColor);
  	 * 
  	 * // Unbind multiple events with different handlers from an element at once.
  	 * // Use an object which of key is an event name and value is a handler function.
  	 * off(div, {
  	 *   keydown: highlight,
  	 *   keyup: dehighlight
  	 * });
  	 * 
  	 * // Unbind events without handlers.
  	 * off(div, 'drag');
  	 */
  	function off(element, types, handler) {
  	  if (isString(types)) {
  	    forEach(types.split(/\s+/g), function(type) {
  	      unbindEvent(element, type, handler);
  	    });

  	    return;
  	  }

  	  forEach(types, function(func, type) {
  	    unbindEvent(element, type, func);
  	  });
  	}

  	/**
  	 * Unbind DOM events
  	 * If a handler function is not passed, remove all events of that type.
  	 * @param {HTMLElement} element - element to unbind events
  	 * @param {string} type - events name
  	 * @param {function} [handler] - handler function
  	 * @private
  	 */
  	function unbindEvent(element, type, handler) {
  	  var events = safeEvent(element, type);
  	  var index;

  	  if (!handler) {
  	    forEach(events, function(item) {
  	      removeHandler(element, type, item.wrappedHandler);
  	    });
  	    events.splice(0, events.length);
  	  } else {
  	    forEach(events, function(item, idx) {
  	      if (handler === item.handler) {
  	        removeHandler(element, type, item.wrappedHandler);
  	        index = idx;

  	        return false;
  	      }

  	      return true;
  	    });
  	    events.splice(index, 1);
  	  }
  	}

  	/**
  	 * Remove an event handler
  	 * @param {HTMLElement} element - An element to remove an event
  	 * @param {string} type - event type
  	 * @param {function} handler - event handler
  	 * @private
  	 */
  	function removeHandler(element, type, handler) {
  	  if ('removeEventListener' in element) {
  	    element.removeEventListener(type, handler);
  	  } else if ('detachEvent' in element) {
  	    element.detachEvent('on' + type, handler);
  	  }
  	}

  	module.exports = off;


  	/***/ }),
  	/* 34 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview The entry file of DatePicker components
  	 */



  	var DatePicker = __webpack_require__(21);
  	var DateRangePicker = __webpack_require__(60);
  	var Calendar = __webpack_require__(29);

  	__webpack_require__(61);

  	/**
  	 * Create a calendar.
  	 * @see {@link Calendar}
  	 * @see {@link /tutorial-example07-calendar Calendar example}
  	 * @static
  	 * @param {HTMLElement|string} wrapperElement - Container element or selector of the Calendar
  	 * @param {Object} [options] - {@link Calendar} options. Refer to the {@link Calendar Calendar instance's options}.
  	 * @returns {Calendar}
  	 * @example
  	 * const calendar = DatePicker.createCalendar('#calendar-wrapper', {
  	 *    language: 'en',
  	 *    showToday: true,
  	 *    showJumpButtons: false,
  	 *    date: new Date(),
  	 *    type: 'date'
  	 * });
  	 */
  	DatePicker.createCalendar = function(wrapperElement, options) {
  	  return new Calendar(wrapperElement, options);
  	};

  	/**
  	 * Create a date-range picker.
  	 * @see {@link DateRangePicker}
  	 * @see {@link /tutorial-example08-daterangepicker DateRangePicker example}
  	 * @static
  	 * @param {object} options - {@link DateRangePicker} options. Refer to the {@link DateRangePicker DateRangePicker instance's options}.
  	 * @returns {DateRangePicker}
  	 * @example
  	 * const rangepicker = DatePicker.createRangePicker({
  	 *     startpicker: {
  	 *         input: '#start-input',
  	 *         container: '#start-container'
  	 *     },
  	 *     endpicker: {
  	 *         input: '#end-input',
  	 *         container: '#end-container'
  	 *     },
  	 *     type: 'date',
  	 *     format: 'yyyy-MM-dd'
  	 *     selectableRanges: [
  	 *         [new Date(2017, 3, 1), new Date(2017, 5, 1)],
  	 *         [new Date(2017, 6, 3), new Date(2017, 10, 5)]
  	 *     ]
  	 * });
  	 */
  	DatePicker.createRangePicker = function(options) {
  	  return new DateRangePicker(options);
  	};

  	module.exports = DatePicker;


  	/***/ }),
  	/* 35 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Provide a simple inheritance in prototype-oriented.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var createObject = __webpack_require__(36);

  	/**
  	 * Provide a simple inheritance in prototype-oriented.
  	 * Caution :
  	 *  Don't overwrite the prototype of child constructor.
  	 *
  	 * @param {function} subType Child constructor
  	 * @param {function} superType Parent constructor
  	 * @memberof module:inheritance
  	 * @example
  	 * var inherit = require('tui-code-snippet/inheritance/inherit'); // node, commonjs
  	 *
  	 * // Parent constructor
  	 * function Animal(leg) {
  	 *     this.leg = leg;
  	 * }
  	 * Animal.prototype.growl = function() {
  	 *     // ...
  	 * };
  	 *
  	 * // Child constructor
  	 * function Person(name) {
  	 *     this.name = name;
  	 * }
  	 *
  	 * // Inheritance
  	 * inherit(Person, Animal);
  	 *
  	 * // After this inheritance, please use only the extending of property.
  	 * // Do not overwrite prototype.
  	 * Person.prototype.walk = function(direction) {
  	 *     // ...
  	 * };
  	 */
  	function inherit(subType, superType) {
  	  var prototype = createObject(superType.prototype);
  	  prototype.constructor = subType;
  	  subType.prototype = prototype;
  	}

  	module.exports = inherit;


  	/***/ }),
  	/* 36 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Create a new object with the specified prototype object and properties.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * @module inheritance
  	 */

  	/**
  	 * Create a new object with the specified prototype object and properties.
  	 * @param {Object} obj This object will be a prototype of the newly-created object.
  	 * @returns {Object}
  	 * @memberof module:inheritance
  	 */
  	function createObject(obj) {
  	  function F() {} // eslint-disable-line require-jsdoc
  	  F.prototype = obj;

  	  return new F();
  	}

  	module.exports = createObject;


  	/***/ }),
  	/* 37 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Check whether the given variable is existing or not.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var isUndefined = __webpack_require__(12);
  	var isNull = __webpack_require__(38);

  	/**
  	 * Check whether the given variable is existing or not.
  	 * If the given variable is not null and not undefined, returns true.
  	 * @param {*} param - Target for checking
  	 * @returns {boolean} Is existy?
  	 * @memberof module:type
  	 * @example
  	 * var isExisty = require('tui-code-snippet/type/isExisty'); // node, commonjs
  	 *
  	 * isExisty(''); //true
  	 * isExisty(0); //true
  	 * isExisty([]); //true
  	 * isExisty({}); //true
  	 * isExisty(null); //false
  	 * isExisty(undefined); //false
  	*/
  	function isExisty(param) {
  	  return !isUndefined(param) && !isNull(param);
  	}

  	module.exports = isExisty;


  	/***/ }),
  	/* 38 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Check whether the given variable is null or not.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * Check whether the given variable is null or not.
  	 * If the given variable(arguments[0]) is null, returns true.
  	 * @param {*} obj - Target for checking
  	 * @returns {boolean} Is null?
  	 * @memberof module:type
  	 */
  	function isNull(obj) {
  	  return obj === null;
  	}

  	module.exports = isNull;


  	/***/ }),
  	/* 39 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Check whether the given variable is a function or not.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * Check whether the given variable is a function or not.
  	 * If the given variable is a function, return true.
  	 * @param {*} obj - Target for checking
  	 * @returns {boolean} Is function?
  	 * @memberof module:type
  	 */
  	function isFunction(obj) {
  	  return obj instanceof Function;
  	}

  	module.exports = isFunction;


  	/***/ }),
  	/* 40 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Check element match selector
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var inArray = __webpack_require__(3);
  	var toArray = __webpack_require__(41);

  	var elProto = Element.prototype;
  	var matchSelector = elProto.matches ||
  	    elProto.webkitMatchesSelector ||
  	    elProto.mozMatchesSelector ||
  	    elProto.msMatchesSelector ||
  	    function(selector) {
  	      var doc = this.document || this.ownerDocument;

  	      return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;
  	    };

  	/**
  	 * Check element match selector
  	 * @param {HTMLElement} element - element to check
  	 * @param {string} selector - selector to check
  	 * @returns {boolean} is selector matched to element?
  	 * @memberof module:domUtil
  	 */
  	function matches(element, selector) {
  	  return matchSelector.call(element, selector);
  	}

  	module.exports = matches;


  	/***/ }),
  	/* 41 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Transform the Array-like object to Array.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var forEachArray = __webpack_require__(2);

  	/**
  	 * Transform the Array-like object to Array.
  	 * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
  	 * @param {*} arrayLike Array-like object
  	 * @returns {Array} Array
  	 * @memberof module:collection
  	 * @example
  	 * var toArray = require('tui-code-snippet/collection/toArray'); // node, commonjs
  	 *
  	 * var arrayLike = {
  	 *     0: 'one',
  	 *     1: 'two',
  	 *     2: 'three',
  	 *     3: 'four',
  	 *     length: 4
  	 * };
  	 * var result = toArray(arrayLike);
  	 *
  	 * alert(result instanceof Array); // true
  	 * alert(result); // one,two,three,four
  	 */
  	function toArray(arrayLike) {
  	  var arr;
  	  try {
  	    arr = Array.prototype.slice.call(arrayLike);
  	  } catch (e) {
  	    arr = [];
  	    forEachArray(arrayLike, function(value) {
  	      arr.push(value);
  	    });
  	  }

  	  return arr;
  	}

  	module.exports = toArray;


  	/***/ }),
  	/* 42 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Convert kebab-case
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * Convert kebab-case
  	 * @param {string} key - string to be converted to Kebab-case
  	 * @private
  	 */
  	function convertToKebabCase(key) {
  	  return key.replace(/([A-Z])/g, function(match) {
  	    return '-' + match.toLowerCase();
  	  });
  	}

  	module.exports = convertToKebabCase;


  	/***/ }),
  	/* 43 */
  	/***/ (function(module, exports) {

  	module.exports = __WEBPACK_EXTERNAL_MODULE__43__;

  	/***/ }),
  	/* 44 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Calendar Header
  	 */



  	var defineClass = __webpack_require__(0);
  	var CustomEvents = __webpack_require__(8);
  	var closest = __webpack_require__(25);
  	var removeElement = __webpack_require__(14);

  	var localeTexts = __webpack_require__(10);
  	var headerTmpl = __webpack_require__(45);
  	var DateTimeFormatter = __webpack_require__(30);
  	var constants = __webpack_require__(1);
  	var util = __webpack_require__(4);
  	var mouseTouchEvent = __webpack_require__(19);

  	var TYPE_DATE = constants.TYPE_DATE;
  	var TYPE_MONTH = constants.TYPE_MONTH;
  	var TYPE_YEAR = constants.TYPE_YEAR;

  	var CLASS_NAME_TITLE_MONTH = 'tui-calendar-title-month';
  	var CLASS_NAME_TITLE_YEAR = 'tui-calendar-title-year';
  	var CLASS_NAME_TITLE_YEAR_TO_YEAR = 'tui-calendar-title-year-to-year';

  	var SELECTOR_INNER_ELEM = '.tui-calendar-header-inner';
  	var SELECTOR_INFO_ELEM = '.tui-calendar-header-info';
  	var SELECTOR_BTN = '.tui-calendar-btn';

  	var YEAR_TITLE_FORMAT = 'yyyy';

  	/**
  	 * @ignore
  	 * @class
  	 * @param {string|HTMLElement} container - Header container or selector
  	 * @param {object} option - Header option
  	 * @param {string} option.language - Header language
  	 * @param {boolean} option.showToday - Has today box or not.
  	 * @param {boolean} option.showJumpButtons - Has jump buttons or not.
  	 */
  	var Header = defineClass(
  	  /** @lends Header.prototype */ {
  	    init: function(container, option) {
  	      /**
  	       * Container element
  	       * @type {HTMLElement}
  	       * @private
  	       */
  	      this._container = util.getElement(container);

  	      /**
  	       * Header inner element
  	       * @type {HTMLElement}
  	       * @private
  	       */
  	      this._innerElement = null;

  	      /**
  	       * Header info element
  	       * @type {HTMLElement}
  	       * @private
  	       */
  	      this._infoElement = null;

  	      /**
  	       * Render today box or not
  	       * @type {boolean}
  	       * @private
  	       */
  	      this._showToday = option.showToday;

  	      /**
  	       * Render jump buttons or not (next,prev year on date calendar)
  	       * @type {boolean}
  	       * @private
  	       */
  	      this._showJumpButtons = option.showJumpButtons;

  	      /**
  	       * Year_Month title formatter
  	       * @type {DateTimeFormatter}
  	       * @private
  	       */
  	      this._yearMonthTitleFormatter = null;

  	      /**
  	       * Year title formatter
  	       * @type {DateTimeFormatter}
  	       * @private
  	       */
  	      this._yearTitleFormatter = null;

  	      /**
  	       * Today formatter
  	       * @type {DateTimeFormatter}
  	       * @private
  	       */
  	      this._todayFormatter = null;

  	      this._setFormatters(localeTexts[option.language]);
  	      this._setEvents(option);
  	    },

  	    /**
  	     * @param {object} localeText - Locale text
  	     * @private
  	     */
  	    _setFormatters: function(localeText) {
  	      this._yearMonthTitleFormatter = new DateTimeFormatter(
  	        localeText.titleFormat,
  	        localeText.titles
  	      );
  	      this._yearTitleFormatter = new DateTimeFormatter(YEAR_TITLE_FORMAT, localeText.titles);
  	      this._todayFormatter = new DateTimeFormatter(localeText.todayFormat, localeText.titles);
  	    },

  	    /**
  	     * @param {object} option - Constructor option
  	     * @private
  	     */
  	    _setEvents: function() {
  	      mouseTouchEvent.on(this._container, 'click', this._onClickHandler, this);
  	    },

  	    /**
  	     * @private
  	     */
  	    _removeEvents: function() {
  	      this.off();
  	      mouseTouchEvent.off(this._container, 'click', this._onClickHandler);
  	    },

  	    /**
  	     * Fire customEvents
  	     * @param {Event} ev An event object
  	     * @private
  	     */
  	    _onClickHandler: function(ev) {
  	      var target = util.getTarget(ev);

  	      if (closest(target, SELECTOR_BTN)) {
  	        this.fire('click', ev);
  	      }
  	    },

  	    /**
  	     * @param {string} type - Calendar type
  	     * @returns {string}
  	     * @private
  	     */
  	    _getTitleClass: function(type) {
  	      switch (type) {
  	        case TYPE_DATE:
  	          return CLASS_NAME_TITLE_MONTH;
  	        case TYPE_MONTH:
  	          return CLASS_NAME_TITLE_YEAR;
  	        case TYPE_YEAR:
  	          return CLASS_NAME_TITLE_YEAR_TO_YEAR;
  	        default:
  	          return '';
  	      }
  	    },

  	    /**
  	     * @param {Date} date - date
  	     * @param {string} type - Calendar type
  	     * @returns {string}
  	     * @private
  	     */
  	    _getTitleText: function(date, type) {
  	      var currentYear, start, end;

  	      switch (type) {
  	        case TYPE_DATE:
  	          return this._yearMonthTitleFormatter.format(date);
  	        case TYPE_MONTH:
  	          return this._yearTitleFormatter.format(date);
  	        case TYPE_YEAR:
  	          currentYear = date.getFullYear();
  	          start = new Date(currentYear - 4, 0, 1);
  	          end = new Date(currentYear + 4, 0, 1);

  	          return (
  	            this._yearTitleFormatter.format(start) + ' - ' + this._yearTitleFormatter.format(end)
  	          );
  	        default:
  	          return '';
  	      }
  	    },

  	    /**
  	     * Change langauge
  	     * @param {string} language - Language
  	     */
  	    changeLanguage: function(language) {
  	      this._setFormatters(localeTexts[language]);
  	    },

  	    /**
  	     * Render header
  	     * @param {Date} date - date
  	     * @param {string} type - Calendar type
  	     */
  	    render: function(date, type) {
  	      var context = {
  	        showToday: this._showToday,
  	        showJumpButtons: this._showJumpButtons,
  	        todayText: this._todayFormatter.format(new Date()),
  	        isDateCalendar: type === TYPE_DATE,
  	        titleClass: this._getTitleClass(type),
  	        title: this._getTitleText(date, type)
  	      };

  	      this._container.innerHTML = headerTmpl(context).replace(/^\s+|\s+$/g, '');
  	      this._innerElement = this._container.querySelector(SELECTOR_INNER_ELEM);
  	      if (context.showToday) {
  	        this._infoElement = this._container.querySelector(SELECTOR_INFO_ELEM);
  	      }
  	    },

  	    /**
  	     * Destroy header
  	     */
  	    destroy: function() {
  	      this._removeEvents();
  	      removeElement(this._innerElement);
  	      removeElement(this._infoElement);
  	      this._container = this._showToday = this._showJumpButtons = this._yearMonthTitleFormatter = this._yearTitleFormatter = this._todayFormatter = this._innerElement = this._infoElement = null;
  	    }
  	  }
  	);

  	CustomEvents.mixin(Header);
  	module.exports = Header;


  	/***/ }),
  	/* 45 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var template = __webpack_require__(11);

  	module.exports = function(context) {
  	  var source =
  	    '{{if isDateCalendar}}' +
  	    '  {{if showJumpButtons}}' +
  	    '    <div class="tui-calendar-header-inner tui-calendar-has-btns">' +
  	    '      <button class="tui-calendar-btn tui-calendar-btn-prev-year">Prev year</button>' +
  	    '      <button class="tui-calendar-btn tui-calendar-btn-prev-month">Prev month</button>' +
  	    '      <em class="tui-calendar-title {{titleClass}}">{{title}}</em>' +
  	    '      <button class="tui-calendar-btn tui-calendar-btn-next-month">Next month</button>' +
  	    '      <button class="tui-calendar-btn tui-calendar-btn-next-year">Next year</button>' +
  	    '    </div>' +
  	    '  {{else}}' +
  	    '    <div class="tui-calendar-header-inner">' +
  	    '      <button class="tui-calendar-btn tui-calendar-btn-prev-month">Prev month</button>' +
  	    '      <em class="tui-calendar-title {{titleClass}}">{{title}}</em>' +
  	    '      <button class="tui-calendar-btn tui-calendar-btn-next-month">Next month</button>' +
  	    '    </div>' +
  	    '  {{/if}}' +
  	    '{{else}}' +
  	    '  <div class="tui-calendar-header-inner">' +
  	    '    <button class="tui-calendar-btn tui-calendar-btn-prev-year">Prev year</button>' +
  	    '    <em class="tui-calendar-title {{titleClass}}">{{title}}</em>' +
  	    '    <button class="tui-calendar-btn tui-calendar-btn-next-year">Next year</button>' +
  	    '  </div>' +
  	    '{{/if}}' +
  	    '{{if showToday}}' +
  	    '  <div class="tui-calendar-header-info">' +
  	    '    <p class="tui-calendar-title-today">{{todayText}}</p>' +
  	    '  </div>' +
  	    '{{/if}}';

  	  return template(source, context);
  	};


  	/***/ }),
  	/* 46 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Check whether the given variable is a instance of HTMLNode or not.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	/**
  	 * Check whether the given variable is a instance of HTMLNode or not.
  	 * If the given variables is a instance of HTMLNode, return true.
  	 * @param {*} html - Target for checking
  	 * @returns {boolean} Is HTMLNode ?
  	 * @memberof module:type
  	 */
  	function isHTMLNode(html) {
  	  if (typeof HTMLElement === 'object') {
  	    return (html && (html instanceof HTMLElement || !!html.nodeType));
  	  }

  	  return !!(html && html.nodeType);
  	}

  	module.exports = isHTMLNode;


  	/***/ }),
  	/* 47 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Send hostname on DOMContentLoaded.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var isUndefined = __webpack_require__(12);
  	var imagePing = __webpack_require__(48);

  	var ms7days = 7 * 24 * 60 * 60 * 1000;

  	/**
  	 * Check if the date has passed 7 days
  	 * @param {number} date - milliseconds
  	 * @returns {boolean}
  	 * @private
  	 */
  	function isExpired(date) {
  	  var now = new Date().getTime();

  	  return now - date > ms7days;
  	}

  	/**
  	 * Send hostname on DOMContentLoaded.
  	 * To prevent hostname set tui.usageStatistics to false.
  	 * @param {string} appName - application name
  	 * @param {string} trackingId - GA tracking ID
  	 * @ignore
  	 */
  	function sendHostname(appName, trackingId) {
  	  var url = 'https://www.google-analytics.com/collect';
  	  var hostname = location.hostname;
  	  var hitType = 'event';
  	  var eventCategory = 'use';
  	  var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';
  	  var date = window.localStorage.getItem(applicationKeyForStorage);

  	  // skip if the flag is defined and is set to false explicitly
  	  if (!isUndefined(window.tui) && window.tui.usageStatistics === false) {
  	    return;
  	  }

  	  // skip if not pass seven days old
  	  if (date && !isExpired(date)) {
  	    return;
  	  }

  	  window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());

  	  setTimeout(function() {
  	    if (document.readyState === 'interactive' || document.readyState === 'complete') {
  	      imagePing(url, {
  	        v: 1,
  	        t: hitType,
  	        tid: trackingId,
  	        cid: hostname,
  	        dp: hostname,
  	        dh: appName,
  	        el: appName,
  	        ec: eventCategory
  	      });
  	    }
  	  }, 1000);
  	}

  	module.exports = sendHostname;


  	/***/ }),
  	/* 48 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Request image ping.
  	 * @author NHN FE Development Lab <dl_javascript@nhn.com>
  	 */



  	var forEachOwnProperties = __webpack_require__(23);

  	/**
  	 * @module request
  	 */

  	/**
  	 * Request image ping.
  	 * @param {String} url url for ping request
  	 * @param {Object} trackingInfo infos for make query string
  	 * @returns {HTMLElement}
  	 * @memberof module:request
  	 * @example
  	 * var imagePing = require('tui-code-snippet/request/imagePing'); // node, commonjs
  	 *
  	 * imagePing('https://www.google-analytics.com/collect', {
  	 *     v: 1,
  	 *     t: 'event',
  	 *     tid: 'trackingid',
  	 *     cid: 'cid',
  	 *     dp: 'dp',
  	 *     dh: 'dh'
  	 * });
  	 */
  	function imagePing(url, trackingInfo) {
  	  var trackingElement = document.createElement('img');
  	  var queryString = '';
  	  forEachOwnProperties(trackingInfo, function(value, key) {
  	    queryString += '&' + key + '=' + value;
  	  });
  	  queryString = queryString.substring(1);

  	  trackingElement.src = url + '?' + queryString;

  	  trackingElement.style.display = 'none';
  	  document.body.appendChild(trackingElement);
  	  document.body.removeChild(trackingElement);

  	  return trackingElement;
  	}

  	module.exports = imagePing;


  	/***/ }),
  	/* 49 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Calendar body
  	 */



  	var forEachArray = __webpack_require__(2);
  	var defineClass = __webpack_require__(0);

  	var DateLayer = __webpack_require__(50);
  	var MonthLayer = __webpack_require__(52);
  	var YearLayer = __webpack_require__(54);
  	var constants = __webpack_require__(1);

  	var TYPE_DATE = constants.TYPE_DATE;
  	var TYPE_MONTH = constants.TYPE_MONTH;
  	var TYPE_YEAR = constants.TYPE_YEAR;

  	/**
  	 * @ignore
  	 * @class
  	 */
  	var Body = defineClass(
  	  /** @lends Body.prototype */ {
  	    init: function(bodyContainer, options) {
  	      var language = options.language;
  	      var weekStartDay = options.weekStartDay;

  	      /**
  	       * Body container element
  	       * @type {HTMLElement}
  	       * @private
  	       */
  	      this._container = bodyContainer;

  	      /**
  	       * DateLayer
  	       * @type {DateLayer}
  	       * @private
  	       */
  	      this._dateLayer = new DateLayer(language, weekStartDay);

  	      /**
  	       * MonthLayer
  	       * @type {MonthLayer}
  	       * @private
  	       */
  	      this._monthLayer = new MonthLayer(language);

  	      /**
  	       * YearLayer
  	       * @type {YearLayer}
  	       * @private
  	       */
  	      this._yearLayer = new YearLayer(language);

  	      /**
  	       * Current Layer
  	       * @type {DateLayer|MonthLayer|YearLayer}
  	       * @private
  	       */
  	      this._currentLayer = this._dateLayer;
  	    },

  	    /**
  	     * Returns matched layer
  	     * @param {string} type - Layer type
  	     * @returns {Base} - Layer
  	     * @private
  	     */
  	    _getLayer: function(type) {
  	      switch (type) {
  	        case TYPE_DATE:
  	          return this._dateLayer;
  	        case TYPE_MONTH:
  	          return this._monthLayer;
  	        case TYPE_YEAR:
  	          return this._yearLayer;
  	        default:
  	          return this._currentLayer;
  	      }
  	    },

  	    /**
  	     * Iterate each layer
  	     * @param {Function} fn - function
  	     * @private
  	     */
  	    _eachLayer: function(fn) {
  	      forEachArray([this._dateLayer, this._monthLayer, this._yearLayer], fn);
  	    },

  	    /**
  	     * Change language
  	     * @param {string} language - Language
  	     */
  	    changeLanguage: function(language) {
  	      this._eachLayer(function(layer) {
  	        layer.changeLanguage(language);
  	      });
  	    },

  	    /**
  	     * Render body
  	     * @param {Date} date - date
  	     * @param {string} type - Layer type
  	     */
  	    render: function(date, type) {
  	      var nextLayer = this._getLayer(type);
  	      var prevLayer = this._currentLayer;

  	      prevLayer.remove();
  	      nextLayer.render(date, this._container);

  	      this._currentLayer = nextLayer;
  	    },

  	    /**
  	     * Returns date elements
  	     * @returns {HTMLElement[]}
  	     */
  	    getDateElements: function() {
  	      return this._currentLayer.getDateElements();
  	    },

  	    /**
  	     * Destory
  	     */
  	    destroy: function() {
  	      this._eachLayer(function(layer) {
  	        layer.remove();
  	      });

  	      this._container = this._currentLayer = this._dateLayer = this._monthLayer = this._yearLayer = null;
  	    }
  	  }
  	);

  	module.exports = Body;


  	/***/ }),
  	/* 50 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Date layer
  	 */



  	var defineClass = __webpack_require__(0);

  	var dateUtil = __webpack_require__(5);
  	var bodyTmpl = __webpack_require__(51);
  	var LayerBase = __webpack_require__(20);
  	var TYPE_DATE = __webpack_require__(1).TYPE_DATE;
  	var WEEK_START_DAY_MAP = __webpack_require__(1).WEEK_START_DAY_MAP;

  	var DATE_SELECTOR = '.tui-calendar-date';
  	var DAYS_OF_WEEK = 7;

  	/**
  	 * @ignore
  	 * @class
  	 * @extends LayerBase
  	 * @param {string} language - Initial language
  	 */
  	var DateLayer = defineClass(
  	  LayerBase,
  	  /** @lends DateLayer.prototype */ {
  	    init: function(language, weekStartDay) {
  	      LayerBase.call(this, language);

  	      this.weekStartDay = WEEK_START_DAY_MAP[String(weekStartDay).toLowerCase()] || 0;
  	    },

  	    /**
  	     * Layer type
  	     * @type {string}
  	     * @private
  	     */
  	    _type: TYPE_DATE,

  	    /**
  	     * @override
  	     * @private
  	     * @returns {object} Template context
  	     */
  	    _makeContext: function(date) {
  	      var daysShort = this._localeText.titles.D;
  	      var year, month, days, i;

  	      date = date || new Date();
  	      year = date.getFullYear();
  	      month = date.getMonth() + 1;

  	      if (this.weekStartDay) {
  	        days = daysShort.slice();
  	        for (i = 0; i < this.weekStartDay; i += 1) {
  	          days.push(days.shift());
  	        }
  	        daysShort = days;
  	      }

  	      return {
  	        Sun: daysShort[0],
  	        Mon: daysShort[1],
  	        Tue: daysShort[2],
  	        Wed: daysShort[3],
  	        Thu: daysShort[4],
  	        Fri: daysShort[5],
  	        Sat: daysShort[6],
  	        year: year,
  	        month: month,
  	        weeks: this._getWeeks(year, month)
  	      };
  	    },

  	    /**
  	     * weeks (templating) for date-calendar
  	     * @param {number} year - Year
  	     * @param {number} month - Month
  	     * @returns {Array.<Array.<Date>>}
  	     * @private
  	     */
  	    _getWeeks: function(year, month) {
  	      var weekNumber = 0;
  	      var weeksCount = 6; // Fix for no changing height
  	      var weeks = [];
  	      var week, dates, i;

  	      while (weekNumber < weeksCount) {
  	        dates = [];

  	        for (i = this.weekStartDay; i < DAYS_OF_WEEK + this.weekStartDay; i += 1) {
  	          dates.push(dateUtil.getDateOfWeek(year, month, weekNumber, i));
  	        }

  	        week = this._getWeek(year, month, dates);

  	        if (this.weekStartDay && !_isFirstWeek(weekNumber, week[0].dayInMonth)) {
  	          weeks.push(this._getFirstWeek(year, month));
  	          weeksCount -= 1; // Fix for no changing height
  	        }

  	        weeks.push(week);
  	        weekNumber += 1;
  	      }

  	      return weeks;
  	    },

  	    /**
  	     * week (templating) for date-calendar
  	     * @param {number} currentYear
  	     * @param {number} currentMonth
  	     * @param {Array.<Date>} dates
  	     * @private
  	     */
  	    _getWeek: function(currentYear, currentMonth, dates) {
  	      var firstDateOfCurrentMonth = new Date(currentYear, currentMonth - 1, 1);
  	      var lastDateOfCurrentMonth = new Date(currentYear, currentMonth, 0);
  	      var contexts = [];
  	      var i = 0;
  	      var length = dates.length;
  	      var date, className;

  	      for (; i < length; i += 1) {
  	        className = 'tui-calendar-date';
  	        date = dates[i];

  	        if (date < firstDateOfCurrentMonth) {
  	          className += ' tui-calendar-prev-month';
  	        }

  	        if (date > lastDateOfCurrentMonth) {
  	          className += ' tui-calendar-next-month';
  	        }

  	        if (date.getDay() === 0) {
  	          className += ' tui-calendar-sun';
  	        } else if (date.getDay() === 6) {
  	          className += ' tui-calendar-sat';
  	        }

  	        contexts.push({
  	          dayInMonth: date.getDate(),
  	          className: className,
  	          timestamp: date.getTime()
  	        });
  	      }

  	      return contexts;
  	    },

  	    /**
  	     * Render date-layer
  	     * @override
  	     * @param {Date} date Date to render
  	     * @param {HTMLElement} container A container element for the rendered element
  	     */
  	    render: function(date, container) {
  	      var context = this._makeContext(date);

  	      container.innerHTML = bodyTmpl(context);
  	      this._element = container.firstChild;
  	    },

  	    /**
  	     * Return date elements
  	     * @override
  	     * @returns {HTMLElement[]}
  	     */
  	    getDateElements: function() {
  	      return this._element.querySelectorAll(DATE_SELECTOR);
  	    },

  	    _getFirstWeek: function(year, month) {
  	      var firstWeekDates = [];
  	      var i;

  	      for (i = this.weekStartDay; i < DAYS_OF_WEEK + this.weekStartDay; i += 1) {
  	        firstWeekDates.push(dateUtil.getDateOfWeek(year, month, -1, i));
  	      }

  	      return this._getWeek(year, month, firstWeekDates);
  	    }
  	  }
  	);

  	function _isFirstWeek(weekIndex, dayInMonth) {
  	  return weekIndex || dayInMonth === 1 || dayInMonth > DAYS_OF_WEEK;
  	}

  	module.exports = DateLayer;


  	/***/ }),
  	/* 51 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var template = __webpack_require__(11);

  	module.exports = function(context) {
  	  var source =
  	    '<table class="tui-calendar-body-inner" cellspacing="0" cellpadding="0">' +
  	    '  <caption><span>Dates</span></caption>' +
  	    '  <thead class="tui-calendar-body-header">' +
  	    '    <tr>' +
  	    '      <th class="tui-sun" scope="col">{{Sun}}</th>' +
  	    '      <th scope="col">{{Mon}}</th>' +
  	    '      <th scope="col">{{Tue}}</th>' +
  	    '      <th scope="col">{{Wed}}</th>' +
  	    '      <th scope="col">{{Thu}}</th>' +
  	    '      <th scope="col">{{Fri}}</th>' +
  	    '      <th class="tui-sat" scope="col">{{Sat}}</th>' +
  	    '    </tr>' +
  	    '  </thead>' +
  	    '  <tbody>' +
  	    '    {{each weeks}}' +
  	    '    <tr class="tui-calendar-week">' +
  	    '      {{each @this}}' +
  	    '      <td class="{{@this["className"]}}" data-timestamp="{{@this["timestamp"]}}">{{@this["dayInMonth"]}}</td>' +
  	    '      {{/each}}' +
  	    '    </tr>' +
  	    '    {{/each}}' +
  	    '  </tbody>' +
  	    '</table>';

  	  return template(source, context);
  	};


  	/***/ }),
  	/* 52 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Month layer
  	 */



  	var defineClass = __webpack_require__(0);

  	var bodyTmpl = __webpack_require__(53);
  	var LayerBase = __webpack_require__(20);
  	var TYPE_MONTH = __webpack_require__(1).TYPE_MONTH;
  	var dateUtil = __webpack_require__(5);

  	var DATE_SELECTOR = '.tui-calendar-month';

  	/**
  	 * @class
  	 * @extends LayerBase
  	 * @param {string} language - Initial language
  	 * @ignore
  	 */
  	var MonthLayer = defineClass(
  	  LayerBase,
  	  /** @lends MonthLayer.prototype */ {
  	    init: function(language) {
  	      LayerBase.call(this, language);
  	    },

  	    /**
  	     * Layer type
  	     * @type {string}
  	     * @private
  	     */
  	    _type: TYPE_MONTH,

  	    /**
  	     * @override
  	     * @returns {object} Template context
  	     * @private
  	     */
  	    _makeContext: function(date) {
  	      var monthsShort = this._localeText.titles.MMM;

  	      return {
  	        year: date.getFullYear(),
  	        Jan: monthsShort[0],
  	        Feb: monthsShort[1],
  	        Mar: monthsShort[2],
  	        Apr: monthsShort[3],
  	        May: monthsShort[4],
  	        Jun: monthsShort[5],
  	        Jul: monthsShort[6],
  	        Aug: monthsShort[7],
  	        Sep: monthsShort[8],
  	        Oct: monthsShort[9],
  	        Nov: monthsShort[10],
  	        Dec: monthsShort[11],
  	        getFirstDayTimestamp: dateUtil.getFirstDayTimestamp
  	      };
  	    },

  	    /**
  	     * Render month-layer element
  	     * @override
  	     * @param {Date} date Date to render
  	     * @param {HTMLElement} container A container element for the rendered element
  	     */
  	    render: function(date, container) {
  	      var context = this._makeContext(date);

  	      container.innerHTML = bodyTmpl(context);
  	      this._element = container.firstChild;
  	    },

  	    /**
  	     * Returns month elements
  	     * @override
  	     * @returns {HTMLElement[]}
  	     */
  	    getDateElements: function() {
  	      return this._element.querySelectorAll(DATE_SELECTOR);
  	    }
  	  }
  	);

  	module.exports = MonthLayer;


  	/***/ }),
  	/* 53 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var template = __webpack_require__(11);

  	module.exports = function(context) {
  	  var source =
  	    '<table class="tui-calendar-body-inner">' +
  	    '  <caption><span>Months</span></caption>' +
  	    '  <tbody>' +
  	    '    <tr class="tui-calendar-month-group">' +
  	    '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 0}}>{{Jan}}</td>' +
  	    '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 1}}>{{Feb}}</td>' +
  	    '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 2}}>{{Mar}}</td>' +
  	    '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 3}}>{{Apr}}</td>' +
  	    '    </tr>' +
  	    '    <tr class="tui-calendar-month-group">' +
  	    '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 4}}>{{May}}</td>' +
  	    '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 5}}>{{Jun}}</td>' +
  	    '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 6}}>{{Jul}}</td>' +
  	    '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 7}}>{{Aug}}</td>' +
  	    '    </tr>' +
  	    '    <tr class="tui-calendar-month-group">' +
  	    '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 8}}>{{Sep}}</td>' +
  	    '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 9}}>{{Oct}}</td>' +
  	    '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 10}}>{{Nov}}</td>' +
  	    '      <td class="tui-calendar-month" data-timestamp={{getFirstDayTimestamp year 11}}>{{Dec}}</td>' +
  	    '    </tr>' +
  	    '  </tbody>' +
  	    '</table>';

  	  return template(source, context);
  	};


  	/***/ }),
  	/* 54 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Year layer
  	 */



  	var defineClass = __webpack_require__(0);

  	var bodyTmpl = __webpack_require__(55);
  	var LayerBase = __webpack_require__(20);
  	var TYPE_YEAR = __webpack_require__(1).TYPE_YEAR;
  	var dateUtil = __webpack_require__(5);

  	var DATE_SELECTOR = '.tui-calendar-year';

  	/**
  	 * @class
  	 * @extends LayerBase
  	 * @param {string} language - Initial language
  	 * @ignore
  	 */
  	var YearLayer = defineClass(
  	  LayerBase,
  	  /** @lends YearLayer.prototype */ {
  	    init: function(language) {
  	      LayerBase.call(this, language);
  	    },

  	    /**
  	     * Layer type
  	     * @type {string}
  	     * @private
  	     */
  	    _type: TYPE_YEAR,

  	    /**
  	     * @override
  	     * @returns {object} Template context
  	     * @private
  	     */
  	    _makeContext: function(date) {
  	      var year = date.getFullYear();

  	      return {
  	        yearGroups: [
  	          dateUtil.getRangeArr(year - 4, year - 2),
  	          dateUtil.getRangeArr(year - 1, year + 1),
  	          dateUtil.getRangeArr(year + 2, year + 4)
  	        ],
  	        getFirstDayTimestamp: dateUtil.getFirstDayTimestamp
  	      };
  	    },

  	    /**
  	     * Render year-layer element
  	     * @override
  	     * @param {Date} date Date to render
  	     * @param {HTMLElement} container A container element for the rendered element
  	     */
  	    render: function(date, container) {
  	      var context = this._makeContext(date);

  	      container.innerHTML = bodyTmpl(context);
  	      this._element = container.firstChild;
  	    },

  	    /**
  	     * Returns year elements
  	     * @override
  	     * @returns {HTMLElement[]}
  	     */
  	    getDateElements: function() {
  	      return this._element.querySelectorAll(DATE_SELECTOR);
  	    }
  	  }
  	);

  	module.exports = YearLayer;


  	/***/ }),
  	/* 55 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var template = __webpack_require__(11);

  	module.exports = function(context) {
  	  var source =
  	    '<table class="tui-calendar-body-inner">' +
  	    '  <caption><span>Years</span></caption>' +
  	    '  <tbody>' +
  	    '    {{each yearGroups}}' +
  	    '    <tr class="tui-calendar-year-group">' +
  	    '      {{each @this}}' +
  	    '      <td class="tui-calendar-year" data-timestamp={{getFirstDayTimestamp @this 0}}>' +
  	    '        {{@this}}' +
  	    '      </td>' +
  	    '      {{/each}}' +
  	    '    </tr>' +
  	    '    {{/each}}' +
  	    '  </tbody>' +
  	    '</table>';

  	  return template(source, context);
  	};


  	/***/ }),
  	/* 56 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview RangeModel
  	 */



  	var forEachArray = __webpack_require__(2);
  	var defineClass = __webpack_require__(0);
  	var isNumber = __webpack_require__(15);

  	var Range = __webpack_require__(57);
  	var util = __webpack_require__(4);

  	/**
  	 * @class
  	 * @ignore
  	 * @param {Array.<Array.<number>>} ranges - Ranges
  	 */
  	var RangeModel = defineClass(
  	  /** @lends RangeModel.prototype */ {
  	    init: function(ranges) {
  	      ranges = ranges || [];

  	      /**
  	       * @type {Array.<Range>}
  	       * @private
  	       */
  	      this._ranges = [];

  	      forEachArray(
  	        ranges,
  	        function(range) {
  	          this.add(range[0], range[1]);
  	        },
  	        this
  	      );
  	    },

  	    /**
  	     * Whether the ranges contain a time or time-range
  	     * @param {number} start - Start
  	     * @param {number} [end] - End
  	     * @returns {boolean}
  	     */
  	    contains: function(start, end) {
  	      var i = 0;
  	      var length = this._ranges.length;
  	      var range;

  	      for (; i < length; i += 1) {
  	        range = this._ranges[i];
  	        if (range.contains(start, end)) {
  	          return true;
  	        }
  	      }

  	      return false;
  	    },

  	    /**
  	     * Whether overlaps with a point or range
  	     * @param {number} start - Start
  	     * @param {number} [end] - End
  	     * @returns {boolean}
  	     */
  	    hasOverlap: function(start, end) {
  	      var i = 0;
  	      var length = this._ranges.length;
  	      var range;

  	      for (; i < length; i += 1) {
  	        range = this._ranges[i];
  	        if (range.isOverlapped(start, end)) {
  	          return true;
  	        }
  	      }

  	      return false;
  	    },

  	    /**
  	     * Add range
  	     * @param {number} start - Start
  	     * @param {number} [end] - End
  	     */
  	    add: function(start, end) {
  	      var overlapped = false;
  	      var i = 0;
  	      var len = this._ranges.length;
  	      var range;

  	      for (; i < len; i += 1) {
  	        range = this._ranges[i];
  	        overlapped = range.isOverlapped(start, end);

  	        if (overlapped) {
  	          range.merge(start, end);
  	          break;
  	        }

  	        if (start < range.start) {
  	          break;
  	        }
  	      }

  	      if (!overlapped) {
  	        this._ranges.splice(i, 0, new Range(start, end));
  	      }
  	    },

  	    /**
  	     * Returns minimum value in ranges
  	     * @returns {number}
  	     */
  	    getMinimumValue: function() {
  	      return this._ranges[0].start;
  	    },

  	    /**
  	     * Returns maximum value in ranges
  	     * @returns {number}
  	     */
  	    getMaximumValue: function() {
  	      var length = this._ranges.length;

  	      return this._ranges[length - 1].end;
  	    },

  	    /**
  	     * @param {number} start - Start
  	     * @param {number} [end] - End
  	     */
  	    exclude: function(start, end) {
  	      if (!isNumber(end)) {
  	        end = start;
  	      }

  	      forEachArray(
  	        this._ranges,
  	        function(range) {
  	          var rangeEnd;

  	          if (range.isOverlapped(start, end)) {
  	            rangeEnd = range.end; // Save before excluding
  	            range.exclude(start, end);

  	            if (end + 1 <= rangeEnd) {
  	              this.add(end + 1, rangeEnd); // Add split range
  	            }
  	          }
  	        },
  	        this
  	      );

  	      // Reduce empty ranges
  	      this._ranges = util.filter(this._ranges, function(range) {
  	        return !range.isEmpty();
  	      });
  	    },

  	    /**
  	     * Returns the first overlapped range from the point or range
  	     * @param {number} start - Start
  	     * @param {number} end - End
  	     * @returns {Array.<number>} - [start, end]
  	     */
  	    findOverlappedRange: function(start, end) {
  	      var i = 0;
  	      var len = this._ranges.length;
  	      var range;

  	      for (; i < len; i += 1) {
  	        range = this._ranges[i];
  	        if (range.isOverlapped(start, end)) {
  	          return [range.start, range.end];
  	        }
  	      }

  	      return null;
  	    }
  	  }
  	);

  	module.exports = RangeModel;


  	/***/ }),
  	/* 57 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Range (in RangeModel)
  	 */



  	var defineClass = __webpack_require__(0);
  	var isNumber = __webpack_require__(15);

  	/**
  	 * @class
  	 * @ignore
  	 * @param {number} start - Start of range
  	 * @param {number} [end] - End of range
  	 */
  	var Range = defineClass(
  	  /** @lends Range.prototype */ {
  	    init: function(start, end) {
  	      this.setRange(start, end);
  	    },

  	    /**
  	     * Set range
  	     * @param {number} start - Start number
  	     * @param {number} [end] - End number
  	     */
  	    setRange: function(start, end) {
  	      if (!isNumber(end)) {
  	        end = start;
  	      }

  	      this.start = Math.min(start, end);
  	      this.end = Math.max(start, end);
  	    },

  	    /**
  	     * Merge range
  	     * @param {number} start - Start
  	     * @param {number} [end] - End
  	     */
  	    merge: function(start, end) {
  	      if (!isNumber(start) || !isNumber(end) || !this.isOverlapped(start, end)) {
  	        return;
  	      }

  	      this.start = Math.min(start, this.start);
  	      this.end = Math.max(end, this.end);
  	    },

  	    /**
  	     * Whether being empty.
  	     * @returns {boolean}
  	     */
  	    isEmpty: function() {
  	      return !isNumber(this.start) || !isNumber(this.end);
  	    },

  	    /**
  	     * Set empty
  	     */
  	    setEmpty: function() {
  	      this.start = this.end = null;
  	    },

  	    /**
  	     * Whether containing a range.
  	     * @param {number} start - Start
  	     * @param {number} [end] - End
  	     * @returns {boolean}
  	     */
  	    contains: function(start, end) {
  	      if (!isNumber(end)) {
  	        end = start;
  	      }

  	      return this.start <= start && end <= this.end;
  	    },

  	    /**
  	     * Whether overlaps with a range
  	     * @param {number} start - Start
  	     * @param {number} [end] - End
  	     * @returns {boolean}
  	     */
  	    isOverlapped: function(start, end) {
  	      if (!isNumber(end)) {
  	        end = start;
  	      }

  	      return this.start <= end && this.end >= start;
  	    },

  	    /**
  	     * Exclude a range
  	     * @param {number} start - Start
  	     * @param {number} end - End
  	     */
  	    exclude: function(start, end) {
  	      if (start <= this.start && end >= this.end) {
  	        // Excluding range contains this
  	        this.setEmpty();
  	      } else if (this.contains(start)) {
  	        this.setRange(this.start, start - 1);
  	      } else if (this.contains(end)) {
  	        this.setRange(end + 1, this.end);
  	      }
  	    }
  	  }
  	);

  	module.exports = Range;


  	/***/ }),
  	/* 58 */
  	/***/ (function(module, exports, __webpack_require__) {


  	var template = __webpack_require__(11);

  	module.exports = function(context) {
  	  var source =
  	    '<div class="tui-datepicker">' +
  	    '  {{if timePicker}}' +
  	    '    {{if isTab}}' +
  	    '      <div class="tui-datepicker-selector">' +
  	    '        <button type="button" class="tui-datepicker-selector-button tui-is-checked" aria-label="selected">' +
  	    '          <span class="tui-ico-date"></span>{{localeText["date"]}}' +
  	    '        </button>' +
  	    '        <button type="button" class="tui-datepicker-selector-button">' +
  	    '          <span class="tui-ico-time"></span>{{localeText["time"]}}' +
  	    '        </button>' +
  	    '      </div>' +
  	    '      <div class="tui-datepicker-body">' +
  	    '        <div class="tui-calendar-container"></div>' +
  	    '        <div class="tui-timepicker-container"></div>' +
  	    '      </div>' +
  	    '    {{else}}' +
  	    '      <div class="tui-datepicker-body">' +
  	    '        <div class="tui-calendar-container"></div>' +
  	    '      </div>' +
  	    '      <div class="tui-datepicker-footer">' +
  	    '        <div class="tui-timepicker-container"></div>' +
  	    '      </div>' +
  	    '    {{/if}}' +
  	    '  {{else}}' +
  	    '    <div class="tui-datepicker-body">' +
  	    '      <div class="tui-calendar-container"></div>' +
  	    '    </div>' +
  	    '  {{/if}}' +
  	    '</div>';

  	  return template(source, context);
  	};


  	/***/ }),
  	/* 59 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview DatePicker input(element) component
  	 */



  	var defineClass = __webpack_require__(0);
  	var CustomEvents = __webpack_require__(8);
  	var on = __webpack_require__(31);
  	var off = __webpack_require__(33);

  	var DateTimeFormatter = __webpack_require__(30);
  	var mouseTouchEvent = __webpack_require__(19);
  	var util = __webpack_require__(4);

  	var DEFAULT_FORMAT = 'yyyy-MM-dd';

  	/**
  	 * DatePicker Input
  	 * @ignore
  	 * @class
  	 * @param {string|HTMLElement} inputElement - Input element or selector
  	 * @param {object} option - Option
  	 * @param {string} option.id - Id
  	 * @param {string} option.format - Text format
  	 */
  	var DatePickerInput = defineClass(
  	  /** @lends DatePickerInput.prototype */ {
  	    init: function(inputElement, option) {
  	      option.format = option.format || DEFAULT_FORMAT;

  	      /**
  	       * Input element
  	       * @type {HTMLElement}
  	       * @private
  	       */
  	      this._input = util.getElement(inputElement);

  	      /**
  	       * Id
  	       * @type {string}
  	       * @private
  	       */
  	      this._id = option.id;

  	      /**
  	       * LocaleText titles
  	       * @type {Object}
  	       * @private
  	       */
  	      this._titles = option.localeText.titles;

  	      /**
  	       * Text<->DateTime Formatter
  	       * @type {DateTimeFormatter}
  	       * @private
  	       */
  	      this._formatter = new DateTimeFormatter(option.format, this._titles);

  	      this._setEvents();
  	    },

  	    /**
  	     * Change locale titles
  	     * @param {object} titles - locale text in format
  	     */
  	    changeLocaleTitles: function(titles) {
  	      this._titles = titles;
  	    },

  	    /**
  	     * Set input 'click', 'change' event
  	     * @private
  	     */
  	    _setEvents: function() {
  	      if (this._input) {
  	        on(this._input, 'change', this._onChangeHandler, this);
  	        mouseTouchEvent.on(this._input, 'click', this._onClickHandler, this);
  	      }
  	    },

  	    /**
  	     * Remove events
  	     * @private
  	     */
  	    _removeEvents: function() {
  	      this.off();

  	      if (this._input) {
  	        off(this._input, 'change', this._onChangeHandler);
  	        mouseTouchEvent.off(this._input, 'click', this._onClickHandler);
  	      }
  	    },

  	    /**
  	     * Onchange handler
  	     */
  	    _onChangeHandler: function() {
  	      this.fire('change');
  	    },

  	    /**
  	     * Onclick handler
  	     */
  	    _onClickHandler: function() {
  	      this.fire('click');
  	    },

  	    /**
  	     * Check element is same as the input element.
  	     * @param {HTMLElement} el - To check matched set of elements
  	     * @returns {boolean}
  	     */
  	    is: function(el) {
  	      return this._input === el;
  	    },

  	    /**
  	     * Enable input
  	     */
  	    enable: function() {
  	      if (this._input) {
  	        this._input.removeAttribute('disabled');
  	      }
  	    },

  	    /**
  	     * Disable input
  	     */
  	    disable: function() {
  	      if (this._input) {
  	        this._input.setAttribute('disabled', true);
  	      }
  	    },

  	    /**
  	     * Return format
  	     * @returns {string}
  	     */
  	    getFormat: function() {
  	      return this._formatter.getRawString();
  	    },

  	    /**
  	     * Set format
  	     * @param {string} format - Format
  	     */
  	    setFormat: function(format) {
  	      if (!format) {
  	        return;
  	      }

  	      this._formatter = new DateTimeFormatter(format, this._titles);
  	    },

  	    /**
  	     * Clear text
  	     */
  	    clearText: function() {
  	      if (this._input) {
  	        this._input.value = '';
  	      }
  	    },

  	    /**
  	     * Set value from date
  	     * @param {Date} date - Date
  	     */
  	    setDate: function(date) {
  	      if (this._input) {
  	        this._input.value = this._formatter.format(date);
  	      }
  	    },

  	    /**
  	     * Returns date from input-text
  	     * @returns {Date}
  	     * @throws {Error}
  	     */
  	    getDate: function() {
  	      var value = '';

  	      if (this._input) {
  	        value = this._input.value;
  	      }

  	      return this._formatter.parse(value);
  	    },

  	    /**
  	     * Destroy
  	     */
  	    destroy: function() {
  	      this._removeEvents();

  	      this._input = this._id = this._formatter = null;
  	    }
  	  }
  	);

  	CustomEvents.mixin(DatePickerInput);
  	module.exports = DatePickerInput;


  	/***/ }),
  	/* 60 */
  	/***/ (function(module, exports, __webpack_require__) {
  	/**
  	 * @fileoverview Date-Range picker
  	 */



  	var forEachArray = __webpack_require__(2);
  	var defineClass = __webpack_require__(0);
  	var CustomEvents = __webpack_require__(8);
  	var addClass = __webpack_require__(16);
  	var getData = __webpack_require__(26);
  	var removeClass = __webpack_require__(18);
  	var extend = __webpack_require__(7);

  	var DatePicker = __webpack_require__(21);
  	var dateUtil = __webpack_require__(5);
  	var constants = __webpack_require__(1);
  	var util = __webpack_require__(4);

  	var CLASS_NAME_RANGE_PICKER = 'tui-rangepicker';
  	var CLASS_NAME_SELECTED = constants.CLASS_NAME_SELECTED;
  	var CLASS_NAME_SELECTED_RANGE = 'tui-is-selected-range';

  	/**
  	 * @class
  	 * @description
  	 * Create a date-range picker by {@link DatePicker#createRangePicker DatePicker.createRangePicker()}.
  	 * @see {@link /tutorial-example08-daterangepicker DateRangePicker example}
  	 * @param {object} options - DateRangePicker options
  	 *     @param {object} options.startpicker - Startpicker options
  	 *         @param {HTMLElement|string} options.startpicker.input - Startpicker input element or selector
  	 *         @param {HTMLElement|string} options.startpicker.container - Startpicker container element or selector
  	 *         @param {Date|number} [options.startpicker.date] - Initial date of the start picker. Set by a Date instance or a number(timestamp). (default: no initial date)
  	 *         @param {string} [options.startpicker.weekStartDay = 'Sun'] - Start of the week. 'Sun', 'Mon', ..., 'Sat'(default: 'Sun'(start on Sunday))
  	 *     @param {object} options.endpicker - Endpicker options
  	 *         @param {HTMLElement|string} options.endpicker.input - Endpicker input element or selector
  	 *         @param {HTMLElement|string} options.endpicker.container - Endpicker container element or selector
  	 *         @param {Date|number} [options.endpicker.date] - Initial date of the end picker. Set by a Date instance or a number(timestamp). (default: no initial date)
  	 *         @param {string} [options.endpicker.weekStartDay = 'Sun'] - Start of the week. 'Sun', 'Mon', ..., 'Sat'(default: 'Sun'(start on Sunday))
  	 *     @param {('date'|'month'|'year')} [options.type = 'date'] - DatePicker type. Determine whether to choose a date, month, or year.
  	 *     @param {string} [options.language='en'] - Language code. English('en') and Korean('ko') are provided as default. To use the other languages, use {@link DatePicker#localeTexts DatePicker.localeTexts}.
  	 *     @param {object|boolean} [options.timePicker] - [TimePicker](https://nhn.github.io/tui.time-picker/latest) options. Refer to the [TimePicker instance's options](https://nhn.github.io/tui.time-picker/latest/TimePicker). To create the TimePicker without customization, set to true.
  	 *     @param {object} [options.calendar] - {@link Calendar} options. Refer to the {@link Calendar Calendar instance's options}.
  	 *     @param {string} [options.format = 'yyyy-mm-dd'] - Format of the Date string
  	 *     @param {Array.<Array.<Date|number>>} [options.selectableRanges] - Ranges of selectable date. Set by Date instances or numbers(timestamp).
  	 *     @param {boolean} [options.showAlways = false] - Show the DateRangePicker always
  	 *     @param {boolean} [options.autoClose = true] - Close the DateRangePicker after clicking the date
  	 *     @param {boolean} [options.usageStatistics = true] - Send a hostname to Google Analytics (default: true)
  	 * @example
  	 * // ES6
  	 * import DatePicker from 'tui-date-picker'
  	 *
  	 * // CommonJS
  	 * const DatePicker = require('tui-date-picker');
  	 *
  	 * // Browser
  	 * const DatePicker = tui.DatePicker;
  	 *
  	 * const rangePicker = DatePicker.createRangePicker({
  	 *     startpicker: {
  	 *         input: '#start-input',
  	 *         container: '#start-container'
  	 *         date: new Date(2019, 3, 1),
  	 *         weekStartDay: 'Mon',
  	 *     },
  	 *     endpicker: {
  	 *         input: '#end-input',
  	 *         container: '#end-container',
  	 *         weekStartDay: 'Mon',
  	 *     },
  	 *     type: 'date',
  	 *     format: 'yyyy-MM-dd'
  	 *     selectableRanges: [
  	 *         [new Date(2017, 3, 1), new Date(2017, 5, 1)],
  	 *         [new Date(2017, 6, 3), new Date(2017, 10, 5)]
  	 *     ]
  	 * });
  	 */
  	var DateRangePicker = defineClass(
  	  /** @lends DateRangePicker.prototype */ {
  	    init: function(options) {
  	      var startpickerOpt, endpickerOpt;

  	      options = options || {};
  	      startpickerOpt = options.startpicker;
  	      endpickerOpt = options.endpicker;

  	      if (!startpickerOpt) {
  	        throw new Error('The "startpicker" option is required.');
  	      }
  	      if (!endpickerOpt) {
  	        throw new Error('The "endpicker" option is required.');
  	      }

  	      /**
  	       * Start picker
  	       * @type {DatePicker}
  	       * @private
  	       */
  	      this._startpicker = null;

  	      /**
  	       * End picker
  	       * @type {DatePicker}
  	       * @private
  	       */
  	      this._endpicker = null;

  	      this._isRangeSet = false;

  	      this._preEndPickerDate = new Date().getDate();

  	      this._initializePickers(options);
  	      this._syncRangesToEndpicker();
  	    },

  	    /**
  	     * Create picker
  	     * @param {Object} options - DatePicker options
  	     * @private
  	     */
  	    _initializePickers: function(options) {
  	      var startpickerContainer = util.getElement(options.startpicker.container);
  	      var endpickerContainer = util.getElement(options.endpicker.container);
  	      var startInput = util.getElement(options.startpicker.input);
  	      var endInput = util.getElement(options.endpicker.input);

  	      var startpickerOpt = extend({}, options, {
  	        input: {
  	          element: startInput,
  	          format: options.format
  	        },
  	        date: options.startpicker.date,
  	        weekStartDay: options.startpicker.weekStartDay
  	      });
  	      var endpickerOpt = extend({}, options, {
  	        input: {
  	          element: endInput,
  	          format: options.format
  	        },
  	        date: options.endpicker.date,
  	        weekStartDay: options.endpicker.weekStartDay
  	      });

  	      this._startpicker = new DatePicker(startpickerContainer, startpickerOpt);
  	      this._startpicker.addCssClass(CLASS_NAME_RANGE_PICKER);
  	      this._startpicker.on('change', this._onChangeStartpicker, this);
  	      this._startpicker.on('draw', this._onDrawPicker, this);

  	      this._endpicker = new DatePicker(endpickerContainer, endpickerOpt);
  	      this._endpicker.addCssClass(CLASS_NAME_RANGE_PICKER);
  	      this._endpicker.on('change', this._onChangeEndpicker, this);
  	      this._endpicker.on('draw', this._onDrawPicker, this);
  	    },

  	    /**
  	     * Set selection-class to elements after calendar drawing
  	     * @param {Object} eventData - Event data {@link DatePicker#event:draw}
  	     * @private
  	     */
  	    _onDrawPicker: function(eventData) {
  	      var calendarType = eventData.type;
  	      var startDate = this._startpicker.getDate();
  	      var endDate = this._endpicker.getDate();

  	      if (!startDate) {
  	        return;
  	      }

  	      if (!endDate) {
  	        // Convert null to invaild date.
  	        endDate = new Date(NaN);
  	      }

  	      forEachArray(
  	        eventData.dateElements,
  	        function(el) {
  	          var elDate = new Date(Number(getData(el, 'timestamp')));
  	          var isInRange = dateUtil.inRange(startDate, endDate, elDate, calendarType);
  	          var isSelected =
  	            dateUtil.isSame(startDate, elDate, calendarType) ||
  	            dateUtil.isSame(endDate, elDate, calendarType);

  	          this._setRangeClass(el, isInRange);
  	          this._setSelectedClass(el, isSelected);
  	        },
  	        this
  	      );
  	    },

  	    /**
  	     * Set range class to element
  	     * @param {HTMLElement} el - Element
  	     * @param {boolean} isInRange - In range
  	     * @private
  	     */
  	    _setRangeClass: function(el, isInRange) {
  	      if (isInRange) {
  	        addClass(el, CLASS_NAME_SELECTED_RANGE);
  	      } else {
  	        removeClass(el, CLASS_NAME_SELECTED_RANGE);
  	      }
  	    },

  	    /**
  	     * Set selected class to element
  	     * @param {HTMLElement} el - Element
  	     * @param {boolean} isSelected - Is selected
  	     * @private
  	     */
  	    _setSelectedClass: function(el, isSelected) {
  	      if (isSelected) {
  	        addClass(el, CLASS_NAME_SELECTED);
  	      } else {
  	        removeClass(el, CLASS_NAME_SELECTED);
  	      }
  	    },

  	    /**
  	     * Sync ranges to endpicker
  	     * @private
  	     */
  	    _syncRangesToEndpicker: function() {
  	      var startDate = this._startpicker.getDate();
  	      var overlappedRange;

  	      if (startDate) {
  	        overlappedRange = this._startpicker.findOverlappedRange(
  	          dateUtil.cloneWithStartOf(startDate).getTime(),
  	          dateUtil.cloneWithEndOf(startDate).getTime()
  	        );

  	        this._endpicker.enable();
  	        this._endpicker.setRanges([[startDate.getTime(), overlappedRange[1].getTime()]]);

  	        this._setTimeRangeOnEndPicker();
  	      } else {
  	        this._endpicker.setNull();
  	        this._endpicker.disable();
  	      }
  	    },

  	    /**
  	     * After change on start-picker
  	     * @private
  	     */
  	    _onChangeStartpicker: function() {
  	      this._syncRangesToEndpicker();
  	      /**
  	       * Occur after the start date is changed.
  	       * @event DateRangePicker#change:start
  	       * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on rangePicker.on()} to bind event handlers.
  	       * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off rangePicker.off()} to unbind event handlers.
  	       * @see Refer to {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents} for more methods. DateRangePicker mixes in the methods from CustomEvents.
  	       * @example
  	       * // bind the 'change:start' event
  	       * rangePicker.on('change:start', () => {
  	       *     console.log(`Start date: ${rangePicker.getStartDate()}`);
  	       * });
  	       *
  	       * // unbind the 'change:start' event
  	       * rangePicker.off('change:start');
  	       */
  	      this.fire('change:start');
  	    },

  	    /**
  	     * After change on end-picker
  	     * @private
  	     */
  	    _onChangeEndpicker: function() {
  	      /**
  	       * Occur after the end date is changed.
  	       * @event DateRangePicker#change:end
  	       * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on rangePicker.on()} to bind event handlers.
  	       * @see {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off rangePicker.off()} to unbind event handlers.
  	       * @see Refer to {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents} for more methods. DateRangePicker mixes in the methods from CustomEvents.
  	       * @example
  	       * // bind the 'change:end' event
  	       * rangePicker.on('change:end', () => {
  	       *     console.log(`End date: ${rangePicker.getEndDate()}`);
  	       * });
  	       *
  	       * // unbind the 'change:end' event
  	       * rangePicker.off('change:end');
  	       */

  	      var date;
  	      var endPickerDate = this._endpicker.getDate();

  	      if (endPickerDate) {
  	        date = endPickerDate.getDate();
  	        if (this._preEndPickerDate !== date) {
  	          this._setTimeRangeOnEndPicker();
  	        }

  	        this._preEndPickerDate = date;
  	      } else {
  	        this._preEndPickerDate = null;
  	      }

  	      this.fire('change:end');
  	    },

  	    /*
  	     * Get date of start picker and end picker being same
  	     * @returns {boolean}
  	     * @private
  	     */
  	    _isStartAndEndDateSame: function() {
  	      return (
  	        !!this._endpicker.getDate() &&
  	        !!this._startpicker.getDate() &&
  	        dateUtil.compare(
  	          this._endpicker.getDate(),
  	          this._startpicker.getDate(),
  	          constants.TYPE_DATE
  	        ) === 0
  	      );
  	    },

  	    /**
  	     * Set time range on end picker
  	     * @private
  	     */
  	    _setTimeRangeOnEndPicker: function() {
  	      var pickerDate, timeRange, timeRangeToSet;
  	      var endTimePicker = this._endpicker._timePicker;

  	      if (!endTimePicker) {
  	        return;
  	      }

  	      pickerDate = this._endpicker.getDate() || this._startpicker.getDate();
  	      timeRange = this._getTimeRangeFromStartPicker();
  	      timeRangeToSet = pickerDate && timeRange[pickerDate.getDate()];

  	      if (this._isStartAndEndDateSame() && timeRangeToSet) {
  	        endTimePicker.setRange(timeRangeToSet);
  	        this._isRangeSet = true;
  	      } else if (this._isRangeSet) {
  	        endTimePicker.setRange({ hour: 0, minute: 0 });
  	        endTimePicker.resetMinuteRange();
  	        this._isRangeSet = false;
  	      }
  	    },

  	    /**
  	     * Return object of time range from start picker.
  	     * @returns {object}
  	     * @private
  	     */
  	    _getTimeRangeFromStartPicker: function() {
  	      var startDate = this._startpicker.getDate();
  	      var timeRange = {};

  	      timeRange[startDate.getDate()] = {
  	        hour: startDate.getHours(),
  	        minute: startDate.getMinutes()
  	      };

  	      return timeRange;
  	    },

  	    /**
  	     * Return a start-datepicker.
  	     * @returns {DatePicker}
  	     */
  	    getStartpicker: function() {
  	      return this._startpicker;
  	    },

  	    /**
  	     * Return a end-datepicker.
  	     * @returns {DatePicker}
  	     */
  	    getEndpicker: function() {
  	      return this._endpicker;
  	    },

  	    /**
  	     * Set the start date.
  	     * @param {Date} date - Start date
  	     */
  	    setStartDate: function(date) {
  	      this._startpicker.setDate(date);
  	    },

  	    /**
  	     * Return the start date.
  	     * @returns {?Date}
  	     */
  	    getStartDate: function() {
  	      return this._startpicker.getDate();
  	    },

  	    /**
  	     * Return the end date.
  	     * @returns {?Date}
  	     */
  	    getEndDate: function() {
  	      return this._endpicker.getDate();
  	    },

  	    /**
  	     * Set the end date.
  	     * @param {Date} date - End date
  	     */
  	    setEndDate: function(date) {
  	      this._endpicker.setDate(date);
  	    },

  	    /**
  	     * Set selectable ranges.
  	     * @param {Array.<Array.<number|Date>>} ranges - Selectable ranges. Use Date instances or numbers(timestamp).
  	     */
  	    setRanges: function(ranges) {
  	      this._startpicker.setRanges(ranges);
  	      this._syncRangesToEndpicker();
  	    },

  	    /**
  	     * Add a selectable range. Use Date instances or numbers(timestamp).
  	     * @param {Date|number} start - the start date
  	     * @param {Date|number} end - the end date
  	     */
  	    addRange: function(start, end) {
  	      this._startpicker.addRange(start, end);
  	      this._syncRangesToEndpicker();
  	    },

  	    /**
  	     * Remove a range. Use Date instances or numbers(timestamp).
  	     * @param {Date|number} start - the start date
  	     * @param {Date|number} end - the end date
  	     * @param {null|'date'|'month'|'year'} type - Range type. If falsy, start and end values are considered as timestamp
  	     */
  	    removeRange: function(start, end, type) {
  	      this._startpicker.removeRange(start, end, type);
  	      this._syncRangesToEndpicker();
  	    },

  	    /**
  	     * Change language.
  	     * @param {string} language - Language code. English('en') and Korean('ko') are provided as default.
  	     * @see To set to the other languages, use {@link DatePicker#localeTexts DatePicker.localeTexts}.
  	     */
  	    changeLanguage: function(language) {
  	      this._startpicker.changeLanguage(language);
  	      this._endpicker.changeLanguage(language);
  	    },

  	    /**
  	     * Destroy the date-range picker.
  	     */
  	    destroy: function() {
  	      this.off();
  	      this._startpicker.destroy();
  	      this._endpicker.destroy();
  	      this._startpicker = this._endpicker = null;
  	    }
  	  }
  	);

  	CustomEvents.mixin(DateRangePicker);
  	module.exports = DateRangePicker;


  	/***/ }),
  	/* 61 */
  	/***/ (function(module, exports, __webpack_require__) {

  	// extracted by mini-css-extract-plugin

  	/***/ })
  	/******/ ]);
  	}); 
  } (tuiDatePicker));

  var tuiDatePickerExports = tuiDatePicker.exports;
  var DatePicker = /*@__PURE__*/getDefaultExportFromCjs(tuiDatePickerExports);

  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b2)) {
        if (__propIsEnum.call(b2, prop))
          __defNormalProp(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var n$2, l$3, u$3, i$3, o$3, r$2, f$3, e$1, c$3 = {}, s$3 = [], a$3 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, h$3 = Array.isArray;
  function v$3(n2, l2) {
    for (var u2 in l2)
      n2[u2] = l2[u2];
    return n2;
  }
  function p$3(n2) {
    var l2 = n2.parentNode;
    l2 && l2.removeChild(n2);
  }
  function y$3(l2, u2, t2) {
    var i2, o2, r2, f2 = {};
    for (r2 in u2)
      "key" == r2 ? i2 = u2[r2] : "ref" == r2 ? o2 = u2[r2] : f2[r2] = u2[r2];
    if (arguments.length > 2 && (f2.children = arguments.length > 3 ? n$2.call(arguments, 2) : t2), "function" == typeof l2 && null != l2.defaultProps)
      for (r2 in l2.defaultProps)
        void 0 === f2[r2] && (f2[r2] = l2.defaultProps[r2]);
    return d$3(l2, f2, i2, o2, null);
  }
  function d$3(n2, t2, i2, o2, r2) {
    var f2 = { type: n2, props: t2, key: i2, ref: o2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r2 ? ++u$3 : r2, __i: -1, __u: 0 };
    return null == r2 && null != l$3.vnode && l$3.vnode(f2), f2;
  }
  function g$2(n2) {
    return n2.children;
  }
  function b$2(n2, l2) {
    this.props = n2, this.context = l2;
  }
  function m$2(n2, l2) {
    if (null == l2)
      return n2.__ ? m$2(n2.__, n2.__i + 1) : null;
    for (var u2; l2 < n2.__k.length; l2++)
      if (null != (u2 = n2.__k[l2]) && null != u2.__e)
        return u2.__e;
    return "function" == typeof n2.type ? m$2(n2) : null;
  }
  function w$4(n2) {
    var l2, u2;
    if (null != (n2 = n2.__) && null != n2.__c) {
      for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++)
        if (null != (u2 = n2.__k[l2]) && null != u2.__e) {
          n2.__e = n2.__c.base = u2.__e;
          break;
        }
      return w$4(n2);
    }
  }
  function k$3(n2) {
    (!n2.__d && (n2.__d = true) && i$3.push(n2) && !x$4.__r++ || o$3 !== l$3.debounceRendering) && ((o$3 = l$3.debounceRendering) || r$2)(x$4);
  }
  function x$4() {
    var n2, u2, t2, o2, r2, e2, c2, s2, a2;
    for (i$3.sort(f$3); n2 = i$3.shift(); )
      n2.__d && (u2 = i$3.length, o2 = void 0, e2 = (r2 = (t2 = n2).__v).__e, s2 = [], a2 = [], (c2 = t2.__P) && ((o2 = v$3({}, r2)).__v = r2.__v + 1, l$3.vnode && l$3.vnode(o2), F$3(c2, o2, r2, t2.__n, void 0 !== c2.ownerSVGElement, 32 & r2.__u ? [e2] : null, s2, null == e2 ? m$2(r2) : e2, !!(32 & r2.__u), a2), o2.__v = r2.__v, o2.__.__k[o2.__i] = o2, L$2(s2, o2, a2), o2.__e != e2 && w$4(o2)), i$3.length > u2 && i$3.sort(f$3));
    x$4.__r = 0;
  }
  function C$3(n2, l2, u2, t2, i2, o2, r2, f2, e2, a2, h2) {
    var v2, p2, y2, d2, _2, g2 = t2 && t2.__k || s$3, b2 = l2.length;
    for (u2.__d = e2, P$3(u2, l2, g2), e2 = u2.__d, v2 = 0; v2 < b2; v2++)
      null != (y2 = u2.__k[v2]) && "boolean" != typeof y2 && "function" != typeof y2 && (p2 = -1 === y2.__i ? c$3 : g2[y2.__i] || c$3, y2.__i = v2, F$3(n2, y2, p2, i2, o2, r2, f2, e2, a2, h2), d2 = y2.__e, y2.ref && p2.ref != y2.ref && (p2.ref && O$3(p2.ref, null, y2), h2.push(y2.ref, y2.__c || d2, y2)), null == _2 && null != d2 && (_2 = d2), 65536 & y2.__u || p2.__k === y2.__k ? (d2 || p2.__e != e2 || (e2 = m$2(p2)), e2 = S$3(y2, e2, n2)) : "function" == typeof y2.type && void 0 !== y2.__d ? e2 = y2.__d : d2 && (e2 = d2.nextSibling), y2.__d = void 0, y2.__u &= -196609);
    u2.__d = e2, u2.__e = _2;
  }
  function P$3(n2, l2, u2) {
    var t2, i2, o2, r2, f2, e2 = l2.length, c2 = u2.length, s2 = c2, a2 = 0;
    for (n2.__k = [], t2 = 0; t2 < e2; t2++)
      r2 = t2 + a2, null != (i2 = n2.__k[t2] = null == (i2 = l2[t2]) || "boolean" == typeof i2 || "function" == typeof i2 ? null : "string" == typeof i2 || "number" == typeof i2 || "bigint" == typeof i2 || i2.constructor == String ? d$3(null, i2, null, null, null) : h$3(i2) ? d$3(g$2, { children: i2 }, null, null, null) : void 0 === i2.constructor && i2.__b > 0 ? d$3(i2.type, i2.props, i2.key, i2.ref ? i2.ref : null, i2.__v) : i2) ? (i2.__ = n2, i2.__b = n2.__b + 1, f2 = I$2(i2, u2, r2, s2), i2.__i = f2, o2 = null, -1 !== f2 && (s2--, (o2 = u2[f2]) && (o2.__u |= 131072)), null == o2 || null === o2.__v ? (-1 == f2 && a2--, "function" != typeof i2.type && (i2.__u |= 65536)) : f2 !== r2 && (f2 === r2 + 1 ? a2++ : f2 > r2 ? s2 > e2 - r2 ? a2 += f2 - r2 : a2-- : f2 < r2 ? f2 == r2 - 1 && (a2 = f2 - r2) : a2 = 0, f2 !== t2 + a2 && (i2.__u |= 65536))) : (o2 = u2[r2]) && null == o2.key && o2.__e && 0 == (131072 & o2.__u) && (o2.__e == n2.__d && (n2.__d = m$2(o2)), j$4(o2, o2, false), u2[r2] = null, s2--);
    if (s2)
      for (t2 = 0; t2 < c2; t2++)
        null != (o2 = u2[t2]) && 0 == (131072 & o2.__u) && (o2.__e == n2.__d && (n2.__d = m$2(o2)), j$4(o2, o2));
  }
  function S$3(n2, l2, u2) {
    var t2, i2;
    if ("function" == typeof n2.type) {
      for (t2 = n2.__k, i2 = 0; t2 && i2 < t2.length; i2++)
        t2[i2] && (t2[i2].__ = n2, l2 = S$3(t2[i2], l2, u2));
      return l2;
    }
    n2.__e != l2 && (u2.insertBefore(n2.__e, l2 || null), l2 = n2.__e);
    do {
      l2 = l2 && l2.nextSibling;
    } while (null != l2 && 8 === l2.nodeType);
    return l2;
  }
  function $$1(n2, l2) {
    return l2 = l2 || [], null == n2 || "boolean" == typeof n2 || (h$3(n2) ? n2.some(function(n3) {
      $$1(n3, l2);
    }) : l2.push(n2)), l2;
  }
  function I$2(n2, l2, u2, t2) {
    var i2 = n2.key, o2 = n2.type, r2 = u2 - 1, f2 = u2 + 1, e2 = l2[u2];
    if (null === e2 || e2 && i2 == e2.key && o2 === e2.type && 0 == (131072 & e2.__u))
      return u2;
    if (t2 > (null != e2 && 0 == (131072 & e2.__u) ? 1 : 0))
      for (; r2 >= 0 || f2 < l2.length; ) {
        if (r2 >= 0) {
          if ((e2 = l2[r2]) && 0 == (131072 & e2.__u) && i2 == e2.key && o2 === e2.type)
            return r2;
          r2--;
        }
        if (f2 < l2.length) {
          if ((e2 = l2[f2]) && 0 == (131072 & e2.__u) && i2 == e2.key && o2 === e2.type)
            return f2;
          f2++;
        }
      }
    return -1;
  }
  function H$2(n2, l2, u2) {
    "-" === l2[0] ? n2.setProperty(l2, null == u2 ? "" : u2) : n2[l2] = null == u2 ? "" : "number" != typeof u2 || a$3.test(l2) ? u2 : u2 + "px";
  }
  function T$1(n2, l2, u2, t2, i2) {
    var o2;
    n:
      if ("style" === l2)
        if ("string" == typeof u2)
          n2.style.cssText = u2;
        else {
          if ("string" == typeof t2 && (n2.style.cssText = t2 = ""), t2)
            for (l2 in t2)
              u2 && l2 in u2 || H$2(n2.style, l2, "");
          if (u2)
            for (l2 in u2)
              t2 && u2[l2] === t2[l2] || H$2(n2.style, l2, u2[l2]);
        }
      else if ("o" === l2[0] && "n" === l2[1])
        o2 = l2 !== (l2 = l2.replace(/(PointerCapture)$|Capture$/i, "$1")), l2 = l2.toLowerCase() in n2 || "onFocusOut" === l2 || "onFocusIn" === l2 ? l2.toLowerCase().slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + o2] = u2, u2 ? t2 ? u2.u = t2.u : (u2.u = Date.now(), n2.addEventListener(l2, o2 ? D$3 : A$3, o2)) : n2.removeEventListener(l2, o2 ? D$3 : A$3, o2);
      else {
        if (i2)
          l2 = l2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if ("width" !== l2 && "height" !== l2 && "href" !== l2 && "list" !== l2 && "form" !== l2 && "tabIndex" !== l2 && "download" !== l2 && "rowSpan" !== l2 && "colSpan" !== l2 && "role" !== l2 && l2 in n2)
          try {
            n2[l2] = null == u2 ? "" : u2;
            break n;
          } catch (n3) {
          }
        "function" == typeof u2 || (null == u2 || false === u2 && "-" !== l2[4] ? n2.removeAttribute(l2) : n2.setAttribute(l2, u2));
      }
  }
  function A$3(n2) {
    if (this.l) {
      var u2 = this.l[n2.type + false];
      if (n2.t) {
        if (n2.t <= u2.u)
          return;
      } else
        n2.t = Date.now();
      return u2(l$3.event ? l$3.event(n2) : n2);
    }
  }
  function D$3(n2) {
    if (this.l)
      return this.l[n2.type + true](l$3.event ? l$3.event(n2) : n2);
  }
  function F$3(n2, u2, t2, i2, o2, r2, f2, e2, c2, s2) {
    var a2, p2, y2, d2, _2, m2, w2, k2, x2, P2, S2, $2, I2, H2, T2, A2 = u2.type;
    if (void 0 !== u2.constructor)
      return null;
    128 & t2.__u && (c2 = !!(32 & t2.__u), r2 = [e2 = u2.__e = t2.__e]), (a2 = l$3.__b) && a2(u2);
    n:
      if ("function" == typeof A2)
        try {
          if (k2 = u2.props, x2 = (a2 = A2.contextType) && i2[a2.__c], P2 = a2 ? x2 ? x2.props.value : a2.__ : i2, t2.__c ? w2 = (p2 = u2.__c = t2.__c).__ = p2.__E : ("prototype" in A2 && A2.prototype.render ? u2.__c = p2 = new A2(k2, P2) : (u2.__c = p2 = new b$2(k2, P2), p2.constructor = A2, p2.render = z$3), x2 && x2.sub(p2), p2.props = k2, p2.state || (p2.state = {}), p2.context = P2, p2.__n = i2, y2 = p2.__d = true, p2.__h = [], p2._sb = []), null == p2.__s && (p2.__s = p2.state), null != A2.getDerivedStateFromProps && (p2.__s == p2.state && (p2.__s = v$3({}, p2.__s)), v$3(p2.__s, A2.getDerivedStateFromProps(k2, p2.__s))), d2 = p2.props, _2 = p2.state, p2.__v = u2, y2)
            null == A2.getDerivedStateFromProps && null != p2.componentWillMount && p2.componentWillMount(), null != p2.componentDidMount && p2.__h.push(p2.componentDidMount);
          else {
            if (null == A2.getDerivedStateFromProps && k2 !== d2 && null != p2.componentWillReceiveProps && p2.componentWillReceiveProps(k2, P2), !p2.__e && (null != p2.shouldComponentUpdate && false === p2.shouldComponentUpdate(k2, p2.__s, P2) || u2.__v === t2.__v)) {
              for (u2.__v !== t2.__v && (p2.props = k2, p2.state = p2.__s, p2.__d = false), u2.__e = t2.__e, u2.__k = t2.__k, u2.__k.forEach(function(n3) {
                n3 && (n3.__ = u2);
              }), S2 = 0; S2 < p2._sb.length; S2++)
                p2.__h.push(p2._sb[S2]);
              p2._sb = [], p2.__h.length && f2.push(p2);
              break n;
            }
            null != p2.componentWillUpdate && p2.componentWillUpdate(k2, p2.__s, P2), null != p2.componentDidUpdate && p2.__h.push(function() {
              p2.componentDidUpdate(d2, _2, m2);
            });
          }
          if (p2.context = P2, p2.props = k2, p2.__P = n2, p2.__e = false, $2 = l$3.__r, I2 = 0, "prototype" in A2 && A2.prototype.render) {
            for (p2.state = p2.__s, p2.__d = false, $2 && $2(u2), a2 = p2.render(p2.props, p2.state, p2.context), H2 = 0; H2 < p2._sb.length; H2++)
              p2.__h.push(p2._sb[H2]);
            p2._sb = [];
          } else
            do {
              p2.__d = false, $2 && $2(u2), a2 = p2.render(p2.props, p2.state, p2.context), p2.state = p2.__s;
            } while (p2.__d && ++I2 < 25);
          p2.state = p2.__s, null != p2.getChildContext && (i2 = v$3(v$3({}, i2), p2.getChildContext())), y2 || null == p2.getSnapshotBeforeUpdate || (m2 = p2.getSnapshotBeforeUpdate(d2, _2)), C$3(n2, h$3(T2 = null != a2 && a2.type === g$2 && null == a2.key ? a2.props.children : a2) ? T2 : [T2], u2, t2, i2, o2, r2, f2, e2, c2, s2), p2.base = u2.__e, u2.__u &= -161, p2.__h.length && f2.push(p2), w2 && (p2.__E = p2.__ = null);
        } catch (n3) {
          u2.__v = null, c2 || null != r2 ? (u2.__e = e2, u2.__u |= c2 ? 160 : 32, r2[r2.indexOf(e2)] = null) : (u2.__e = t2.__e, u2.__k = t2.__k), l$3.__e(n3, u2, t2);
        }
      else
        null == r2 && u2.__v === t2.__v ? (u2.__k = t2.__k, u2.__e = t2.__e) : u2.__e = M$2(t2.__e, u2, t2, i2, o2, r2, f2, c2, s2);
    (a2 = l$3.diffed) && a2(u2);
  }
  function L$2(n2, u2, t2) {
    u2.__d = void 0;
    for (var i2 = 0; i2 < t2.length; i2++)
      O$3(t2[i2], t2[++i2], t2[++i2]);
    l$3.__c && l$3.__c(u2, n2), n2.some(function(u3) {
      try {
        n2 = u3.__h, u3.__h = [], n2.some(function(n3) {
          n3.call(u3);
        });
      } catch (n3) {
        l$3.__e(n3, u3.__v);
      }
    });
  }
  function M$2(l2, u2, t2, i2, o2, r2, f2, e2, s2) {
    var a2, v2, y2, d2, _2, g2, b2, w2 = t2.props, k2 = u2.props, x2 = u2.type;
    if ("svg" === x2 && (o2 = true), null != r2) {
      for (a2 = 0; a2 < r2.length; a2++)
        if ((_2 = r2[a2]) && "setAttribute" in _2 == !!x2 && (x2 ? _2.localName === x2 : 3 === _2.nodeType)) {
          l2 = _2, r2[a2] = null;
          break;
        }
    }
    if (null == l2) {
      if (null === x2)
        return document.createTextNode(k2);
      l2 = o2 ? document.createElementNS("http://www.w3.org/2000/svg", x2) : document.createElement(x2, k2.is && k2), r2 = null, e2 = false;
    }
    if (null === x2)
      w2 === k2 || e2 && l2.data === k2 || (l2.data = k2);
    else {
      if (r2 = r2 && n$2.call(l2.childNodes), w2 = t2.props || c$3, !e2 && null != r2)
        for (w2 = {}, a2 = 0; a2 < l2.attributes.length; a2++)
          w2[(_2 = l2.attributes[a2]).name] = _2.value;
      for (a2 in w2)
        _2 = w2[a2], "children" == a2 || ("dangerouslySetInnerHTML" == a2 ? y2 = _2 : "key" === a2 || a2 in k2 || T$1(l2, a2, null, _2, o2));
      for (a2 in k2)
        _2 = k2[a2], "children" == a2 ? d2 = _2 : "dangerouslySetInnerHTML" == a2 ? v2 = _2 : "value" == a2 ? g2 = _2 : "checked" == a2 ? b2 = _2 : "key" === a2 || e2 && "function" != typeof _2 || w2[a2] === _2 || T$1(l2, a2, _2, w2[a2], o2);
      if (v2)
        e2 || y2 && (v2.__html === y2.__html || v2.__html === l2.innerHTML) || (l2.innerHTML = v2.__html), u2.__k = [];
      else if (y2 && (l2.innerHTML = ""), C$3(l2, h$3(d2) ? d2 : [d2], u2, t2, i2, o2 && "foreignObject" !== x2, r2, f2, r2 ? r2[0] : t2.__k && m$2(t2, 0), e2, s2), null != r2)
        for (a2 = r2.length; a2--; )
          null != r2[a2] && p$3(r2[a2]);
      e2 || (a2 = "value", void 0 !== g2 && (g2 !== l2[a2] || "progress" === x2 && !g2 || "option" === x2 && g2 !== w2[a2]) && T$1(l2, a2, g2, w2[a2], false), a2 = "checked", void 0 !== b2 && b2 !== l2[a2] && T$1(l2, a2, b2, w2[a2], false));
    }
    return l2;
  }
  function O$3(n2, u2, t2) {
    try {
      "function" == typeof n2 ? n2(u2) : n2.current = u2;
    } catch (n3) {
      l$3.__e(n3, t2);
    }
  }
  function j$4(n2, u2, t2) {
    var i2, o2;
    if (l$3.unmount && l$3.unmount(n2), (i2 = n2.ref) && (i2.current && i2.current !== n2.__e || O$3(i2, null, u2)), null != (i2 = n2.__c)) {
      if (i2.componentWillUnmount)
        try {
          i2.componentWillUnmount();
        } catch (n3) {
          l$3.__e(n3, u2);
        }
      i2.base = i2.__P = null, n2.__c = void 0;
    }
    if (i2 = n2.__k)
      for (o2 = 0; o2 < i2.length; o2++)
        i2[o2] && j$4(i2[o2], u2, t2 || "function" != typeof n2.type);
    t2 || null == n2.__e || p$3(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
  }
  function z$3(n2, l2, u2) {
    return this.constructor(n2, u2);
  }
  function N$2(u2, t2, i2) {
    var o2, r2, f2, e2;
    l$3.__ && l$3.__(u2, t2), r2 = (o2 = "function" == typeof i2) ? null : i2 && i2.__k || t2.__k, f2 = [], e2 = [], F$3(t2, u2 = (!o2 && i2 || t2).__k = y$3(g$2, null, [u2]), r2 || c$3, c$3, void 0 !== t2.ownerSVGElement, !o2 && i2 ? [i2] : r2 ? null : t2.firstChild ? n$2.call(t2.childNodes) : null, f2, !o2 && i2 ? i2 : r2 ? r2.__e : t2.firstChild, o2, e2), L$2(f2, u2, e2);
  }
  function B$3(l2, u2, t2) {
    var i2, o2, r2, f2, e2 = v$3({}, l2.props);
    for (r2 in l2.type && l2.type.defaultProps && (f2 = l2.type.defaultProps), u2)
      "key" == r2 ? i2 = u2[r2] : "ref" == r2 ? o2 = u2[r2] : e2[r2] = void 0 === u2[r2] && void 0 !== f2 ? f2[r2] : u2[r2];
    return arguments.length > 2 && (e2.children = arguments.length > 3 ? n$2.call(arguments, 2) : t2), d$3(l2.type, e2, i2 || l2.key, o2 || l2.ref, null);
  }
  function E$2(n2, l2) {
    var u2 = { __c: l2 = "__cC" + e$1++, __: n2, Consumer: function(n3, l3) {
      return n3.children(l3);
    }, Provider: function(n3) {
      var u3, t2;
      return this.getChildContext || (u3 = [], (t2 = {})[l2] = this, this.getChildContext = function() {
        return t2;
      }, this.shouldComponentUpdate = function(n4) {
        this.props.value !== n4.value && u3.some(function(n5) {
          n5.__e = true, k$3(n5);
        });
      }, this.sub = function(n4) {
        u3.push(n4);
        var l3 = n4.componentWillUnmount;
        n4.componentWillUnmount = function() {
          u3.splice(u3.indexOf(n4), 1), l3 && l3.call(n4);
        };
      }), n3.children;
    } };
    return u2.Provider.__ = u2.Consumer.contextType = u2;
  }
  n$2 = s$3.slice, l$3 = { __e: function(n2, l2, u2, t2) {
    for (var i2, o2, r2; l2 = l2.__; )
      if ((i2 = l2.__c) && !i2.__)
        try {
          if ((o2 = i2.constructor) && null != o2.getDerivedStateFromError && (i2.setState(o2.getDerivedStateFromError(n2)), r2 = i2.__d), null != i2.componentDidCatch && (i2.componentDidCatch(n2, t2 || {}), r2 = i2.__d), r2)
            return i2.__E = i2;
        } catch (l3) {
          n2 = l3;
        }
    throw n2;
  } }, u$3 = 0, b$2.prototype.setState = function(n2, l2) {
    var u2;
    u2 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v$3({}, this.state), "function" == typeof n2 && (n2 = n2(v$3({}, u2), this.props)), n2 && v$3(u2, n2), null != n2 && this.__v && (l2 && this._sb.push(l2), k$3(this));
  }, b$2.prototype.forceUpdate = function(n2) {
    this.__v && (this.__e = true, n2 && this.__h.push(n2), k$3(this));
  }, b$2.prototype.render = g$2, i$3 = [], r$2 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f$3 = function(n2, l2) {
    return n2.__v.__b - l2.__v.__b;
  }, x$4.__r = 0, e$1 = 0;
  var t$1, r$1, u$2, i$2, o$2 = 0, f$2 = [], c$2 = [], e = l$3, a$2 = e.__b, v$2 = e.__r, l$2 = e.diffed, m$1 = e.__c, s$2 = e.unmount, d$2 = e.__;
  function h$2(n2, t2) {
    e.__h && e.__h(r$1, n2, o$2 || t2), o$2 = 0;
    var u2 = r$1.__H || (r$1.__H = { __: [], __h: [] });
    return n2 >= u2.__.length && u2.__.push({ __V: c$2 }), u2.__[n2];
  }
  function p$2(n2) {
    return o$2 = 1, y$2(D$2, n2);
  }
  function y$2(n2, u2, i2) {
    var o2 = h$2(t$1++, 2);
    if (o2.t = n2, !o2.__c && (o2.__ = [i2 ? i2(u2) : D$2(void 0, u2), function(n3) {
      var t2 = o2.__N ? o2.__N[0] : o2.__[0], r2 = o2.t(t2, n3);
      t2 !== r2 && (o2.__N = [r2, o2.__[1]], o2.__c.setState({}));
    }], o2.__c = r$1, !r$1.u)) {
      var f2 = function(n3, t2, r2) {
        if (!o2.__c.__H)
          return true;
        var u3 = o2.__c.__H.__.filter(function(n4) {
          return !!n4.__c;
        });
        if (u3.every(function(n4) {
          return !n4.__N;
        }))
          return !c2 || c2.call(this, n3, t2, r2);
        var i3 = false;
        return u3.forEach(function(n4) {
          if (n4.__N) {
            var t3 = n4.__[0];
            n4.__ = n4.__N, n4.__N = void 0, t3 !== n4.__[0] && (i3 = true);
          }
        }), !(!i3 && o2.__c.props === n3) && (!c2 || c2.call(this, n3, t2, r2));
      };
      r$1.u = true;
      var c2 = r$1.shouldComponentUpdate, e2 = r$1.componentWillUpdate;
      r$1.componentWillUpdate = function(n3, t2, r2) {
        if (this.__e) {
          var u3 = c2;
          c2 = void 0, f2(n3, t2, r2), c2 = u3;
        }
        e2 && e2.call(this, n3, t2, r2);
      }, r$1.shouldComponentUpdate = f2;
    }
    return o2.__N || o2.__;
  }
  function _$2(n2, u2) {
    var i2 = h$2(t$1++, 3);
    !e.__s && C$2(i2.__H, u2) && (i2.__ = n2, i2.i = u2, r$1.__H.__h.push(i2));
  }
  function A$2(n2, u2) {
    var i2 = h$2(t$1++, 4);
    !e.__s && C$2(i2.__H, u2) && (i2.__ = n2, i2.i = u2, r$1.__h.push(i2));
  }
  function F$2(n2) {
    return o$2 = 5, q$1(function() {
      return { current: n2 };
    }, []);
  }
  function q$1(n2, r2) {
    var u2 = h$2(t$1++, 7);
    return C$2(u2.__H, r2) ? (u2.__V = n2(), u2.i = r2, u2.__h = n2, u2.__V) : u2.__;
  }
  function x$3(n2, t2) {
    return o$2 = 8, q$1(function() {
      return n2;
    }, t2);
  }
  function P$2(n2) {
    var u2 = r$1.context[n2.__c], i2 = h$2(t$1++, 9);
    return i2.c = n2, u2 ? (null == i2.__ && (i2.__ = true, u2.sub(r$1)), u2.props.value) : n2.__;
  }
  function j$3() {
    for (var n2; n2 = f$2.shift(); )
      if (n2.__P && n2.__H)
        try {
          n2.__H.__h.forEach(z$2), n2.__H.__h.forEach(B$2), n2.__H.__h = [];
        } catch (t2) {
          n2.__H.__h = [], e.__e(t2, n2.__v);
        }
  }
  e.__b = function(n2) {
    r$1 = null, a$2 && a$2(n2);
  }, e.__ = function(n2, t2) {
    n2 && t2.__k && t2.__k.__m && (n2.__m = t2.__k.__m), d$2 && d$2(n2, t2);
  }, e.__r = function(n2) {
    v$2 && v$2(n2), t$1 = 0;
    var i2 = (r$1 = n2.__c).__H;
    i2 && (u$2 === r$1 ? (i2.__h = [], r$1.__h = [], i2.__.forEach(function(n3) {
      n3.__N && (n3.__ = n3.__N), n3.__V = c$2, n3.__N = n3.i = void 0;
    })) : (i2.__h.forEach(z$2), i2.__h.forEach(B$2), i2.__h = [], t$1 = 0)), u$2 = r$1;
  }, e.diffed = function(n2) {
    l$2 && l$2(n2);
    var t2 = n2.__c;
    t2 && t2.__H && (t2.__H.__h.length && (1 !== f$2.push(t2) && i$2 === e.requestAnimationFrame || ((i$2 = e.requestAnimationFrame) || w$3)(j$3)), t2.__H.__.forEach(function(n3) {
      n3.i && (n3.__H = n3.i), n3.__V !== c$2 && (n3.__ = n3.__V), n3.i = void 0, n3.__V = c$2;
    })), u$2 = r$1 = null;
  }, e.__c = function(n2, t2) {
    t2.some(function(n3) {
      try {
        n3.__h.forEach(z$2), n3.__h = n3.__h.filter(function(n4) {
          return !n4.__ || B$2(n4);
        });
      } catch (r2) {
        t2.some(function(n4) {
          n4.__h && (n4.__h = []);
        }), t2 = [], e.__e(r2, n3.__v);
      }
    }), m$1 && m$1(n2, t2);
  }, e.unmount = function(n2) {
    s$2 && s$2(n2);
    var t2, r2 = n2.__c;
    r2 && r2.__H && (r2.__H.__.forEach(function(n3) {
      try {
        z$2(n3);
      } catch (n4) {
        t2 = n4;
      }
    }), r2.__H = void 0, t2 && e.__e(t2, r2.__v));
  };
  var k$2 = "function" == typeof requestAnimationFrame;
  function w$3(n2) {
    var t2, r2 = function() {
      clearTimeout(u2), k$2 && cancelAnimationFrame(t2), setTimeout(n2);
    }, u2 = setTimeout(r2, 100);
    k$2 && (t2 = requestAnimationFrame(r2));
  }
  function z$2(n2) {
    var t2 = r$1, u2 = n2.__c;
    "function" == typeof u2 && (n2.__c = void 0, u2()), r$1 = t2;
  }
  function B$2(n2) {
    var t2 = r$1;
    n2.__c = n2.__(), r$1 = t2;
  }
  function C$2(n2, t2) {
    return !n2 || n2.length !== t2.length || t2.some(function(t3, r2) {
      return t3 !== n2[r2];
    });
  }
  function D$2(n2, t2) {
    return "function" == typeof t2 ? t2(n2) : t2;
  }
  function n$1(n2) {
    for (var r2 = arguments.length, t2 = Array(r2 > 1 ? r2 - 1 : 0), e2 = 1; e2 < r2; e2++)
      t2[e2 - 1] = arguments[e2];
    throw Error("[Immer] minified error nr: " + n2 + (t2.length ? " " + t2.map(function(n3) {
      return "'" + n3 + "'";
    }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
  }
  function r(n2) {
    return !!n2 && !!n2[Q$1];
  }
  function t(n2) {
    var r2;
    return !!n2 && (function(n3) {
      if (!n3 || "object" != typeof n3)
        return false;
      var r3 = Object.getPrototypeOf(n3);
      if (null === r3)
        return true;
      var t2 = Object.hasOwnProperty.call(r3, "constructor") && r3.constructor;
      return t2 === Object || "function" == typeof t2 && Function.toString.call(t2) === Z$1;
    }(n2) || Array.isArray(n2) || !!n2[L$1] || !!(null === (r2 = n2.constructor) || void 0 === r2 ? void 0 : r2[L$1]) || s$1(n2) || v$1(n2));
  }
  function i$1(n2, r2, t2) {
    void 0 === t2 && (t2 = false), 0 === o$1(n2) ? (t2 ? Object.keys : nn)(n2).forEach(function(e2) {
      t2 && "symbol" == typeof e2 || r2(e2, n2[e2], n2);
    }) : n2.forEach(function(t3, e2) {
      return r2(e2, t3, n2);
    });
  }
  function o$1(n2) {
    var r2 = n2[Q$1];
    return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s$1(n2) ? 2 : v$1(n2) ? 3 : 0;
  }
  function u$1(n2, r2) {
    return 2 === o$1(n2) ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
  }
  function a$1(n2, r2) {
    return 2 === o$1(n2) ? n2.get(r2) : n2[r2];
  }
  function f$1(n2, r2, t2) {
    var e2 = o$1(n2);
    2 === e2 ? n2.set(r2, t2) : 3 === e2 ? n2.add(t2) : n2[r2] = t2;
  }
  function c$1(n2, r2) {
    return n2 === r2 ? 0 !== n2 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
  }
  function s$1(n2) {
    return X$1 && n2 instanceof Map;
  }
  function v$1(n2) {
    return q && n2 instanceof Set;
  }
  function p$1(n2) {
    return n2.o || n2.t;
  }
  function l$1(n2) {
    if (Array.isArray(n2))
      return Array.prototype.slice.call(n2);
    var r2 = rn$1(n2);
    delete r2[Q$1];
    for (var t2 = nn(r2), e2 = 0; e2 < t2.length; e2++) {
      var i2 = t2[e2], o2 = r2[i2];
      false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
    }
    return Object.create(Object.getPrototypeOf(n2), r2);
  }
  function d$1(n2, e2) {
    return void 0 === e2 && (e2 = false), y$1(n2) || r(n2) || !t(n2) || (o$1(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h$1), Object.freeze(n2), e2 && i$1(n2, function(n3, r2) {
      return d$1(r2, true);
    }, true)), n2;
  }
  function h$1() {
    n$1(2);
  }
  function y$1(n2) {
    return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
  }
  function b$1(r2) {
    var t2 = tn$1[r2];
    return t2 || n$1(18, r2), t2;
  }
  function _$1() {
    return U;
  }
  function j$2(n2, r2) {
    r2 && (b$1("Patches"), n2.u = [], n2.s = [], n2.v = r2);
  }
  function g$1(n2) {
    O$2(n2), n2.p.forEach(S$2), n2.p = null;
  }
  function O$2(n2) {
    n2 === U && (U = n2.l);
  }
  function w$2(n2) {
    return U = { p: [], l: U, h: n2, m: true, _: 0 };
  }
  function S$2(n2) {
    var r2 = n2[Q$1];
    0 === r2.i || 1 === r2.i ? r2.j() : r2.g = true;
  }
  function P$1(r2, e2) {
    e2._ = e2.p.length;
    var i2 = e2.p[0], o2 = void 0 !== r2 && r2 !== i2;
    return e2.h.O || b$1("ES5").S(e2, r2, o2), o2 ? (i2[Q$1].P && (g$1(e2), n$1(4)), t(r2) && (r2 = M$1(e2, r2), e2.l || x$2(e2, r2)), e2.u && b$1("Patches").M(i2[Q$1].t, r2, e2.u, e2.s)) : r2 = M$1(e2, i2, []), g$1(e2), e2.u && e2.v(e2.u, e2.s), r2 !== H$1 ? r2 : void 0;
  }
  function M$1(n2, r2, t2) {
    if (y$1(r2))
      return r2;
    var e2 = r2[Q$1];
    if (!e2)
      return i$1(r2, function(i2, o3) {
        return A$1(n2, e2, r2, i2, o3, t2);
      }, true), r2;
    if (e2.A !== n2)
      return r2;
    if (!e2.P)
      return x$2(n2, e2.t, true), e2.t;
    if (!e2.I) {
      e2.I = true, e2.A._--;
      var o2 = 4 === e2.i || 5 === e2.i ? e2.o = l$1(e2.k) : e2.o, u2 = o2, a2 = false;
      3 === e2.i && (u2 = new Set(o2), o2.clear(), a2 = true), i$1(u2, function(r3, i2) {
        return A$1(n2, e2, o2, r3, i2, t2, a2);
      }), x$2(n2, o2, false), t2 && n2.u && b$1("Patches").N(e2, t2, n2.u, n2.s);
    }
    return e2.o;
  }
  function A$1(e2, i2, o2, a2, c2, s2, v2) {
    if (r(c2)) {
      var p2 = M$1(e2, c2, s2 && i2 && 3 !== i2.i && !u$1(i2.R, a2) ? s2.concat(a2) : void 0);
      if (f$1(o2, a2, p2), !r(p2))
        return;
      e2.m = false;
    } else
      v2 && o2.add(c2);
    if (t(c2) && !y$1(c2)) {
      if (!e2.h.D && e2._ < 1)
        return;
      M$1(e2, c2), i2 && i2.A.l || x$2(e2, c2);
    }
  }
  function x$2(n2, r2, t2) {
    void 0 === t2 && (t2 = false), !n2.l && n2.h.D && n2.m && d$1(r2, t2);
  }
  function z$1(n2, r2) {
    var t2 = n2[Q$1];
    return (t2 ? p$1(t2) : n2)[r2];
  }
  function I$1(n2, r2) {
    if (r2 in n2)
      for (var t2 = Object.getPrototypeOf(n2); t2; ) {
        var e2 = Object.getOwnPropertyDescriptor(t2, r2);
        if (e2)
          return e2;
        t2 = Object.getPrototypeOf(t2);
      }
  }
  function k$1(n2) {
    n2.P || (n2.P = true, n2.l && k$1(n2.l));
  }
  function E$1(n2) {
    n2.o || (n2.o = l$1(n2.t));
  }
  function N$1(n2, r2, t2) {
    var e2 = s$1(r2) ? b$1("MapSet").F(r2, t2) : v$1(r2) ? b$1("MapSet").T(r2, t2) : n2.O ? function(n3, r3) {
      var t3 = Array.isArray(n3), e3 = { i: t3 ? 1 : 0, A: r3 ? r3.A : _$1(), P: false, I: false, R: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e3, o2 = en$1;
      t3 && (i2 = [e3], o2 = on);
      var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
      return e3.k = f2, e3.j = a2, f2;
    }(r2, t2) : b$1("ES5").J(r2, t2);
    return (t2 ? t2.A : _$1()).p.push(e2), e2;
  }
  function R$1(e2) {
    return r(e2) || n$1(22, e2), function n2(r2) {
      if (!t(r2))
        return r2;
      var e3, u2 = r2[Q$1], c2 = o$1(r2);
      if (u2) {
        if (!u2.P && (u2.i < 4 || !b$1("ES5").K(u2)))
          return u2.t;
        u2.I = true, e3 = D$1(r2, c2), u2.I = false;
      } else
        e3 = D$1(r2, c2);
      return i$1(e3, function(r3, t2) {
        u2 && a$1(u2.t, r3) === t2 || f$1(e3, r3, n2(t2));
      }), 3 === c2 ? new Set(e3) : e3;
    }(e2);
  }
  function D$1(n2, r2) {
    switch (r2) {
      case 2:
        return new Map(n2);
      case 3:
        return Array.from(n2);
    }
    return l$1(n2);
  }
  var G, U, W$1 = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), X$1 = "undefined" != typeof Map, q = "undefined" != typeof Set, B$1 = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, H$1 = W$1 ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G), L$1 = W$1 ? Symbol.for("immer-draftable") : "__$immer_draftable", Q$1 = W$1 ? Symbol.for("immer-state") : "__$immer_state", Z$1 = "" + Object.prototype.constructor, nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
    return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
  } : Object.getOwnPropertyNames, rn$1 = Object.getOwnPropertyDescriptors || function(n2) {
    var r2 = {};
    return nn(n2).forEach(function(t2) {
      r2[t2] = Object.getOwnPropertyDescriptor(n2, t2);
    }), r2;
  }, tn$1 = {}, en$1 = { get: function(n2, r2) {
    if (r2 === Q$1)
      return n2;
    var e2 = p$1(n2);
    if (!u$1(e2, r2))
      return function(n3, r3, t2) {
        var e3, i3 = I$1(r3, t2);
        return i3 ? "value" in i3 ? i3.value : null === (e3 = i3.get) || void 0 === e3 ? void 0 : e3.call(n3.k) : void 0;
      }(n2, e2, r2);
    var i2 = e2[r2];
    return n2.I || !t(i2) ? i2 : i2 === z$1(n2.t, r2) ? (E$1(n2), n2.o[r2] = N$1(n2.A.h, i2, n2)) : i2;
  }, has: function(n2, r2) {
    return r2 in p$1(n2);
  }, ownKeys: function(n2) {
    return Reflect.ownKeys(p$1(n2));
  }, set: function(n2, r2, t2) {
    var e2 = I$1(p$1(n2), r2);
    if (null == e2 ? void 0 : e2.set)
      return e2.set.call(n2.k, t2), true;
    if (!n2.P) {
      var i2 = z$1(p$1(n2), r2), o2 = null == i2 ? void 0 : i2[Q$1];
      if (o2 && o2.t === t2)
        return n2.o[r2] = t2, n2.R[r2] = false, true;
      if (c$1(t2, i2) && (void 0 !== t2 || u$1(n2.t, r2)))
        return true;
      E$1(n2), k$1(n2);
    }
    return n2.o[r2] === t2 && (void 0 !== t2 || r2 in n2.o) || Number.isNaN(t2) && Number.isNaN(n2.o[r2]) || (n2.o[r2] = t2, n2.R[r2] = true), true;
  }, deleteProperty: function(n2, r2) {
    return void 0 !== z$1(n2.t, r2) || r2 in n2.t ? (n2.R[r2] = false, E$1(n2), k$1(n2)) : delete n2.R[r2], n2.o && delete n2.o[r2], true;
  }, getOwnPropertyDescriptor: function(n2, r2) {
    var t2 = p$1(n2), e2 = Reflect.getOwnPropertyDescriptor(t2, r2);
    return e2 ? { writable: true, configurable: 1 !== n2.i || "length" !== r2, enumerable: e2.enumerable, value: t2[r2] } : e2;
  }, defineProperty: function() {
    n$1(11);
  }, getPrototypeOf: function(n2) {
    return Object.getPrototypeOf(n2.t);
  }, setPrototypeOf: function() {
    n$1(12);
  } }, on = {};
  i$1(en$1, function(n2, r2) {
    on[n2] = function() {
      return arguments[0] = arguments[0][0], r2.apply(this, arguments);
    };
  }), on.deleteProperty = function(r2, t2) {
    return on.set.call(this, r2, t2, void 0);
  }, on.set = function(r2, t2, e2) {
    return en$1.set.call(this, r2[0], t2, e2, r2[0]);
  };
  var un$1 = function() {
    function e2(r2) {
      var e3 = this;
      this.O = B$1, this.D = true, this.produce = function(r3, i3, o2) {
        if ("function" == typeof r3 && "function" != typeof i3) {
          var u2 = i3;
          i3 = r3;
          var a2 = e3;
          return function(n2) {
            var r4 = this;
            void 0 === n2 && (n2 = u2);
            for (var t2 = arguments.length, e4 = Array(t2 > 1 ? t2 - 1 : 0), o3 = 1; o3 < t2; o3++)
              e4[o3 - 1] = arguments[o3];
            return a2.produce(n2, function(n3) {
              var t3;
              return (t3 = i3).call.apply(t3, [r4, n3].concat(e4));
            });
          };
        }
        var f2;
        if ("function" != typeof i3 && n$1(6), void 0 !== o2 && "function" != typeof o2 && n$1(7), t(r3)) {
          var c2 = w$2(e3), s2 = N$1(e3, r3, void 0), v2 = true;
          try {
            f2 = i3(s2), v2 = false;
          } finally {
            v2 ? g$1(c2) : O$2(c2);
          }
          return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then(function(n2) {
            return j$2(c2, o2), P$1(n2, c2);
          }, function(n2) {
            throw g$1(c2), n2;
          }) : (j$2(c2, o2), P$1(f2, c2));
        }
        if (!r3 || "object" != typeof r3) {
          if (void 0 === (f2 = i3(r3)) && (f2 = r3), f2 === H$1 && (f2 = void 0), e3.D && d$1(f2, true), o2) {
            var p2 = [], l2 = [];
            b$1("Patches").M(r3, f2, p2, l2), o2(p2, l2);
          }
          return f2;
        }
        n$1(21, r3);
      }, this.produceWithPatches = function(n2, r3) {
        if ("function" == typeof n2)
          return function(r4) {
            for (var t3 = arguments.length, i4 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++)
              i4[o3 - 1] = arguments[o3];
            return e3.produceWithPatches(r4, function(r5) {
              return n2.apply(void 0, [r5].concat(i4));
            });
          };
        var t2, i3, o2 = e3.produce(n2, r3, function(n3, r4) {
          t2 = n3, i3 = r4;
        });
        return "undefined" != typeof Promise && o2 instanceof Promise ? o2.then(function(n3) {
          return [n3, t2, i3];
        }) : [o2, t2, i3];
      }, "boolean" == typeof (null == r2 ? void 0 : r2.useProxies) && this.setUseProxies(r2.useProxies), "boolean" == typeof (null == r2 ? void 0 : r2.autoFreeze) && this.setAutoFreeze(r2.autoFreeze);
    }
    var i2 = e2.prototype;
    return i2.createDraft = function(e3) {
      t(e3) || n$1(8), r(e3) && (e3 = R$1(e3));
      var i3 = w$2(this), o2 = N$1(this, e3, void 0);
      return o2[Q$1].C = true, O$2(i3), o2;
    }, i2.finishDraft = function(r2, t2) {
      var e3 = r2 && r2[Q$1];
      var i3 = e3.A;
      return j$2(i3, t2), P$1(void 0, i3);
    }, i2.setAutoFreeze = function(n2) {
      this.D = n2;
    }, i2.setUseProxies = function(r2) {
      r2 && !B$1 && n$1(20), this.O = r2;
    }, i2.applyPatches = function(n2, t2) {
      var e3;
      for (e3 = t2.length - 1; e3 >= 0; e3--) {
        var i3 = t2[e3];
        if (0 === i3.path.length && "replace" === i3.op) {
          n2 = i3.value;
          break;
        }
      }
      e3 > -1 && (t2 = t2.slice(e3 + 1));
      var o2 = b$1("Patches").$;
      return r(n2) ? o2(n2, t2) : this.produce(n2, function(n3) {
        return o2(n3, t2);
      });
    }, e2;
  }(), an = new un$1(), fn = an.produce;
  an.produceWithPatches.bind(an);
  an.setAutoFreeze.bind(an);
  an.setUseProxies.bind(an);
  an.applyPatches.bind(an);
  an.createDraft.bind(an);
  an.finishDraft.bind(an);
  var produce = fn;
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function isUndefined$3(obj) {
    return obj === void 0;
  }
  var isUndefined_1 = isUndefined$3;
  var isUndefined$2 = isUndefined_1;
  function range(start, stop, step) {
    var arr = [];
    var flag;
    if (isUndefined$2(stop)) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;
    flag = step < 0 ? -1 : 1;
    stop *= flag;
    for (; start * flag < stop; start += step) {
      arr.push(start);
    }
    return arr;
  }
  var range_1 = range;
  const DEFAULT_DAY_NAME_MARGIN_LEFT = "0";
  const MONTH_EVENT_HEIGHT = 24;
  const MONTH_EVENT_MARGIN_TOP = 2;
  const MONTH_CELL_PADDING_TOP = 3;
  const MONTH_CELL_BAR_HEIGHT = 27;
  const MONTH_MORE_VIEW_PADDING = 5;
  const MONTH_MORE_VIEW_MIN_WIDTH = 280;
  const MONTH_MORE_VIEW_HEADER_HEIGHT = 44;
  const MONTH_MORE_VIEW_HEADER_MARGIN_BOTTOM = 12;
  const MONTH_MORE_VIEW_HEADER_PADDING_TOP = 12;
  const MONTH_MORE_VIEW_HEADER_PADDING = "12px 17px 0";
  const WEEK_DAY_NAME_HEIGHT = 42;
  const WEEK_DAY_NAME_BORDER = 1;
  const WEEK_EVENT_MARGIN_TOP = 2;
  const DEFAULT_PANEL_HEIGHT = 72;
  const DEFAULT_EVENT_COLORS = {
    color: "#000",
    backgroundColor: "#a1b56c",
    dragBackgroundColor: "#a1b56c",
    borderColor: "#000"
  };
  const TIME_EVENT_CONTAINER_MARGIN_LEFT = 2;
  const COLLAPSED_DUPLICATE_EVENT_WIDTH_PX = 9;
  function isBoolean(obj) {
    return typeof obj === "boolean" || obj instanceof Boolean;
  }
  var isBoolean_1 = isBoolean;
  function isNumber(obj) {
    return typeof obj === "number" || obj instanceof Number;
  }
  var isNumber_1 = isNumber;
  function isObject$1(obj) {
    return obj === Object(obj);
  }
  var isObject_1 = isObject$1;
  function isString$1(obj) {
    return typeof obj === "string" || obj instanceof String;
  }
  var isString_1 = isString$1;
  function isNil(value) {
    return isUndefined_1(value) || value === null;
  }
  function isPresent(value) {
    return !isNil(value);
  }
  function isFunction$2(value) {
    return typeof value === "function";
  }
  const CSS_PREFIX = "toastui-calendar-";
  function cls(...args) {
    const result = [];
    args.forEach((arg) => {
      if (!arg) {
        return;
      }
      if (isString_1(arg)) {
        result.push(arg);
      } else {
        Object.keys(arg).forEach((className2) => {
          if (arg[className2]) {
            result.push(className2);
          }
        });
      }
    });
    return result.map((str) => `${CSS_PREFIX}${str}`).join(" ");
  }
  function toPercent(value) {
    return `${value}%`;
  }
  function toPx(value) {
    return `${value}px`;
  }
  function extractPercentPx(value) {
    const percentRegexp = /(\d+)%/;
    const percentResult = value.match(percentRegexp);
    const pxRegexp = /(-?)\s?(\d+)px/;
    const pxResult = value.match(pxRegexp);
    return {
      percent: percentResult ? parseInt(percentResult[1], 10) : 0,
      px: pxResult ? parseInt(`${pxResult[1]}${pxResult[2]}`, 10) : 0
    };
  }
  function getEventColors(uiModel, calendarColor) {
    const eventColors = uiModel.model.getColors();
    return Object.keys(DEFAULT_EVENT_COLORS).reduce((colors, _key) => {
      var _a, _b;
      const key = _key;
      colors[key] = (_b = (_a = eventColors[key]) != null ? _a : calendarColor[key]) != null ? _b : DEFAULT_EVENT_COLORS[key];
      return colors;
    }, {});
  }
  const rISO8601 = /^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\.)?([0-9]+)?([+-]\d\d(?::?\d\d)?|\s*Z)?$/;
  function throwNotSupported() {
    throw new Error("This operation is not supported.");
  }
  function getDateTime(dateString) {
    const match = rISO8601.exec(dateString);
    if (match) {
      const [, y2, M2, d2, h2, m2, s2, , ms, zoneInfo] = match;
      return {
        y: Number(y2),
        M: Number(M2) - 1,
        d: Number(d2),
        h: Number(h2),
        m: Number(m2),
        s: Number(s2),
        ms: Number(ms) || 0,
        zoneInfo
      };
    }
    return null;
  }
  function createFromDateString(dateString) {
    const info = getDateTime(dateString);
    if (info && !info.zoneInfo) {
      const { y: y2, M: M2, d: d2, h: h2, m: m2, s: s2, ms } = info;
      return new Date(y2, M2, d2, h2, m2, s2, ms);
    }
    return null;
  }
  class LocalDate {
    constructor(...args) {
      const [firstArg] = args;
      if (firstArg instanceof Date) {
        this.d = new Date(firstArg.getTime());
      } else if (isString_1(firstArg) && args.length === 1) {
        this.d = createFromDateString(firstArg);
      }
      if (!this.d) {
        this.d = new Date(...args);
      }
    }
    setTimezoneOffset() {
      throwNotSupported();
    }
    setTimezoneName() {
      throwNotSupported();
    }
    clone() {
      return new LocalDate(this.d);
    }
    toDate() {
      return new Date(this.d.getTime());
    }
    toString() {
      return this.d.toString();
    }
  }
  const getterMethods = [
    "getTime",
    "getTimezoneOffset",
    "getFullYear",
    "getMonth",
    "getDate",
    "getHours",
    "getMinutes",
    "getSeconds",
    "getMilliseconds",
    "getDay"
  ];
  const setterMethods = [
    "setTime",
    "setFullYear",
    "setMonth",
    "setDate",
    "setHours",
    "setMinutes",
    "setSeconds",
    "setMilliseconds"
  ];
  getterMethods.forEach((methodName) => {
    LocalDate.prototype[methodName] = function(...args) {
      return this.d[methodName](...args);
    };
  });
  setterMethods.forEach((methodName) => {
    LocalDate.prototype[methodName] = function(...args) {
      return this.d[methodName](...args);
    };
  });
  class UTCDate extends LocalDate {
    clone() {
      return new UTCDate(this.d);
    }
    getTimezoneOffset() {
      return 0;
    }
  }
  const getterProperties = [
    "FullYear",
    "Month",
    "Date",
    "Hours",
    "Minutes",
    "Seconds",
    "Milliseconds",
    "Day"
  ];
  const setterProperties = [
    "FullYear",
    "Month",
    "Date",
    "Hours",
    "Minutes",
    "Seconds",
    "Milliseconds"
  ];
  getterProperties.forEach((prop) => {
    const methodName = `get${prop}`;
    UTCDate.prototype[methodName] = function(...args) {
      return this.d[`getUTC${prop}`](...args);
    };
  });
  setterProperties.forEach((prop) => {
    const methodName = `set${prop}`;
    UTCDate.prototype[methodName] = function(...args) {
      return this.d[`setUTC${prop}`](...args);
    };
  });
  const INVALID_DATETIME_FORMAT = "Invalid DateTime Format";
  const INVALID_TIMEZONE_NAME = "Invalid IANA Timezone Name";
  const INVALID_VIEW_TYPE = "Invalid View Type";
  const MESSAGE_PREFIX = "@toast-ui/calendar: ";
  class InvalidTimezoneNameError extends Error {
    constructor(timezoneName) {
      super(`${MESSAGE_PREFIX}${INVALID_TIMEZONE_NAME} - ${timezoneName}`);
      this.name = "InvalidTimezoneNameError";
    }
  }
  class InvalidDateTimeFormatError extends Error {
    constructor(dateTimeString) {
      super(`${MESSAGE_PREFIX}${INVALID_DATETIME_FORMAT} - ${dateTimeString}`);
      this.name = "InvalidDateTimeFormatError";
    }
  }
  class InvalidViewTypeError extends Error {
    constructor(viewType) {
      super(`${MESSAGE_PREFIX}${INVALID_VIEW_TYPE} - ${viewType}`);
      this.name = "InvalidViewTypeError";
    }
  }
  const logger = {
    error: (firstArg, ...restArgs) => {
      console.error(`${MESSAGE_PREFIX}${firstArg}`, ...restArgs);
    },
    warn: (firstArg, ...restArgs) => {
      console.warn(`${MESSAGE_PREFIX}${firstArg}`, ...restArgs);
    }
  };
  let Constructor = LocalDate;
  function date(...args) {
    return new Constructor(...args);
  }
  function getLocalTimezoneOffset() {
    return -new Date().getTimezoneOffset();
  }
  function calculateTimezoneOffset(timezoneName, targetDate = new TZDate()) {
    if (!isIntlDateTimeFormatSupported()) {
      logger.warn(
        "Intl.DateTimeFormat is not fully supported. So It will return the local timezone offset only.\nYou can use a polyfill to fix this issue."
      );
      return -targetDate.toDate().getTimezoneOffset();
    }
    validateIANATimezoneName(timezoneName);
    const token = tokenizeTZDate(targetDate, timezoneName);
    const utcDate = tokenToUtcDate(token);
    return Math.round((utcDate.getTime() - targetDate.getTime()) / 60 / 1e3);
  }
  function isUsingDST(targetDate, timezoneName) {
    if (timezoneName) {
      validateIANATimezoneName(timezoneName);
    }
    const jan = new TZDate(targetDate.getFullYear(), 0, 1);
    const jul = new TZDate(targetDate.getFullYear(), 6, 1);
    if (timezoneName) {
      return Math.max(
        -calculateTimezoneOffset(timezoneName, jan),
        -calculateTimezoneOffset(timezoneName, jul)
      ) !== -calculateTimezoneOffset(timezoneName, targetDate);
    }
    return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset()) !== targetDate.toDate().getTimezoneOffset();
  }
  const dtfCache = {};
  const timezoneNameValidationCache = {};
  function isIntlDateTimeFormatSupported() {
    var _a, _b;
    return isFunction$2((_b = (_a = Intl == null ? void 0 : Intl.DateTimeFormat) == null ? void 0 : _a.prototype) == null ? void 0 : _b.formatToParts);
  }
  function validateIANATimezoneName(timezoneName) {
    if (timezoneNameValidationCache[timezoneName]) {
      return true;
    }
    try {
      Intl.DateTimeFormat("en-US", { timeZone: timezoneName });
      timezoneNameValidationCache[timezoneName] = true;
      return true;
    } catch (e2) {
      throw new InvalidTimezoneNameError(timezoneName);
    }
  }
  function getDateTimeFormat(timezoneName) {
    if (dtfCache[timezoneName]) {
      return dtfCache[timezoneName];
    }
    const dtf = new Intl.DateTimeFormat("en-US", {
      timeZone: timezoneName,
      hourCycle: "h23",
      hour12: false,
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    });
    dtfCache[timezoneName] = dtf;
    return dtf;
  }
  const typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    hour: 3,
    minute: 4,
    second: 5
  };
  function tokenizeTZDate(tzDate, timezoneName) {
    const dtf = getDateTimeFormat(timezoneName);
    const formatted = dtf.formatToParts(tzDate.toDate());
    return formatted.reduce((result, cur) => {
      const pos = typeToPos[cur.type];
      if (isPresent(pos)) {
        result[pos] = parseInt(cur.value, 10);
      }
      return result;
    }, []);
  }
  function tokenToUtcDate(token) {
    const [year, monthPlusOne, day, hour, minute, second] = token;
    const month = monthPlusOne - 1;
    return new Date(Date.UTC(year, month, day, hour % 24, minute, second));
  }
  function getTZOffsetMSDifference(offset) {
    return (getLocalTimezoneOffset() - offset) * MS_PER_MINUTES;
  }
  class TZDate {
    constructor(...args) {
      this.tzOffset = null;
      if (args[0] instanceof TZDate) {
        this.d = date(args[0].getTime());
      } else {
        this.d = date(...args);
      }
    }
    toString() {
      return this.d.toString();
    }
    addFullYear(y2) {
      this.setFullYear(this.getFullYear() + y2);
      return this;
    }
    addMonth(m2) {
      this.setMonth(this.getMonth() + m2);
      return this;
    }
    addDate(d2) {
      this.setDate(this.getDate() + d2);
      return this;
    }
    addHours(h2) {
      this.setHours(this.getHours() + h2);
      return this;
    }
    addMinutes(M2) {
      this.setMinutes(this.getMinutes() + M2);
      return this;
    }
    addSeconds(s2) {
      this.setSeconds(this.getSeconds() + s2);
      return this;
    }
    addMilliseconds(ms) {
      this.setMilliseconds(this.getMilliseconds() + ms);
      return this;
    }
    setWithRaw(y2, m2, d2, h2, M2, s2, ms) {
      this.setFullYear(y2, m2, d2);
      this.setHours(h2, M2, s2, ms);
      return this;
    }
    toDate() {
      return this.d.toDate();
    }
    valueOf() {
      return this.getTime();
    }
    getTimezoneOffset() {
      var _a;
      return (_a = this.tzOffset) != null ? _a : this.d.getTimezoneOffset();
    }
    getTime() {
      return this.d.getTime();
    }
    getFullYear() {
      return this.d.getFullYear();
    }
    getMonth() {
      return this.d.getMonth();
    }
    getDate() {
      return this.d.getDate();
    }
    getHours() {
      return this.d.getHours();
    }
    getMinutes() {
      return this.d.getMinutes();
    }
    getSeconds() {
      return this.d.getSeconds();
    }
    getMilliseconds() {
      return this.d.getMilliseconds();
    }
    getDay() {
      return this.d.getDay();
    }
    setTime(t2) {
      return this.d.setTime(t2);
    }
    setFullYear(y2, m2 = this.getMonth(), d2 = this.getDate()) {
      return this.d.setFullYear(y2, m2, d2);
    }
    setMonth(m2, d2 = this.getDate()) {
      return this.d.setMonth(m2, d2);
    }
    setDate(d2) {
      return this.d.setDate(d2);
    }
    setHours(h2, M2 = this.getMinutes(), s2 = this.getSeconds(), ms = this.getMilliseconds()) {
      return this.d.setHours(h2, M2, s2, ms);
    }
    setMinutes(M2, s2 = this.getSeconds(), ms = this.getMilliseconds()) {
      return this.d.setMinutes(M2, s2, ms);
    }
    setSeconds(s2, ms = this.getMilliseconds()) {
      return this.d.setSeconds(s2, ms);
    }
    setMilliseconds(ms) {
      return this.d.setMilliseconds(ms);
    }
    tz(tzValue) {
      if (tzValue === "Local") {
        return new TZDate(this.getTime());
      }
      const tzOffset = isString_1(tzValue) ? calculateTimezoneOffset(tzValue, this) : tzValue;
      const newTZDate = new TZDate(this.getTime() - getTZOffsetMSDifference(tzOffset));
      newTZDate.tzOffset = tzOffset;
      return newTZDate;
    }
    local(tzValue) {
      if (isPresent(tzValue)) {
        const tzOffset = isString_1(tzValue) ? calculateTimezoneOffset(tzValue, this) : tzValue;
        return new TZDate(this.getTime() + getTZOffsetMSDifference(tzOffset));
      }
      return new TZDate(
        this.getTime() + (isPresent(this.tzOffset) ? getTZOffsetMSDifference(this.tzOffset) : 0)
      );
    }
  }
  function pick(obj, ...propNames) {
    return propNames.reduce((acc, key) => {
      if (obj.hasOwnProperty(key)) {
        acc[key] = obj[key];
      }
      return acc;
    }, {});
  }
  function clone$1(source) {
    return Object.assign(Object.create(Object.getPrototypeOf(source)), source);
  }
  function mergeObject(target, source = {}) {
    if (!isObject_1(source)) {
      return target;
    }
    Object.keys(source).forEach((k2) => {
      const targetKey = k2;
      const sourceKey = k2;
      if (!Array.isArray(source[sourceKey]) && isObject_1(target[targetKey]) && isObject_1(source[sourceKey]) && !(source[sourceKey] instanceof TZDate)) {
        target[targetKey] = mergeObject(
          target[targetKey],
          source[sourceKey]
        );
      } else {
        target[targetKey] = source[sourceKey];
      }
    });
    return target;
  }
  const eventUIPropsKey = [
    "top",
    "left",
    "width",
    "height",
    "exceedLeft",
    "exceedRight",
    "croppedStart",
    "croppedEnd",
    "goingDurationHeight",
    "modelDurationHeight",
    "comingDurationHeight",
    "duplicateEvents",
    "duplicateEventIndex",
    "duplicateStarts",
    "duplicateEnds",
    "duplicateLeft",
    "duplicateWidth",
    "collapse",
    "isMain"
  ];
  class EventUIModel {
    constructor(event) {
      this.top = 0;
      this.left = 0;
      this.width = 0;
      this.height = 0;
      this.exceedLeft = false;
      this.exceedRight = false;
      this.croppedStart = false;
      this.croppedEnd = false;
      this.goingDurationHeight = 0;
      this.modelDurationHeight = 100;
      this.comingDurationHeight = 0;
      this.duplicateEvents = [];
      this.duplicateEventIndex = -1;
      this.duplicateLeft = "";
      this.duplicateWidth = "";
      this.collapse = false;
      this.isMain = false;
      this.model = event;
    }
    getUIProps() {
      return pick(this, ...eventUIPropsKey);
    }
    setUIProps(props) {
      Object.assign(this, props);
    }
    getStarts() {
      if (this.renderStarts) {
        return this.renderStarts;
      }
      return this.model.getStarts();
    }
    getEnds() {
      if (this.renderEnds) {
        return this.renderEnds;
      }
      return this.model.getEnds();
    }
    cid() {
      return this.model.cid();
    }
    valueOf() {
      return this.model;
    }
    duration() {
      return this.model.duration();
    }
    collidesWith(uiModel, usingTravelTime = true) {
      const infos = [];
      [this, uiModel].forEach((event) => {
        const isDuplicateEvent = event instanceof EventUIModel && event.duplicateEvents.length > 0;
        if (isDuplicateEvent) {
          infos.push({
            start: event.duplicateStarts,
            end: event.duplicateEnds,
            goingDuration: 0,
            comingDuration: 0
          });
        } else {
          infos.push({
            start: event.getStarts(),
            end: event.getEnds(),
            goingDuration: event.valueOf().goingDuration,
            comingDuration: event.valueOf().comingDuration
          });
        }
      });
      const [thisInfo, targetInfo] = infos;
      return collidesWith({
        start: thisInfo.start.getTime(),
        end: thisInfo.end.getTime(),
        targetStart: targetInfo.start.getTime(),
        targetEnd: targetInfo.end.getTime(),
        goingDuration: thisInfo.goingDuration,
        comingDuration: thisInfo.comingDuration,
        targetGoingDuration: targetInfo.goingDuration,
        targetComingDuration: targetInfo.comingDuration,
        usingTravelTime
      });
    }
    clone() {
      const eventUIModelProps = this.getUIProps();
      const clonedEventUIModel = new EventUIModel(this.model);
      clonedEventUIModel.setUIProps(eventUIModelProps);
      if (this.renderStarts) {
        clonedEventUIModel.renderStarts = new TZDate(this.renderStarts);
      }
      if (this.renderEnds) {
        clonedEventUIModel.renderEnds = new TZDate(this.renderEnds);
      }
      return clonedEventUIModel;
    }
  }
  function compareBooleansASC(a2, b2) {
    if (a2 !== b2) {
      return a2 ? -1 : 1;
    }
    return 0;
  }
  function compareNumbersASC(a2, b2) {
    return Number(a2) - Number(b2);
  }
  function compareStringsASC(_a, _b) {
    const a2 = String(_a);
    const b2 = String(_b);
    if (a2 === b2) {
      return 0;
    }
    return a2 > b2 ? 1 : -1;
  }
  function compareEventsASC(a2, b2) {
    const modelA = a2 instanceof EventUIModel ? a2.model : a2;
    const modelB = b2 instanceof EventUIModel ? b2.model : b2;
    const alldayCompare = compareBooleansASC(
      modelA.isAllday || modelA.hasMultiDates,
      modelB.isAllday || modelB.hasMultiDates
    );
    if (alldayCompare) {
      return alldayCompare;
    }
    const startsCompare = compare(a2.getStarts(), b2.getStarts());
    if (startsCompare) {
      return startsCompare;
    }
    const durationA = a2.duration();
    const durationB = b2.duration();
    if (durationA < durationB) {
      return 1;
    }
    if (durationA > durationB) {
      return -1;
    }
    return modelA.cid() - modelB.cid();
  }
  function bsearch(arr, search, fn2, compareFn) {
    let minIndex = 0;
    let maxIndex = arr.length - 1;
    let currentIndex;
    let value;
    let comp;
    compareFn = compareFn || compareStringsASC;
    while (minIndex <= maxIndex) {
      currentIndex = (minIndex + maxIndex) / 2 | 0;
      value = fn2 ? fn2(arr[currentIndex]) : arr[currentIndex];
      comp = compareFn(value, search);
      if (comp < 0) {
        minIndex = currentIndex + 1;
      } else if (comp > 0) {
        maxIndex = currentIndex - 1;
      } else {
        return currentIndex;
      }
    }
    return ~maxIndex;
  }
  var array = {
    bsearch,
    compare: {
      event: {
        asc: compareEventsASC
      },
      num: {
        asc: compareNumbersASC
      }
    }
  };
  function first(array2) {
    return array2[0];
  }
  function last(array2) {
    return array2[array2.length - 1];
  }
  function findLastIndex(array2, predicate) {
    for (let i2 = array2.length - 1; i2 >= 0; i2 -= 1) {
      if (predicate(array2[i2])) {
        return i2;
      }
    }
    return -1;
  }
  function fill(length, value) {
    if (length > 0) {
      return Array.from({ length }, () => {
        if (Array.isArray(value)) {
          return value.slice();
        }
        return value;
      });
    }
    return [];
  }
  var Day$2 = /* @__PURE__ */ ((Day2) => {
    Day2[Day2["SUN"] = 0] = "SUN";
    Day2[Day2["MON"] = 1] = "MON";
    Day2[Day2["TUE"] = 2] = "TUE";
    Day2[Day2["WED"] = 3] = "WED";
    Day2[Day2["THU"] = 4] = "THU";
    Day2[Day2["FRI"] = 5] = "FRI";
    Day2[Day2["SAT"] = 6] = "SAT";
    return Day2;
  })(Day$2 || {});
  const WEEK_DAYS = 7;
  const dateFormatRx = /^(\d{4}[-|/]*\d{2}[-|/]*\d{2})\s?(\d{2}:\d{2}:\d{2})?$/;
  const memo = {
    millisecondsTo: {},
    millisecondsFrom: {}
  };
  const convByTimeUnit = [24, 60, 60, 1e3];
  function leadingZero(number, length) {
    let zero = "";
    let i2 = 0;
    if (String(number).length > length) {
      return String(number);
    }
    for (; i2 < length - 1; i2 += 1) {
      zero += "0";
    }
    return (zero + number).slice(length * -1);
  }
  function getHourForMeridiem(date2) {
    let hour = date2.getHours();
    if (hour === 0) {
      hour = 12;
    }
    if (hour > 12) {
      hour = hour % 12;
    }
    return hour;
  }
  const tokenFunc = {
    YYYYMMDD(date2) {
      return [
        date2.getFullYear(),
        leadingZero(date2.getMonth() + 1, 2),
        leadingZero(date2.getDate(), 2)
      ].join("");
    },
    YYYY(date2) {
      return String(date2.getFullYear());
    },
    MM(date2) {
      return leadingZero(date2.getMonth() + 1, 2);
    },
    DD(date2) {
      return leadingZero(date2.getDate(), 2);
    },
    "HH:mm": function(date2) {
      const hour = date2.getHours();
      const minutes = date2.getMinutes();
      return `${leadingZero(hour, 2)}:${leadingZero(minutes, 2)}`;
    },
    "hh:mm": function(date2) {
      const hour = getHourForMeridiem(date2);
      const minutes = date2.getMinutes();
      return `${leadingZero(hour, 2)}:${leadingZero(minutes, 2)}`;
    },
    hh(date2) {
      const hour = getHourForMeridiem(date2);
      return String(hour);
    },
    tt(date2) {
      const hour = date2.getHours();
      return hour < 12 ? "am" : "pm";
    }
  };
  const MS_PER_DAY = 864e5;
  const MS_PER_MINUTES = 6e4;
  const MS_EVENT_MIN_DURATION = 20 * MS_PER_MINUTES;
  function getTimeSteps(timeGridRows) {
    const hourStart = Number(timeGridRows[0].startTime.split(":", 1));
    const hourEnd = Number(timeGridRows[timeGridRows.length - 1].endTime.split(":", 1));
    const STEPS = timeGridRows.length / (hourEnd - hourStart);
    const STEP_MINUTES = 60 / STEPS;
    return {
      STEPS,
      STEP_MINUTES,
      MS_PER_STEP_MINUTES: STEP_MINUTES * 60 * 1e3
    };
  }
  function toFormat(date2, strFormat) {
    let result = strFormat;
    Object.entries(tokenFunc).forEach(([token, converter]) => {
      result = result.replace(token, converter(date2));
    });
    return result;
  }
  function convMilliseconds(type, value, iteratee) {
    const index = {
      date: 0,
      hour: 1,
      minute: 2,
      second: 3
    };
    if (!(type in index) || isNaN(value)) {
      return 0;
    }
    return [value].concat(convByTimeUnit.slice(index[type])).reduce(iteratee);
  }
  function millisecondsFrom(type, value) {
    const cache = memo.millisecondsFrom;
    const key = type + value;
    if (cache[key]) {
      return cache[key];
    }
    const result = convMilliseconds(type, value, (m2, v2) => m2 * v2);
    if (!result) {
      return 0;
    }
    cache[key] = result;
    return cache[key];
  }
  function toStartOfDay(date2) {
    const d2 = date2 ? new TZDate(date2) : new TZDate();
    d2.setHours(0, 0, 0, 0);
    return d2;
  }
  function makeDateRange(startDate, endDate, step) {
    const startTime = startDate.getTime();
    const endTime = endDate.getTime();
    const date2 = new TZDate(startDate);
    const result = [];
    let cursor = startTime;
    while (cursor <= endTime && endTime >= date2.getTime()) {
      result.push(new TZDate(date2));
      cursor = cursor + step;
      date2.addMilliseconds(step);
    }
    return result;
  }
  function clone(date2) {
    return new TZDate(date2);
  }
  function compare(d1, d2) {
    const _d1 = d1.getTime();
    const _d2 = d2.getTime();
    if (_d1 < _d2) {
      return -1;
    }
    if (_d1 > _d2) {
      return 1;
    }
    return 0;
  }
  function isSameYear(d1, d2) {
    return d1.getFullYear() === d2.getFullYear();
  }
  function isSameMonth(d1, d2) {
    return isSameYear(d1, d2) && d1.getMonth() === d2.getMonth();
  }
  function isSameDate(d1, d2) {
    return isSameMonth(d1, d2) && d1.getDate() === d2.getDate();
  }
  function max(d1, d2) {
    return compare(d1, d2) === 1 ? d1 : d2;
  }
  function min(d1, d2) {
    return compare(d1, d2) === -1 ? d1 : d2;
  }
  function parse(str, fixMonth = -1) {
    const matches = str.match(dateFormatRx);
    let separator;
    let ymd;
    let hms;
    if (!matches) {
      throw new InvalidDateTimeFormatError(str);
    }
    if (str.length > 8) {
      separator = ~str.indexOf("/") ? "/" : "-";
      const result = matches.splice(1);
      ymd = result[0].split(separator);
      hms = result[1] ? result[1].split(":") : [0, 0, 0];
    } else {
      const [result] = matches;
      ymd = [result.substr(0, 4), result.substr(4, 2), result.substr(6, 2)];
      hms = [0, 0, 0];
    }
    return new TZDate().setWithRaw(
      Number(ymd[0]),
      Number(ymd[1]) + fixMonth,
      Number(ymd[2]),
      Number(hms[0]),
      Number(hms[1]),
      Number(hms[2]),
      0
    );
  }
  function toEndOfDay(date2) {
    const d2 = date2 ? new TZDate(date2) : new TZDate();
    d2.setHours(23, 59, 59, 999);
    return d2;
  }
  function isWeekend(day) {
    return day === 0 || day === 6;
  }
  function isSunday(day) {
    return day === 0;
  }
  function isSaturday(day) {
    return day === 6;
  }
  function toStartOfMonth(date2) {
    const startDate = new TZDate(date2);
    startDate.setDate(1);
    startDate.setHours(0, 0, 0, 0);
    return startDate;
  }
  function toEndOfMonth(date2) {
    const endDate = toStartOfMonth(date2);
    endDate.setMonth(endDate.getMonth() + 1);
    endDate.setDate(endDate.getDate() - 1);
    endDate.setHours(23, 59, 59, 999);
    return endDate;
  }
  function getRowStyleInfo(days, narrowWeekend, startDayOfWeek, workweek) {
    const limitDaysToApplyNarrowWeekend = 5;
    const uniformWidth = 100 / days;
    const wideWidth = days > limitDaysToApplyNarrowWeekend ? 100 / (days - 1) : uniformWidth;
    let accumulatedWidth = 0;
    const dates = range_1(startDayOfWeek, WEEK_DAYS).concat(range_1(days)).slice(0, WEEK_DAYS);
    narrowWeekend = workweek ? false : narrowWeekend;
    const rowStyleInfo = dates.map((day) => {
      let width = narrowWeekend ? wideWidth : uniformWidth;
      if (days > limitDaysToApplyNarrowWeekend && narrowWeekend && isWeekend(day)) {
        width = wideWidth / 2;
      }
      const model = {
        width,
        left: accumulatedWidth
      };
      accumulatedWidth += width;
      return model;
    });
    const { length } = rowStyleInfo;
    const cellWidthMap = fill(length, fill(length, 0));
    rowStyleInfo.forEach(({ width }, index) => {
      for (let i2 = 0; i2 <= index; i2 += 1) {
        for (let j2 = index; j2 < length; j2 += 1) {
          cellWidthMap[i2][j2] += width;
        }
      }
    });
    cellWidthMap[0][length - 1] = 100;
    return {
      rowStyleInfo,
      cellWidthMap: cellWidthMap.map((widthList) => widthList.map(toPercent))
    };
  }
  function addMilliseconds(d2, step) {
    const date2 = clone(d2);
    date2.setMilliseconds(d2.getMilliseconds() + step);
    return date2;
  }
  function addMinutes(d2, step) {
    const date2 = clone(d2);
    date2.setMinutes(d2.getMinutes() + step);
    return date2;
  }
  function setTimeStrToDate(d2, timeStr) {
    const date2 = clone(d2);
    date2.setHours(...timeStr.split(":").map(Number));
    return date2;
  }
  function addDate(d2, step) {
    const date2 = clone(d2);
    date2.setDate(d2.getDate() + step);
    return date2;
  }
  function subtractDate(d2, steps) {
    const date2 = clone(d2);
    date2.setDate(d2.getDate() - steps);
    return date2;
  }
  function addMonths(d2, step = 1) {
    const date2 = clone(d2);
    if (step !== 0) {
      const dayOfMonth = date2.getDate();
      const endOfDesiredMonth = new TZDate(date2.getTime());
      endOfDesiredMonth.setMonth(date2.getMonth() + step + 1, 0);
      const daysInMonth = endOfDesiredMonth.getDate();
      if (dayOfMonth >= daysInMonth) {
        return endOfDesiredMonth;
      }
      date2.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    }
    return date2;
  }
  function getDateDifference(d1, d2) {
    const _d1 = new TZDate(d1.getFullYear(), d1.getMonth(), d1.getDate()).getTime();
    const _d2 = new TZDate(d2.getFullYear(), d2.getMonth(), d2.getDate()).getTime();
    return Math.round((_d1 - _d2) / MS_PER_DAY);
  }
  function hasCollision(start, end, targetStart, targetEnd) {
    return targetStart > start && targetStart < end || targetEnd > start && targetEnd < end || targetStart <= start && targetEnd >= end;
  }
  function collidesWith({
    start,
    end,
    targetStart,
    targetEnd,
    goingDuration,
    comingDuration,
    targetGoingDuration,
    targetComingDuration,
    usingTravelTime
  }) {
    if (Math.abs(end - start) < MS_EVENT_MIN_DURATION) {
      end += MS_EVENT_MIN_DURATION;
    }
    if (Math.abs(end - start) < MS_EVENT_MIN_DURATION) {
      end += MS_EVENT_MIN_DURATION;
    }
    if (usingTravelTime) {
      start -= millisecondsFrom("minute", goingDuration);
      end += millisecondsFrom("minute", comingDuration);
      targetStart -= millisecondsFrom("minute", targetGoingDuration);
      targetEnd += millisecondsFrom("minute", targetComingDuration);
    }
    return hasCollision(start, end, targetStart, targetEnd);
  }
  function isSameEvent(event, eventId, calendarId) {
    return event.id === eventId && event.calendarId === calendarId;
  }
  function idGenerator() {
    let id = 0;
    return {
      next() {
        id += 1;
        return id;
      }
    };
  }
  const getId = function() {
    const generator = idGenerator();
    return () => generator.next();
  }();
  function stamp(obj) {
    if (!obj.__fe_id) {
      obj.__fe_id = getId();
    }
    return obj.__fe_id;
  }
  class EventModel {
    constructor(event = {}) {
      this.id = "";
      this.calendarId = "";
      this.title = "";
      this.body = "";
      this.isAllday = false;
      this.start = new TZDate();
      this.end = new TZDate();
      this.goingDuration = 0;
      this.comingDuration = 0;
      this.location = "";
      this.attendees = [];
      this.category = "time";
      this.dueDateClass = "";
      this.recurrenceRule = "";
      this.state = "Busy";
      this.isVisible = true;
      this.isPending = false;
      this.isFocused = false;
      this.isReadOnly = false;
      this.isPrivate = false;
      this.customStyle = {};
      this.raw = null;
      this.hasMultiDates = false;
      stamp(this);
      this.init(event);
    }
    init({
      id = "",
      calendarId = "",
      title = "",
      body = "",
      isAllday: isAllday2 = false,
      start = new TZDate(),
      end = new TZDate(),
      goingDuration = 0,
      comingDuration = 0,
      location: location2 = "",
      attendees = [],
      category = "time",
      dueDateClass = "",
      recurrenceRule = "",
      state = "Busy",
      isVisible = true,
      isPending = false,
      isFocused = false,
      isReadOnly = false,
      isPrivate = false,
      color,
      backgroundColor,
      dragBackgroundColor,
      borderColor,
      customStyle = {},
      raw = null
    } = {}) {
      this.id = id;
      this.calendarId = calendarId;
      this.title = title;
      this.body = body;
      this.isAllday = category === "allday" ? true : isAllday2;
      this.goingDuration = goingDuration;
      this.comingDuration = comingDuration;
      this.location = location2;
      this.attendees = attendees;
      this.category = category;
      this.dueDateClass = dueDateClass;
      this.recurrenceRule = recurrenceRule;
      this.state = state;
      this.isVisible = isVisible;
      this.isPending = isPending;
      this.isFocused = isFocused;
      this.isReadOnly = isReadOnly;
      this.isPrivate = isPrivate;
      this.color = color;
      this.backgroundColor = backgroundColor;
      this.dragBackgroundColor = dragBackgroundColor;
      this.borderColor = borderColor;
      this.customStyle = customStyle;
      this.raw = raw;
      if (this.isAllday) {
        this.setAlldayPeriod(start, end);
      } else {
        this.setTimePeriod(start, end);
      }
      if (category === "milestone" || category === "task") {
        this.start = new TZDate(this.end);
      }
    }
    setAlldayPeriod(start, end) {
      let startedAt;
      let endedAt;
      if (isString_1(start)) {
        startedAt = parse(start.substring(0, 10));
      } else {
        startedAt = new TZDate(start || Date.now());
      }
      if (isString_1(end)) {
        endedAt = parse(end.substring(0, 10));
      } else {
        endedAt = new TZDate(end || this.start);
      }
      this.start = startedAt;
      this.start.setHours(0, 0, 0);
      this.end = endedAt || new TZDate(this.start);
      this.end.setHours(23, 59, 59);
    }
    setTimePeriod(start, end) {
      this.start = new TZDate(start || Date.now());
      this.end = new TZDate(end || this.start);
      if (!end) {
        this.end.setMinutes(this.end.getMinutes() + 30);
      }
      this.hasMultiDates = this.end.getTime() - this.start.getTime() > MS_PER_DAY;
    }
    getStarts() {
      return this.start;
    }
    getEnds() {
      return this.end;
    }
    cid() {
      return stamp(this);
    }
    equals(event) {
      if (this.id !== event.id) {
        return false;
      }
      if (this.title !== event.title) {
        return false;
      }
      if (this.body !== event.body) {
        return false;
      }
      if (this.isAllday !== event.isAllday) {
        return false;
      }
      if (compare(this.getStarts(), event.getStarts()) !== 0) {
        return false;
      }
      if (compare(this.getEnds(), event.getEnds()) !== 0) {
        return false;
      }
      if (this.color !== event.color) {
        return false;
      }
      if (this.backgroundColor !== event.backgroundColor) {
        return false;
      }
      if (this.dragBackgroundColor !== event.dragBackgroundColor) {
        return false;
      }
      if (this.borderColor !== event.borderColor) {
        return false;
      }
      return true;
    }
    duration() {
      const start = Number(this.getStarts());
      const end = Number(this.getEnds());
      let duration;
      if (this.isAllday) {
        duration = Number(toEndOfDay(end)) - Number(toStartOfDay(start));
      } else {
        duration = end - start;
      }
      return duration;
    }
    valueOf() {
      return this;
    }
    collidesWith(event, usingTravelTime = true) {
      event = event instanceof EventUIModel ? event.model : event;
      return collidesWith({
        start: Number(this.getStarts()),
        end: Number(this.getEnds()),
        targetStart: Number(event.getStarts()),
        targetEnd: Number(event.getEnds()),
        goingDuration: this.goingDuration,
        comingDuration: this.comingDuration,
        targetGoingDuration: event.goingDuration,
        targetComingDuration: event.comingDuration,
        usingTravelTime
      });
    }
    toEventObject() {
      return {
        id: this.id,
        calendarId: this.calendarId,
        __cid: this.cid(),
        title: this.title,
        body: this.body,
        isAllday: this.isAllday,
        start: this.start,
        end: this.end,
        goingDuration: this.goingDuration,
        comingDuration: this.comingDuration,
        location: this.location,
        attendees: this.attendees,
        category: this.category,
        dueDateClass: this.dueDateClass,
        recurrenceRule: this.recurrenceRule,
        state: this.state,
        isVisible: this.isVisible,
        isPending: this.isPending,
        isFocused: this.isFocused,
        isReadOnly: this.isReadOnly,
        isPrivate: this.isPrivate,
        color: this.color,
        backgroundColor: this.backgroundColor,
        dragBackgroundColor: this.dragBackgroundColor,
        borderColor: this.borderColor,
        customStyle: this.customStyle,
        raw: this.raw
      };
    }
    getColors() {
      return {
        color: this.color,
        backgroundColor: this.backgroundColor,
        dragBackgroundColor: this.dragBackgroundColor,
        borderColor: this.borderColor
      };
    }
  }
  EventModel.schema = {
    required: ["title"],
    dateRange: ["start", "end"]
  };
  function isTimeEvent({ model }) {
    const { category, isAllday: isAllday2, hasMultiDates } = model;
    return category === "time" && !isAllday2 && !hasMultiDates;
  }
  class Collection {
    constructor(getItemIDFn) {
      this.internalMap = /* @__PURE__ */ new Map();
      if (isFunction$2(getItemIDFn)) {
        this.getItemID = getItemIDFn;
      }
    }
    static and(...filterFns) {
      const { length } = filterFns;
      return (item) => {
        for (let i2 = 0; i2 < length; i2 += 1) {
          if (!filterFns[i2].call(null, item)) {
            return false;
          }
        }
        return true;
      };
    }
    static or(...filterFns) {
      const { length } = filterFns;
      if (!length) {
        return () => false;
      }
      return (item) => {
        let result = filterFns[0].call(null, item);
        for (let i2 = 1; i2 < length; i2 += 1) {
          result = result || filterFns[i2].call(null, item);
        }
        return result;
      };
    }
    getItemID(item) {
      var _a;
      return (_a = item == null ? void 0 : item._id) != null ? _a : "";
    }
    getFirstItem() {
      const iterator = this.internalMap.values();
      return iterator.next().value;
    }
    add(...items) {
      items.forEach((item) => {
        const id = this.getItemID(item);
        this.internalMap.set(id, item);
      });
      return this;
    }
    remove(...items) {
      const removeResult = [];
      items.forEach((item) => {
        const id = isString_1(item) || isNumber_1(item) ? item : this.getItemID(item);
        if (!this.internalMap.has(id)) {
          return;
        }
        removeResult.push(this.internalMap.get(id));
        this.internalMap["delete"](id);
      });
      return removeResult.length === 1 ? removeResult[0] : removeResult;
    }
    has(item) {
      const id = isString_1(item) || isNumber_1(item) ? item : this.getItemID(item);
      return this.internalMap.has(id);
    }
    get(item) {
      var _a;
      const id = isString_1(item) || isNumber_1(item) ? item : this.getItemID(item);
      return (_a = this.internalMap.get(id)) != null ? _a : null;
    }
    doWhenHas(id, callback) {
      const item = this.internalMap.get(id);
      if (isNil(item)) {
        return;
      }
      callback(item);
    }
    filter(filterFn) {
      const result = new Collection();
      if (this.hasOwnProperty("getItemID")) {
        result.getItemID = this.getItemID;
      }
      this.internalMap.forEach((item) => {
        if (filterFn(item) === true) {
          result.add(item);
        }
      });
      return result;
    }
    groupBy(groupByFn) {
      const result = {};
      this.internalMap.forEach((item) => {
        var _a;
        let key = isFunction$2(groupByFn) ? groupByFn(item) : item[groupByFn];
        if (isFunction$2(key)) {
          key = key.call(item);
        }
        (_a = result[key]) != null ? _a : result[key] = new Collection(this.getItemID);
        result[key].add(item);
      });
      return result;
    }
    find(findFn) {
      let result = null;
      const items = this.internalMap.values();
      let next = items.next();
      while (next.done === false) {
        if (findFn(next.value)) {
          result = next.value;
          break;
        }
        next = items.next();
      }
      return result;
    }
    sort(compareFn) {
      return this.toArray().sort(compareFn);
    }
    each(iteratee) {
      const entries = this.internalMap.entries();
      let next = entries.next();
      while (next.done === false) {
        const [key, value] = next.value;
        if (iteratee(value, key) === false) {
          break;
        }
        next = entries.next();
      }
    }
    clear() {
      this.internalMap.clear();
    }
    toArray() {
      return Array.from(this.internalMap.values());
    }
    get size() {
      return this.internalMap.size;
    }
  }
  function createEventCollection(...initItems) {
    const collection = new Collection((event) => event.cid());
    if (initItems.length) {
      collection.add(...initItems);
    }
    return collection;
  }
  function getDateRange(start, end) {
    return makeDateRange(toStartOfDay(start), toEndOfDay(end), MS_PER_DAY);
  }
  function isAllday(event) {
    return event.isAllday || event.category === "time" && Number(event.end) - Number(event.start) > MS_PER_DAY;
  }
  function filterByCategory(uiModel) {
    const { model } = uiModel;
    if (isAllday(model)) {
      return "allday";
    }
    return model.category;
  }
  function addToMatrix(idsOfDay, event) {
    const containDates = getDateRange(event.getStarts(), event.getEnds());
    containDates.forEach((date2) => {
      const ymd = toFormat(date2, "YYYYMMDD");
      const matrix = idsOfDay[ymd] = idsOfDay[ymd] || [];
      matrix.push(event.cid());
    });
  }
  function removeFromMatrix(idsOfDay, event) {
    const modelID = event.cid();
    Object.values(idsOfDay).forEach((ids) => {
      const index = ids.indexOf(modelID);
      if (~index) {
        ids.splice(index, 1);
      }
    });
  }
  function addEvent(calendarData, event) {
    calendarData.events.add(event);
    addToMatrix(calendarData.idsOfDay, event);
    return event;
  }
  function createEvent(calendarData, eventData) {
    const event = new EventModel(eventData);
    return addEvent(calendarData, event);
  }
  function createEvents(calendarData, events = []) {
    return events.map((eventData) => createEvent(calendarData, eventData));
  }
  function updateEvent(calendarData, eventId, calendarId, eventData) {
    const { idsOfDay } = calendarData;
    const event = calendarData.events.find((item) => isSameEvent(item, eventId, calendarId));
    if (!event) {
      return false;
    }
    event.init(__spreadValues(__spreadValues({}, event), eventData));
    removeFromMatrix(idsOfDay, event);
    addToMatrix(idsOfDay, event);
    return true;
  }
  function deleteEvent(calendarData, event) {
    removeFromMatrix(calendarData.idsOfDay, event);
    calendarData.events.remove(event);
    return event;
  }
  function clearEvents(calendarData) {
    calendarData.idsOfDay = {};
    calendarData.events.clear();
  }
  function createCalendarSlice(calendars = []) {
    return {
      calendar: {
        calendars,
        events: createEventCollection(),
        idsOfDay: {}
      }
    };
  }
  function createCalendarDispatchers(set) {
    return {
      createEvents: (events) => set(
        produce((state) => {
          createEvents(state.calendar, events);
        })
      ),
      updateEvent: ({ event, eventData }) => set(
        produce((state) => {
          updateEvent(
            state.calendar,
            event.id,
            event.calendarId,
            eventData
          );
        })
      ),
      deleteEvent: (event) => set(
        produce((state) => {
          deleteEvent(state.calendar, event);
        })
      ),
      clearEvents: () => set(
        produce((state) => {
          clearEvents(state.calendar);
        })
      ),
      setCalendars: (calendars) => set(
        produce((state) => {
          state.calendar.calendars = calendars;
        })
      ),
      setCalendarColor: (calendarId, colorOptions) => set(
        produce((state) => {
          const calendars = state.calendar.calendars.map((calendar) => {
            if (calendar.id === calendarId) {
              return __spreadValues(__spreadValues({}, calendar), colorOptions);
            }
            return calendar;
          });
          const events = state.calendar.events.toArray().map((event) => {
            var _a, _b, _c, _d;
            if (event.calendarId === calendarId) {
              event.color = (_a = colorOptions.color) != null ? _a : event.color;
              event.backgroundColor = (_b = colorOptions.backgroundColor) != null ? _b : event.backgroundColor;
              event.borderColor = (_c = colorOptions.borderColor) != null ? _c : event.borderColor;
              event.dragBackgroundColor = (_d = colorOptions.dragBackgroundColor) != null ? _d : event.dragBackgroundColor;
            }
            return event;
          });
          const collection = createEventCollection(...events);
          state.calendar.calendars = calendars;
          state.calendar.events = collection;
        })
      ),
      setCalendarVisibility: (calendarIds, isVisible) => set(
        produce((state) => {
          const events = state.calendar.events.toArray();
          state.calendar.events = createEventCollection(
            ...events.map((event) => {
              if (calendarIds.includes(event.calendarId)) {
                event.isVisible = isVisible;
              }
              return event;
            })
          );
        })
      )
    };
  }
  var DraggingState = /* @__PURE__ */ ((DraggingState2) => {
    DraggingState2[DraggingState2["IDLE"] = 0] = "IDLE";
    DraggingState2[DraggingState2["INIT"] = 1] = "INIT";
    DraggingState2[DraggingState2["DRAGGING"] = 2] = "DRAGGING";
    DraggingState2[DraggingState2["CANCELED"] = 3] = "CANCELED";
    return DraggingState2;
  })(DraggingState || {});
  function createDndSlice() {
    return {
      dnd: {
        draggingItemType: null,
        draggingState: 0,
        initX: null,
        initY: null,
        x: null,
        y: null,
        draggingEventUIModel: null
      }
    };
  }
  function createDndDispatchers(set) {
    return {
      initDrag: (initState) => {
        set(
          produce((state) => {
            state.dnd = __spreadProps(__spreadValues(__spreadValues({}, state.dnd), initState), {
              draggingState: 1
            });
          })
        );
      },
      setDragging: (newState) => {
        set(
          produce((state) => {
            state.dnd = __spreadProps(__spreadValues(__spreadValues({}, state.dnd), newState), {
              draggingState: 2
            });
          })
        );
      },
      cancelDrag: () => {
        set(
          produce((state) => {
            state.dnd = createDndSlice().dnd;
            state.dnd.draggingState = 3;
          })
        );
      },
      reset: () => {
        set(
          produce((state) => {
            state.dnd = createDndSlice().dnd;
          })
        );
      },
      setDraggingEventUIModel: (eventUIModel) => {
        set(
          produce((state) => {
            var _a;
            state.dnd.draggingEventUIModel = (_a = eventUIModel == null ? void 0 : eventUIModel.clone()) != null ? _a : null;
          })
        );
      }
    };
  }
  function createGridSelectionSlice() {
    return {
      gridSelection: {
        dayGridMonth: null,
        dayGridWeek: null,
        timeGrid: null,
        accumulated: {
          dayGridMonth: []
        }
      }
    };
  }
  function createGridSelectionDispatchers(set) {
    return {
      setGridSelection: (type, gridSelection) => {
        set(
          produce((state) => {
            state.gridSelection[type] = gridSelection;
          })
        );
      },
      addGridSelection: (type, gridSelection) => {
        set(
          produce((state) => {
            if (type === "dayGridMonth" && gridSelection) {
              state.gridSelection.accumulated[type] = [
                ...state.gridSelection.accumulated[type],
                gridSelection
              ];
              state.gridSelection.dayGridMonth = null;
            }
          })
        );
      },
      clearAll: () => set(
        produce((state) => {
          state.gridSelection = createGridSelectionSlice().gridSelection;
        })
      )
    };
  }
  const DEFAULT_RESIZER_LENGTH = 3;
  const DEFAULT_DUPLICATE_EVENT_CID = -1;
  function getRestPanelHeight(dayGridRowsState, lastPanelType, initHeight) {
    return Object.keys(dayGridRowsState).reduce((acc, rowName) => {
      if (rowName === lastPanelType) {
        return acc;
      }
      return acc - dayGridRowsState[rowName].height - DEFAULT_RESIZER_LENGTH;
    }, initHeight);
  }
  function createWeekViewLayoutSlice() {
    return {
      layout: 500,
      weekViewLayout: {
        lastPanelType: null,
        dayGridRows: {},
        selectedDuplicateEventCid: DEFAULT_DUPLICATE_EVENT_CID
      }
    };
  }
  function createWeekViewLayoutDispatchers(set) {
    return {
      setLastPanelType: (type) => {
        set(
          produce((state) => {
            state.weekViewLayout.lastPanelType = type;
            if (type) {
              state.weekViewLayout.dayGridRows[type].height = getRestPanelHeight(
                state.weekViewLayout.dayGridRows,
                type,
                state.layout
              );
            }
          })
        );
      },
      updateLayoutHeight: (height) => set(
        produce((state) => {
          const { lastPanelType } = state.weekViewLayout;
          state.layout = height;
          if (lastPanelType) {
            state.weekViewLayout.dayGridRows[lastPanelType].height = getRestPanelHeight(
              state.weekViewLayout.dayGridRows,
              lastPanelType,
              height
            );
          }
        })
      ),
      updateDayGridRowHeight: ({ rowName, height }) => set(
        produce((state) => {
          const { lastPanelType } = state.weekViewLayout;
          state.weekViewLayout.dayGridRows[rowName] = { height };
          if (lastPanelType) {
            state.weekViewLayout.dayGridRows[lastPanelType].height = getRestPanelHeight(
              state.weekViewLayout.dayGridRows,
              lastPanelType,
              state.layout
            );
          }
        })
      ),
      updateDayGridRowHeightByDiff: ({ rowName, diff }) => set(
        produce((state) => {
          var _a, _b, _c;
          const { lastPanelType } = state.weekViewLayout;
          const height = (_c = (_b = (_a = state.weekViewLayout.dayGridRows) == null ? void 0 : _a[rowName]) == null ? void 0 : _b.height) != null ? _c : DEFAULT_PANEL_HEIGHT;
          state.weekViewLayout.dayGridRows[rowName] = { height: height + diff };
          if (lastPanelType) {
            state.weekViewLayout.dayGridRows[lastPanelType].height = getRestPanelHeight(
              state.weekViewLayout.dayGridRows,
              lastPanelType,
              state.layout
            );
          }
        })
      ),
      setSelectedDuplicateEventCid: (cid) => set(
        produce((state) => {
          state.weekViewLayout.selectedDuplicateEventCid = cid != null ? cid : DEFAULT_DUPLICATE_EVENT_CID;
        })
      )
    };
  }
  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  const DEFAULT_DAY_NAMES = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
  const getDayName = (dayIndex) => {
    return DEFAULT_DAY_NAMES[dayIndex];
  };
  function getDayNames(days, weekDayNamesOption) {
    return days.map((day) => {
      const dayIndex = day.getDay();
      const dayName = weekDayNamesOption.length > 0 ? weekDayNamesOption[dayIndex] : capitalize(getDayName(dayIndex));
      return {
        date: day.getDate(),
        day: day.getDay(),
        dayName,
        isToday: true,
        renderDate: "date",
        dateInstance: day
      };
    });
  }
  function initializeCollapseDuplicateEvents(options) {
    if (!options) {
      return false;
    }
    const initialCollapseDuplicateEvents = {
      getDuplicateEvents: (targetEvent, events) => events.filter(
        (event) => event.title === targetEvent.title && compare(event.start, targetEvent.start) === 0 && compare(event.end, targetEvent.end) === 0
      ).sort((a2, b2) => a2.calendarId > b2.calendarId ? 1 : -1),
      getMainEvent: (events) => last(events)
    };
    if (isBoolean_1(options)) {
      return initialCollapseDuplicateEvents;
    }
    return __spreadValues(__spreadValues({}, initialCollapseDuplicateEvents), options);
  }
  function initializeWeekOptions(weekOptions = {}) {
    const week = __spreadValues({
      startDayOfWeek: Day$2.SUN,
      dayNames: [],
      narrowWeekend: false,
      workweek: false,
      showNowIndicator: true,
      showTimezoneCollapseButton: false,
      timezonesCollapsed: false,
      hourStart: 0,
      hourEnd: 24,
      eventView: true,
      taskView: true,
      collapseDuplicateEvents: false,
      timeStep: [0, 30]
    }, weekOptions);
    week.collapseDuplicateEvents = initializeCollapseDuplicateEvents(week.collapseDuplicateEvents);
    return week;
  }
  function initializeTimezoneOptions(timezoneOptions = {}) {
    return __spreadValues({
      zones: []
    }, timezoneOptions);
  }
  function initializeMonthOptions(monthOptions = {}) {
    const month = __spreadValues({
      dayNames: [],
      visibleWeeksCount: 0,
      workweek: false,
      narrowWeekend: false,
      startDayOfWeek: Day$2.SUN,
      isAlways6Weeks: true,
      visibleEventCount: 6
    }, monthOptions);
    if (month.dayNames.length === 0) {
      month.dayNames = DEFAULT_DAY_NAMES.slice();
    }
    return month;
  }
  function initializeGridSelectionOptions(options) {
    if (isBoolean_1(options)) {
      return {
        enableDblClick: options,
        enableClick: options
      };
    }
    return __spreadValues({
      enableDblClick: true,
      enableClick: true
    }, options);
  }
  const initialEventFilter = (event) => !!event.isVisible;
  function createOptionsSlice(options = {}) {
    var _a, _b, _c, _d, _e, _f;
    return {
      options: {
        defaultView: (_a = options.defaultView) != null ? _a : "week",
        useFormPopup: (_b = options.useFormPopup) != null ? _b : false,
        useDetailPopup: (_c = options.useDetailPopup) != null ? _c : false,
        isReadOnly: (_d = options.isReadOnly) != null ? _d : false,
        week: initializeWeekOptions(options.week),
        month: initializeMonthOptions(options.month),
        gridSelection: initializeGridSelectionOptions(options.gridSelection),
        usageStatistics: (_e = options.usageStatistics) != null ? _e : true,
        eventFilter: (_f = options.eventFilter) != null ? _f : initialEventFilter,
        timezone: initializeTimezoneOptions(options.timezone)
      }
    };
  }
  function createOptionsDispatchers(set) {
    return {
      setOptions: (newOptions = {}) => set(
        produce((state) => {
          var _a;
          if (newOptions.gridSelection) {
            newOptions.gridSelection = initializeGridSelectionOptions(newOptions.gridSelection);
          }
          if ((_a = newOptions.week) == null ? void 0 : _a.collapseDuplicateEvents) {
            newOptions.week.collapseDuplicateEvents = initializeCollapseDuplicateEvents(
              newOptions.week.collapseDuplicateEvents
            );
          }
          mergeObject(state.options, newOptions);
        })
      )
    };
  }
  var PopupType = /* @__PURE__ */ ((PopupType2) => {
    PopupType2["SeeMore"] = "seeMore";
    PopupType2["Form"] = "form";
    PopupType2["Detail"] = "detail";
    return PopupType2;
  })(PopupType || {});
  function createPopupSlice() {
    return {
      popup: {
        ["seeMore"]: null,
        ["form"]: null,
        ["detail"]: null
      }
    };
  }
  function createPopupDispatchers(set) {
    return {
      showSeeMorePopup: (param) => set(
        produce((state) => {
          state.popup["seeMore"] = param;
          state.popup["form"] = null;
          state.popup["detail"] = null;
        })
      ),
      showFormPopup: (param) => set(
        produce((state) => {
          state.popup["form"] = param;
          state.popup["seeMore"] = null;
          state.popup["detail"] = null;
        })
      ),
      showDetailPopup: (param, isOpenedInSeeMorePopup) => set(
        produce((state) => {
          state.popup["detail"] = param;
          state.popup["form"] = null;
          if (!isOpenedInSeeMorePopup) {
            state.popup["seeMore"] = null;
          }
        })
      ),
      hideSeeMorePopup: () => set(
        produce((state) => {
          state.popup["seeMore"] = null;
        })
      ),
      hideFormPopup: () => set(
        produce((state) => {
          state.popup["form"] = null;
        })
      ),
      hideDetailPopup: () => set(
        produce((state) => {
          state.popup["detail"] = null;
        })
      ),
      hideAllPopup: () => set(
        produce((state) => {
          state.popup["seeMore"] = null;
          state.popup["form"] = null;
          state.popup["detail"] = null;
        })
      )
    };
  }
  const noop = () => {
  };
  const CSS_AUTO_REGEX = /^auto$|^$|%/;
  function getStyle(el, style) {
    let value = el.style[style];
    if ((!value || value === "auto") && document.defaultView) {
      const css = document.defaultView.getComputedStyle(el, null);
      value = css ? css[style] : null;
    }
    return value === "auto" ? null : value;
  }
  function invalidateSizeValue(value) {
    if (isString_1(value)) {
      return CSS_AUTO_REGEX.test(value);
    }
    return value === null;
  }
  function getSize(el) {
    const w2 = getStyle(el, "width");
    const h2 = getStyle(el, "height");
    if ((invalidateSizeValue(w2) || invalidateSizeValue(h2)) && el.getBoundingClientRect) {
      const { width, height } = el.getBoundingClientRect();
      return {
        width: width || el.offsetWidth,
        height: height || el.offsetHeight
      };
    }
    return {
      width: parseFloat(w2 != null ? w2 : "0"),
      height: parseFloat(h2 != null ? h2 : "0")
    };
  }
  const ElementClass = typeof Element === "undefined" ? noop : Element;
  const elProto = ElementClass.prototype;
  elProto.matches || elProto.webkitMatchesSelector || elProto.msMatchesSelector || function(selector) {
    return Array.from(document.querySelectorAll(selector)).includes(this);
  };
  function stripTags(str) {
    return str.replace(/<([^>]+)>/gi, "");
  }
  const SIXTY_MINUTES = 60;
  const templates = {
    milestone(model) {
      const classNames2 = cls("icon", "ic-milestone");
      return /* @__PURE__ */ y$3(g$2, null, /* @__PURE__ */ y$3("span", {
        className: classNames2
      }), /* @__PURE__ */ y$3("span", {
        style: {
          backgroundColor: model.backgroundColor
        }
      }, stripTags(model.title)));
    },
    milestoneTitle() {
      return /* @__PURE__ */ y$3("span", {
        className: cls("left-content")
      }, "Milestone");
    },
    task(model) {
      return `#${model.title}`;
    },
    taskTitle() {
      return /* @__PURE__ */ y$3("span", {
        className: cls("left-content")
      }, "Task");
    },
    alldayTitle() {
      return /* @__PURE__ */ y$3("span", {
        className: cls("left-content")
      }, "All Day");
    },
    allday(model) {
      return stripTags(model.title);
    },
    time(model) {
      const { start, title } = model;
      if (start) {
        return /* @__PURE__ */ y$3("span", null, /* @__PURE__ */ y$3("strong", null, toFormat(start, "HH:mm")), "\xA0", /* @__PURE__ */ y$3("span", null, stripTags(title)));
      }
      return stripTags(title);
    },
    goingDuration(model) {
      const { goingDuration } = model;
      const hour = Math.floor(goingDuration / SIXTY_MINUTES);
      const minutes = goingDuration % SIXTY_MINUTES;
      return `GoingTime ${leadingZero(hour, 2)}:${leadingZero(minutes, 2)}`;
    },
    comingDuration(model) {
      const { comingDuration } = model;
      const hour = Math.floor(comingDuration / SIXTY_MINUTES);
      const minutes = comingDuration % SIXTY_MINUTES;
      return `ComingTime ${leadingZero(hour, 2)}:${leadingZero(minutes, 2)}`;
    },
    monthMoreTitleDate(moreTitle) {
      const { date: date2, day } = moreTitle;
      const classNameDay = cls("more-title-date");
      const classNameDayLabel = cls("more-title-day");
      const dayName = capitalize(getDayName(day));
      return /* @__PURE__ */ y$3(g$2, null, /* @__PURE__ */ y$3("span", {
        className: classNameDay
      }, date2), /* @__PURE__ */ y$3("span", {
        className: classNameDayLabel
      }, dayName));
    },
    monthMoreClose() {
      return "";
    },
    monthGridHeader(model) {
      const date2 = parseInt(model.date.split("-")[2], 10);
      const classNames2 = cls("weekday-grid-date", { "weekday-grid-date-decorator": model.isToday });
      return /* @__PURE__ */ y$3("span", {
        className: classNames2
      }, date2);
    },
    monthGridHeaderExceed(hiddenEvents) {
      const className2 = cls("weekday-grid-more-events");
      return /* @__PURE__ */ y$3("span", {
        className: className2
      }, hiddenEvents, " more");
    },
    monthGridFooter(_model) {
      return "";
    },
    monthGridFooterExceed(_hiddenEvents) {
      return "";
    },
    monthDayName(model) {
      return model.label;
    },
    weekDayName(model) {
      const classDate = cls("day-name__date");
      const className2 = cls("day-name__name");
      return /* @__PURE__ */ y$3(g$2, null, /* @__PURE__ */ y$3("span", {
        className: classDate
      }, model.date), "\xA0\xA0", /* @__PURE__ */ y$3("span", {
        className: className2
      }, model.dayName));
    },
    weekGridFooterExceed(hiddenEvents) {
      return `+${hiddenEvents}`;
    },
    collapseBtnTitle() {
      const className2 = cls("collapse-btn-icon");
      return /* @__PURE__ */ y$3("span", {
        className: className2
      });
    },
    timezoneDisplayLabel({ displayLabel, timezoneOffset }) {
      if (isNil(displayLabel) && isPresent(timezoneOffset)) {
        const sign = timezoneOffset < 0 ? "-" : "+";
        const hours = Math.abs(timezoneOffset / SIXTY_MINUTES);
        const minutes = Math.abs(timezoneOffset % SIXTY_MINUTES);
        return `GMT${sign}${leadingZero(hours, 2)}:${leadingZero(minutes, 2)}`;
      }
      return displayLabel;
    },
    timegridDisplayPrimaryTime(props) {
      const { time } = props;
      return toFormat(time, "hh tt");
    },
    timegridDisplayTime(props) {
      const { time } = props;
      return toFormat(time, "HH:mm");
    },
    timegridNowIndicatorLabel(timezone) {
      const { time, format = "HH:mm" } = timezone;
      return toFormat(time, format);
    },
    popupIsAllday() {
      return "All day";
    },
    popupStateFree() {
      return "Free";
    },
    popupStateBusy() {
      return "Busy";
    },
    titlePlaceholder() {
      return "Subject";
    },
    locationPlaceholder() {
      return "Location";
    },
    startDatePlaceholder() {
      return "Start date";
    },
    endDatePlaceholder() {
      return "End date";
    },
    popupSave() {
      return "Save";
    },
    popupUpdate() {
      return "Update";
    },
    popupEdit() {
      return "Edit";
    },
    popupDelete() {
      return "Delete";
    },
    popupDetailTitle({ title }) {
      return title;
    },
    popupDetailDate({ isAllday: isAllday2, start, end }) {
      const dayFormat = "YYYY.MM.DD";
      const timeFormat = "hh:mm tt";
      const detailFormat = `${dayFormat} ${timeFormat}`;
      const startDate = toFormat(start, isAllday2 ? dayFormat : timeFormat);
      const endDateFormat = isSameDate(start, end) ? timeFormat : detailFormat;
      if (isAllday2) {
        return `${startDate}${isSameDate(start, end) ? "" : ` - ${toFormat(end, dayFormat)}`}`;
      }
      return `${toFormat(start, detailFormat)} - ${toFormat(end, endDateFormat)}`;
    },
    popupDetailLocation({ location: location2 }) {
      return location2;
    },
    popupDetailAttendees({ attendees = [] }) {
      return attendees.join(", ");
    },
    popupDetailState({ state }) {
      return state || "Busy";
    },
    popupDetailRecurrenceRule({ recurrenceRule }) {
      return recurrenceRule;
    },
    popupDetailBody({ body }) {
      return body;
    }
  };
  function createTemplateSlice(templateConfig = {}) {
    return {
      template: __spreadValues(__spreadValues({}, templates), templateConfig)
    };
  }
  function createTemplateDispatchers(set) {
    return {
      setTemplate: (template) => set(
        produce((state) => {
          state.template = __spreadValues(__spreadValues({}, state.template), template);
        })
      )
    };
  }
  function createViewSlice(initialView = "week") {
    const renderDate = new TZDate();
    renderDate.setHours(0, 0, 0, 0);
    return {
      view: {
        currentView: initialView,
        renderDate
      }
    };
  }
  function createViewDispatchers(set) {
    return {
      changeView: (nextView) => set(
        produce((state) => {
          state.view.currentView = nextView;
        })
      ),
      setRenderDate: (date2) => set(
        produce((state) => {
          state.view.renderDate = toStartOfDay(date2);
        })
      )
    };
  }
  const isSSR = isUndefined_1(window) || !window.navigator;
  const useIsomorphicLayoutEffect = isSSR ? _$2 : A$2;
  function createStoreContext() {
    const StoreContext = E$2(null);
    function StoreProvider2({
      children,
      store
    }) {
      return y$3(StoreContext.Provider, { value: store, children });
    }
    const useStore2 = (selector, equalityFn = Object.is) => {
      const storeCtx = P$2(StoreContext);
      if (isNil(storeCtx)) {
        throw new Error("StoreProvider is not found");
      }
      const [, notify] = y$2((notifyCount) => notifyCount + 1, 0);
      const state = storeCtx.getState();
      const stateRef = F$2(state);
      const selectorRef = F$2(selector);
      const equalityFnRef = F$2(equalityFn);
      const hasErrorRef = F$2(false);
      const currentSliceRef = F$2();
      if (isUndefined_1(currentSliceRef.current)) {
        currentSliceRef.current = selector(state);
      }
      let newStateSlice;
      let hasNewStateSlice = false;
      const shouldGetNewSlice = stateRef.current !== state || selectorRef.current !== selector || equalityFnRef.current !== equalityFn || hasErrorRef.current;
      if (shouldGetNewSlice) {
        newStateSlice = selector(state);
        hasNewStateSlice = !equalityFn(currentSliceRef.current, newStateSlice);
      }
      useIsomorphicLayoutEffect(() => {
        if (hasNewStateSlice) {
          currentSliceRef.current = newStateSlice;
        }
        stateRef.current = state;
        selectorRef.current = selector;
        equalityFnRef.current = equalityFn;
        hasErrorRef.current = false;
      });
      const stateBeforeSubscriptionRef = F$2(state);
      useIsomorphicLayoutEffect(() => {
        const listener = () => {
          try {
            const nextState = storeCtx.getState();
            const nextStateSlice = selectorRef.current(nextState);
            const shouldUpdateState = !equalityFnRef.current(
              currentSliceRef.current,
              nextStateSlice
            );
            if (shouldUpdateState) {
              stateRef.current = nextState;
              currentSliceRef.current = newStateSlice;
              notify();
            }
          } catch (e2) {
            console.error("[toastui-calendar] failed to update state", e2 == null ? void 0 : e2.message);
            hasErrorRef.current = true;
            notify();
          }
        };
        const unsubscribe = storeCtx.subscribe(listener);
        if (storeCtx.getState() !== stateBeforeSubscriptionRef.current) {
          listener();
        }
        return unsubscribe;
      }, []);
      return hasNewStateSlice ? newStateSlice : currentSliceRef.current;
    };
    const useInternalStore2 = () => {
      const storeCtx = P$2(StoreContext);
      if (isNil(storeCtx)) {
        throw new Error("StoreProvider is not found");
      }
      return q$1(() => storeCtx, [storeCtx]);
    };
    return {
      StoreProvider: StoreProvider2,
      useStore: useStore2,
      useInternalStore: useInternalStore2
    };
  }
  function createStore(storeCreator2) {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partialStateCreator) => {
      const nextState = partialStateCreator(state);
      if (nextState !== state) {
        const previousState = state;
        state = __spreadValues(__spreadValues({}, state), nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const subscribe = (listener, selector, equalityFn) => {
      let _listener = listener;
      if (selector) {
        let currentSlice = selector(state);
        const _equalityFn = equalityFn != null ? equalityFn : Object.is;
        _listener = () => {
          const nextSlice = selector(state);
          if (!_equalityFn(currentSlice, nextSlice)) {
            const previousSlice = currentSlice;
            currentSlice = nextSlice;
            listener(currentSlice, previousSlice);
          }
        };
      }
      listeners.add(_listener);
      return () => listeners.delete(_listener);
    };
    const clearListeners = () => listeners.clear();
    const internal = { setState, getState, subscribe, clearListeners };
    state = storeCreator2(setState, getState, internal);
    return internal;
  }
  const storeCreator = (options) => (set) => {
    return __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, createOptionsSlice(options)), createTemplateSlice(options.template)), createPopupSlice()), createWeekViewLayoutSlice()), createCalendarSlice(options.calendars)), createViewSlice(options.defaultView)), createDndSlice()), createGridSelectionSlice()), {
      dispatch: {
        options: createOptionsDispatchers(set),
        popup: createPopupDispatchers(set),
        weekViewLayout: createWeekViewLayoutDispatchers(set),
        calendar: createCalendarDispatchers(set),
        view: createViewDispatchers(set),
        dnd: createDndDispatchers(set),
        gridSelection: createGridSelectionDispatchers(set),
        template: createTemplateDispatchers(set)
      }
    });
  };
  const initCalendarStore = (options = {}) => createStore(storeCreator(options));
  const { StoreProvider, useStore, useInternalStore } = createStoreContext();
  function useDispatch(group) {
    return useStore(
      x$3(
        (state) => {
          if (!group) {
            return state.dispatch;
          }
          return state.dispatch[group];
        },
        [group]
      )
    );
  }
  function topLevelStateSelector(group) {
    return (state) => state[group];
  }
  const calendarSelector = topLevelStateSelector("calendar");
  const weekViewLayoutSelector = topLevelStateSelector(
    "weekViewLayout"
  );
  const templateSelector = topLevelStateSelector("template");
  const viewSelector = topLevelStateSelector("view");
  const optionsSelector = topLevelStateSelector("options");
  const dndSelector = topLevelStateSelector("dnd");
  var purify = { exports: {} };
  /*! @license DOMPurify 2.4.9 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.9/LICENSE */
  (function(module, exports) {
    (function(global2, factory) {
      module.exports = factory();
    })(commonjsGlobal, function() {
      function _typeof(obj) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof(obj);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e2) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a2 = [null];
            a2.push.apply(a2, args2);
            var Constructor2 = Function.bind.apply(Parent2, a2);
            var instance = new Constructor2();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray(arr);
      }
      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
          return Array.from(iter);
      }
      function _unsupportedIterableToArray(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray(o2, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
          arr2[i2] = arr[i2];
        return arr2;
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var freeze = Object.freeze, seal = Object.seal, create = Object.create;
      var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
      if (!apply) {
        apply = function apply2(fun, thisValue, args) {
          return fun.apply(thisValue, args);
        };
      }
      if (!freeze) {
        freeze = function freeze2(x2) {
          return x2;
        };
      }
      if (!seal) {
        seal = function seal2(x2) {
          return x2;
        };
      }
      if (!construct) {
        construct = function construct2(Func, args) {
          return _construct(Func, _toConsumableArray(args));
        };
      }
      var arrayForEach = unapply(Array.prototype.forEach);
      var arrayPop = unapply(Array.prototype.pop);
      var arrayPush = unapply(Array.prototype.push);
      var stringToLowerCase = unapply(String.prototype.toLowerCase);
      var stringToString = unapply(String.prototype.toString);
      var stringMatch = unapply(String.prototype.match);
      var stringReplace = unapply(String.prototype.replace);
      var stringIndexOf = unapply(String.prototype.indexOf);
      var stringTrim = unapply(String.prototype.trim);
      var regExpTest = unapply(RegExp.prototype.test);
      var typeErrorCreate = unconstruct(TypeError);
      function unapply(func) {
        return function(thisArg) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return apply(func, thisArg, args);
        };
      }
      function unconstruct(func) {
        return function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return construct(func, args);
        };
      }
      function addToSet(set, array2, transformCaseFunc) {
        var _transformCaseFunc;
        transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;
        if (setPrototypeOf) {
          setPrototypeOf(set, null);
        }
        var l2 = array2.length;
        while (l2--) {
          var element = array2[l2];
          if (typeof element === "string") {
            var lcElement = transformCaseFunc(element);
            if (lcElement !== element) {
              if (!isFrozen(array2)) {
                array2[l2] = lcElement;
              }
              element = lcElement;
            }
          }
          set[element] = true;
        }
        return set;
      }
      function clone2(object) {
        var newObject = create(null);
        var property;
        for (property in object) {
          if (apply(hasOwnProperty, object, [property]) === true) {
            newObject[property] = object[property];
          }
        }
        return newObject;
      }
      function lookupGetter(object, prop) {
        while (object !== null) {
          var desc = getOwnPropertyDescriptor(object, prop);
          if (desc) {
            if (desc.get) {
              return unapply(desc.get);
            }
            if (typeof desc.value === "function") {
              return unapply(desc.value);
            }
          }
          object = getPrototypeOf(object);
        }
        function fallbackValue(element) {
          console.warn("fallback value for", element);
          return null;
        }
        return fallbackValue;
      }
      var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
      var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
      var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
      var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
      var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
      var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
      var text = freeze(["#text"]);
      var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
      var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
      var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
      var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
      var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
      var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
      var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
      var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
      var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
      var IS_ALLOWED_URI = seal(
        /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
      );
      var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
      var ATTR_WHITESPACE = seal(
        /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
      );
      var DOCTYPE_NAME = seal(/^html$/i);
      var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
      var getGlobal = function getGlobal2() {
        return typeof window === "undefined" ? null : window;
      };
      var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
        if (_typeof(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
          return null;
        }
        var suffix = null;
        var ATTR_NAME = "data-tt-policy-suffix";
        if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
          suffix = document2.currentScript.getAttribute(ATTR_NAME);
        }
        var policyName = "dompurify" + (suffix ? "#" + suffix : "");
        try {
          return trustedTypes.createPolicy(policyName, {
            createHTML: function createHTML(html2) {
              return html2;
            },
            createScriptURL: function createScriptURL(scriptUrl) {
              return scriptUrl;
            }
          });
        } catch (_2) {
          console.warn("TrustedTypes policy " + policyName + " could not be created.");
          return null;
        }
      };
      function createDOMPurify() {
        var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
        var DOMPurify = function DOMPurify2(root) {
          return createDOMPurify(root);
        };
        DOMPurify.version = "2.4.9";
        DOMPurify.removed = [];
        if (!window2 || !window2.document || window2.document.nodeType !== 9) {
          DOMPurify.isSupported = false;
          return DOMPurify;
        }
        var originalDocument = window2.document;
        var document2 = window2.document;
        var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node = window2.Node, Element2 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser = window2.DOMParser, trustedTypes = window2.trustedTypes;
        var ElementPrototype = Element2.prototype;
        var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
        var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
        var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
        var getParentNode = lookupGetter(ElementPrototype, "parentNode");
        if (typeof HTMLTemplateElement === "function") {
          var template = document2.createElement("template");
          if (template.content && template.content.ownerDocument) {
            document2 = template.content.ownerDocument;
          }
        }
        var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
        var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
        var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
        var importNode = originalDocument.importNode;
        var documentMode = {};
        try {
          documentMode = clone2(document2).documentMode ? document2.documentMode : {};
        } catch (_2) {
        }
        var hooks = {};
        DOMPurify.isSupported = typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0 && documentMode !== 9;
        var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, TMPLIT_EXPR$1 = TMPLIT_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE, CUSTOM_ELEMENT$1 = CUSTOM_ELEMENT;
        var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
        var ALLOWED_TAGS = null;
        var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
        var ALLOWED_ATTR = null;
        var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
        var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
          tagNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          attributeNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          allowCustomizedBuiltInElements: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: false
          }
        }));
        var FORBID_TAGS = null;
        var FORBID_ATTR = null;
        var ALLOW_ARIA_ATTR = true;
        var ALLOW_DATA_ATTR = true;
        var ALLOW_UNKNOWN_PROTOCOLS = false;
        var ALLOW_SELF_CLOSE_IN_ATTR = true;
        var SAFE_FOR_TEMPLATES = false;
        var WHOLE_DOCUMENT = false;
        var SET_CONFIG = false;
        var FORCE_BODY = false;
        var RETURN_DOM = false;
        var RETURN_DOM_FRAGMENT = false;
        var RETURN_TRUSTED_TYPE = false;
        var SANITIZE_DOM = true;
        var SANITIZE_NAMED_PROPS = false;
        var SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
        var KEEP_CONTENT = true;
        var IN_PLACE = false;
        var USE_PROFILES = {};
        var FORBID_CONTENTS = null;
        var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
        var DATA_URI_TAGS = null;
        var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
        var URI_SAFE_ATTRIBUTES = null;
        var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
        var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var NAMESPACE = HTML_NAMESPACE;
        var IS_EMPTY_INPUT = false;
        var ALLOWED_NAMESPACES = null;
        var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
        var PARSER_MEDIA_TYPE;
        var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
        var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
        var transformCaseFunc;
        var CONFIG = null;
        var formElement = document2.createElement("form");
        var isRegexOrFunction = function isRegexOrFunction2(testValue) {
          return testValue instanceof RegExp || testValue instanceof Function;
        };
        var _parseConfig = function _parseConfig2(cfg) {
          if (CONFIG && CONFIG === cfg) {
            return;
          }
          if (!cfg || _typeof(cfg) !== "object") {
            cfg = {};
          }
          cfg = clone2(cfg);
          PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
          transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
          ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
          ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
          ALLOWED_NAMESPACES = "ALLOWED_NAMESPACES" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
          URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
            clone2(DEFAULT_URI_SAFE_ATTRIBUTES),
            cfg.ADD_URI_SAFE_ATTR,
            transformCaseFunc
          ) : DEFAULT_URI_SAFE_ATTRIBUTES;
          DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
            clone2(DEFAULT_DATA_URI_TAGS),
            cfg.ADD_DATA_URI_TAGS,
            transformCaseFunc
          ) : DEFAULT_DATA_URI_TAGS;
          FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
          FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
          FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
          USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
          ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
          ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
          ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
          ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
          SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
          WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
          RETURN_DOM = cfg.RETURN_DOM || false;
          RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
          RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
          FORCE_BODY = cfg.FORCE_BODY || false;
          SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
          SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
          KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
          IN_PLACE = cfg.IN_PLACE || false;
          IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
          NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
          CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
          }
          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
          }
          if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
          }
          if (SAFE_FOR_TEMPLATES) {
            ALLOW_DATA_ATTR = false;
          }
          if (RETURN_DOM_FRAGMENT) {
            RETURN_DOM = true;
          }
          if (USE_PROFILES) {
            ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
            ALLOWED_ATTR = [];
            if (USE_PROFILES.html === true) {
              addToSet(ALLOWED_TAGS, html$1);
              addToSet(ALLOWED_ATTR, html);
            }
            if (USE_PROFILES.svg === true) {
              addToSet(ALLOWED_TAGS, svg$1);
              addToSet(ALLOWED_ATTR, svg);
              addToSet(ALLOWED_ATTR, xml);
            }
            if (USE_PROFILES.svgFilters === true) {
              addToSet(ALLOWED_TAGS, svgFilters);
              addToSet(ALLOWED_ATTR, svg);
              addToSet(ALLOWED_ATTR, xml);
            }
            if (USE_PROFILES.mathMl === true) {
              addToSet(ALLOWED_TAGS, mathMl$1);
              addToSet(ALLOWED_ATTR, mathMl);
              addToSet(ALLOWED_ATTR, xml);
            }
          }
          if (cfg.ADD_TAGS) {
            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
              ALLOWED_TAGS = clone2(ALLOWED_TAGS);
            }
            addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
          }
          if (cfg.ADD_ATTR) {
            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
              ALLOWED_ATTR = clone2(ALLOWED_ATTR);
            }
            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
          }
          if (cfg.ADD_URI_SAFE_ATTR) {
            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
          }
          if (cfg.FORBID_CONTENTS) {
            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
              FORBID_CONTENTS = clone2(FORBID_CONTENTS);
            }
            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
          }
          if (KEEP_CONTENT) {
            ALLOWED_TAGS["#text"] = true;
          }
          if (WHOLE_DOCUMENT) {
            addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
          }
          if (ALLOWED_TAGS.table) {
            addToSet(ALLOWED_TAGS, ["tbody"]);
            delete FORBID_TAGS.tbody;
          }
          if (freeze) {
            freeze(cfg);
          }
          CONFIG = cfg;
        };
        var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
        var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
        var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
        var ALL_SVG_TAGS = addToSet({}, svg$1);
        addToSet(ALL_SVG_TAGS, svgFilters);
        addToSet(ALL_SVG_TAGS, svgDisallowed);
        var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
        addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
        var _checkValidNamespace = function _checkValidNamespace2(element) {
          var parent = getParentNode(element);
          if (!parent || !parent.tagName) {
            parent = {
              namespaceURI: NAMESPACE,
              tagName: "template"
            };
          }
          var tagName = stringToLowerCase(element.tagName);
          var parentTagName = stringToLowerCase(parent.tagName);
          if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
            return false;
          }
          if (element.namespaceURI === SVG_NAMESPACE) {
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === "svg";
            }
            if (parent.namespaceURI === MATHML_NAMESPACE) {
              return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
            }
            return Boolean(ALL_SVG_TAGS[tagName]);
          }
          if (element.namespaceURI === MATHML_NAMESPACE) {
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === "math";
            }
            if (parent.namespaceURI === SVG_NAMESPACE) {
              return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
            }
            return Boolean(ALL_MATHML_TAGS[tagName]);
          }
          if (element.namespaceURI === HTML_NAMESPACE) {
            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
              return false;
            }
            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
              return false;
            }
            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
          }
          if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
            return true;
          }
          return false;
        };
        var _forceRemove = function _forceRemove2(node) {
          arrayPush(DOMPurify.removed, {
            element: node
          });
          try {
            node.parentNode.removeChild(node);
          } catch (_2) {
            try {
              node.outerHTML = emptyHTML;
            } catch (_3) {
              node.remove();
            }
          }
        };
        var _removeAttribute = function _removeAttribute2(name, node) {
          try {
            arrayPush(DOMPurify.removed, {
              attribute: node.getAttributeNode(name),
              from: node
            });
          } catch (_2) {
            arrayPush(DOMPurify.removed, {
              attribute: null,
              from: node
            });
          }
          node.removeAttribute(name);
          if (name === "is" && !ALLOWED_ATTR[name]) {
            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
              try {
                _forceRemove(node);
              } catch (_2) {
              }
            } else {
              try {
                node.setAttribute(name, "");
              } catch (_2) {
              }
            }
          }
        };
        var _initDocument = function _initDocument2(dirty) {
          var doc;
          var leadingWhitespace;
          if (FORCE_BODY) {
            dirty = "<remove></remove>" + dirty;
          } else {
            var matches = stringMatch(dirty, /^[\r\n\t ]+/);
            leadingWhitespace = matches && matches[0];
          }
          if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
            dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
          }
          var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
          if (NAMESPACE === HTML_NAMESPACE) {
            try {
              doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
            } catch (_2) {
            }
          }
          if (!doc || !doc.documentElement) {
            doc = implementation.createDocument(NAMESPACE, "template", null);
            try {
              doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
            } catch (_2) {
            }
          }
          var body = doc.body || doc.documentElement;
          if (dirty && leadingWhitespace) {
            body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
          }
          if (NAMESPACE === HTML_NAMESPACE) {
            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
          }
          return WHOLE_DOCUMENT ? doc.documentElement : body;
        };
        var _createIterator = function _createIterator2(root) {
          return createNodeIterator.call(
            root.ownerDocument || root,
            root,
            NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
            null,
            false
          );
        };
        var _isClobbered = function _isClobbered2(elm) {
          return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
        };
        var _isNode = function _isNode2(object) {
          return _typeof(Node) === "object" ? object instanceof Node : object && _typeof(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
        };
        var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
          if (!hooks[entryPoint]) {
            return;
          }
          arrayForEach(hooks[entryPoint], function(hook) {
            hook.call(DOMPurify, currentNode, data, CONFIG);
          });
        };
        var _sanitizeElements = function _sanitizeElements2(currentNode) {
          var content;
          _executeHook("beforeSanitizeElements", currentNode, null);
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
            return true;
          }
          if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
            _forceRemove(currentNode);
            return true;
          }
          var tagName = transformCaseFunc(currentNode.nodeName);
          _executeHook("uponSanitizeElement", currentNode, {
            tagName,
            allowedTags: ALLOWED_TAGS
          });
          if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
            _forceRemove(currentNode);
            return true;
          }
          if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);
            return true;
          }
          if (currentNode.nodeType === 7) {
            _forceRemove(currentNode);
            return true;
          }
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
                return false;
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
                return false;
            }
            if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
              var parentNode = getParentNode(currentNode) || currentNode.parentNode;
              var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
              if (childNodes && parentNode) {
                var childCount = childNodes.length;
                for (var i2 = childCount - 1; i2 >= 0; --i2) {
                  parentNode.insertBefore(cloneNode(childNodes[i2], true), getNextSibling(currentNode));
                }
              }
            }
            _forceRemove(currentNode);
            return true;
          }
          if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
            _forceRemove(currentNode);
            return true;
          }
          if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);
            return true;
          }
          if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
            content = currentNode.textContent;
            content = stringReplace(content, MUSTACHE_EXPR$1, " ");
            content = stringReplace(content, ERB_EXPR$1, " ");
            content = stringReplace(content, TMPLIT_EXPR$1, " ");
            if (currentNode.textContent !== content) {
              arrayPush(DOMPurify.removed, {
                element: currentNode.cloneNode()
              });
              currentNode.textContent = content;
            }
          }
          _executeHook("afterSanitizeElements", currentNode, null);
          return false;
        };
        var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
          if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
            return false;
          }
          if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
            ;
          else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
            ;
          else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
            if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))
              ;
            else {
              return false;
            }
          } else if (URI_SAFE_ATTRIBUTES[lcName])
            ;
          else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
            ;
          else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
            ;
          else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
            ;
          else if (value) {
            return false;
          } else
            ;
          return true;
        };
        var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
          return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT$1);
        };
        var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
          var attr;
          var value;
          var lcName;
          var l2;
          _executeHook("beforeSanitizeAttributes", currentNode, null);
          var attributes = currentNode.attributes;
          if (!attributes) {
            return;
          }
          var hookEvent = {
            attrName: "",
            attrValue: "",
            keepAttr: true,
            allowedAttributes: ALLOWED_ATTR
          };
          l2 = attributes.length;
          while (l2--) {
            attr = attributes[l2];
            var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
            value = name === "value" ? attr.value : stringTrim(attr.value);
            lcName = transformCaseFunc(name);
            hookEvent.attrName = lcName;
            hookEvent.attrValue = value;
            hookEvent.keepAttr = true;
            hookEvent.forceKeepAttr = void 0;
            _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
            value = hookEvent.attrValue;
            if (hookEvent.forceKeepAttr) {
              continue;
            }
            _removeAttribute(name, currentNode);
            if (!hookEvent.keepAttr) {
              continue;
            }
            if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
              _removeAttribute(name, currentNode);
              continue;
            }
            if (SAFE_FOR_TEMPLATES) {
              value = stringReplace(value, MUSTACHE_EXPR$1, " ");
              value = stringReplace(value, ERB_EXPR$1, " ");
              value = stringReplace(value, TMPLIT_EXPR$1, " ");
            }
            var lcTag = transformCaseFunc(currentNode.nodeName);
            if (!_isValidAttribute(lcTag, lcName, value)) {
              continue;
            }
            if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
              _removeAttribute(name, currentNode);
              value = SANITIZE_NAMED_PROPS_PREFIX + value;
            }
            if (trustedTypesPolicy && _typeof(trustedTypes) === "object" && typeof trustedTypes.getAttributeType === "function") {
              if (namespaceURI)
                ;
              else {
                switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                  case "TrustedHTML": {
                    value = trustedTypesPolicy.createHTML(value);
                    break;
                  }
                  case "TrustedScriptURL": {
                    value = trustedTypesPolicy.createScriptURL(value);
                    break;
                  }
                }
              }
            }
            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name, value);
              } else {
                currentNode.setAttribute(name, value);
              }
              arrayPop(DOMPurify.removed);
            } catch (_2) {
            }
          }
          _executeHook("afterSanitizeAttributes", currentNode, null);
        };
        var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
          var shadowNode;
          var shadowIterator = _createIterator(fragment);
          _executeHook("beforeSanitizeShadowDOM", fragment, null);
          while (shadowNode = shadowIterator.nextNode()) {
            _executeHook("uponSanitizeShadowNode", shadowNode, null);
            if (_sanitizeElements(shadowNode)) {
              continue;
            }
            if (shadowNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM2(shadowNode.content);
            }
            _sanitizeAttributes(shadowNode);
          }
          _executeHook("afterSanitizeShadowDOM", fragment, null);
        };
        DOMPurify.sanitize = function(dirty) {
          var cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var body;
          var importedNode;
          var currentNode;
          var oldNode;
          var returnNode;
          IS_EMPTY_INPUT = !dirty;
          if (IS_EMPTY_INPUT) {
            dirty = "<!-->";
          }
          if (typeof dirty !== "string" && !_isNode(dirty)) {
            if (typeof dirty.toString === "function") {
              dirty = dirty.toString();
              if (typeof dirty !== "string") {
                throw typeErrorCreate("dirty is not a string, aborting");
              }
            } else {
              throw typeErrorCreate("toString is not a function");
            }
          }
          if (!DOMPurify.isSupported) {
            if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
              if (typeof dirty === "string") {
                return window2.toStaticHTML(dirty);
              }
              if (_isNode(dirty)) {
                return window2.toStaticHTML(dirty.outerHTML);
              }
            }
            return dirty;
          }
          if (!SET_CONFIG) {
            _parseConfig(cfg);
          }
          DOMPurify.removed = [];
          if (typeof dirty === "string") {
            IN_PLACE = false;
          }
          if (IN_PLACE) {
            if (dirty.nodeName) {
              var tagName = transformCaseFunc(dirty.nodeName);
              if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
              }
            }
          } else if (dirty instanceof Node) {
            body = _initDocument("<!---->");
            importedNode = body.ownerDocument.importNode(dirty, true);
            if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
              body = importedNode;
            } else if (importedNode.nodeName === "HTML") {
              body = importedNode;
            } else {
              body.appendChild(importedNode);
            }
          } else {
            if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
              return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
            }
            body = _initDocument(dirty);
            if (!body) {
              return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
            }
          }
          if (body && FORCE_BODY) {
            _forceRemove(body.firstChild);
          }
          var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
          while (currentNode = nodeIterator.nextNode()) {
            if (currentNode.nodeType === 3 && currentNode === oldNode) {
              continue;
            }
            if (_sanitizeElements(currentNode)) {
              continue;
            }
            if (currentNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM(currentNode.content);
            }
            _sanitizeAttributes(currentNode);
            oldNode = currentNode;
          }
          oldNode = null;
          if (IN_PLACE) {
            return dirty;
          }
          if (RETURN_DOM) {
            if (RETURN_DOM_FRAGMENT) {
              returnNode = createDocumentFragment.call(body.ownerDocument);
              while (body.firstChild) {
                returnNode.appendChild(body.firstChild);
              }
            } else {
              returnNode = body;
            }
            if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
              returnNode = importNode.call(originalDocument, returnNode, true);
            }
            return returnNode;
          }
          var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
          if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
            serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
          }
          if (SAFE_FOR_TEMPLATES) {
            serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
            serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
            serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$1, " ");
          }
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
        };
        DOMPurify.setConfig = function(cfg) {
          _parseConfig(cfg);
          SET_CONFIG = true;
        };
        DOMPurify.clearConfig = function() {
          CONFIG = null;
          SET_CONFIG = false;
        };
        DOMPurify.isValidAttribute = function(tag, attr, value) {
          if (!CONFIG) {
            _parseConfig({});
          }
          var lcTag = transformCaseFunc(tag);
          var lcName = transformCaseFunc(attr);
          return _isValidAttribute(lcTag, lcName, value);
        };
        DOMPurify.addHook = function(entryPoint, hookFunction) {
          if (typeof hookFunction !== "function") {
            return;
          }
          hooks[entryPoint] = hooks[entryPoint] || [];
          arrayPush(hooks[entryPoint], hookFunction);
        };
        DOMPurify.removeHook = function(entryPoint) {
          if (hooks[entryPoint]) {
            return arrayPop(hooks[entryPoint]);
          }
        };
        DOMPurify.removeHooks = function(entryPoint) {
          if (hooks[entryPoint]) {
            hooks[entryPoint] = [];
          }
        };
        DOMPurify.removeAllHooks = function() {
          hooks = {};
        };
        return DOMPurify;
      }
      var purify2 = createDOMPurify();
      return purify2;
    });
  })(purify);
  var browser = window.DOMPurify || (window.DOMPurify = purify.exports.default || purify.exports);
  const TEMP_TARGET_ATTRIBUTE = "data-target-temp";
  function addAttributeHooks() {
    browser.addHook("beforeSanitizeAttributes", (node) => {
      if (node.tagName === "A") {
        const targetValue = node.getAttribute("target");
        if (targetValue) {
          node.setAttribute(TEMP_TARGET_ATTRIBUTE, targetValue);
        } else {
          node.setAttribute("target", "_self");
        }
      }
    });
    browser.addHook("afterSanitizeAttributes", (node) => {
      if (node.tagName === "A" && node.hasAttribute(TEMP_TARGET_ATTRIBUTE)) {
        node.setAttribute("target", node.getAttribute(TEMP_TARGET_ATTRIBUTE));
        node.removeAttribute(TEMP_TARGET_ATTRIBUTE);
        if (node.getAttribute("target") === "_blank") {
          node.setAttribute("rel", "noopener");
        }
      }
    });
  }
  function removeAttributeHooks() {
    browser.removeAllHooks();
  }
  function sanitize(str) {
    return browser.sanitize(str);
  }
  function Template({ template, param, as: tagName = "div" }) {
    var _a;
    const templates2 = useStore(templateSelector);
    const templateFunc = templates2[template];
    if (isNil(templateFunc)) {
      return null;
    }
    const htmlOrVnode = templateFunc(param);
    return isString_1(htmlOrVnode) ? y$3(tagName, {
      className: cls(`template-${template}`),
      dangerouslySetInnerHTML: {
        __html: sanitize(htmlOrVnode)
      }
    }) : B$3(htmlOrVnode, {
      className: `${(_a = htmlOrVnode.props.className) != null ? _a : ""} ${cls(`template-${template}`)}`
    });
  }
  const EventBusContext = E$2(
    null
  );
  const EventBusProvider = EventBusContext.Provider;
  const useEventBus = () => {
    const eventBus = P$2(EventBusContext);
    if (!eventBus) {
      throw new Error("useEventBus must be used within a EventBusProvider");
    }
    return eventBus;
  };
  const primaryTimezoneSelector = (state) => {
    var _a, _b, _c, _d, _e;
    return (_e = (_d = (_c = (_b = (_a = state.options) == null ? void 0 : _a.timezone) == null ? void 0 : _b.zones) == null ? void 0 : _c[0]) == null ? void 0 : _d.timezoneName) != null ? _e : "Local";
  };
  const customOffsetCalculatorSelector = (state) => {
    var _a, _b;
    return (_b = (_a = state.options) == null ? void 0 : _a.timezone) == null ? void 0 : _b.customOffsetCalculator;
  };
  const timezonesSelector = (state) => {
    var _a;
    return (_a = state.options.timezone.zones) != null ? _a : [];
  };
  function useTZConverter() {
    const customOffsetCalculator = useStore(customOffsetCalculatorSelector);
    const hasCustomOffsetCalculator = isPresent(customOffsetCalculator);
    return x$3(
      (timezoneName, tzDate = new TZDate()) => tzDate.tz(
        hasCustomOffsetCalculator ? customOffsetCalculator(timezoneName, tzDate.getTime()) : timezoneName
      ),
      [customOffsetCalculator, hasCustomOffsetCalculator]
    );
  }
  function usePrimaryTimezone() {
    const primaryTimezoneName = useStore(primaryTimezoneSelector);
    const tzConverter = useTZConverter();
    const getNow = x$3(
      () => tzConverter(primaryTimezoneName),
      [primaryTimezoneName, tzConverter]
    );
    return [primaryTimezoneName, getNow];
  }
  function isWeekDayName(type, dayName) {
    return type === "week";
  }
  function getWeekDayNameColor({
    dayName,
    theme,
    today
  }) {
    var _a, _b;
    const { day, dateInstance } = dayName;
    const isToday = isSameDate(today, dateInstance);
    const isPastDay = !isToday && dateInstance < today;
    if (isSunday(day)) {
      return theme.common.holiday.color;
    }
    if (isPastDay) {
      return (_a = theme.week) == null ? void 0 : _a.pastDay.color;
    }
    if (isSaturday(day)) {
      return theme.common.saturday.color;
    }
    if (isToday) {
      return (_b = theme.week) == null ? void 0 : _b.today.color;
    }
    return theme.common.dayName.color;
  }
  function getMonthDayNameColor({
    dayName,
    theme
  }) {
    const { day } = dayName;
    if (isSunday(day)) {
      return theme.common.holiday.color;
    }
    if (isSaturday(day)) {
      return theme.common.saturday.color;
    }
    return theme.common.dayName.color;
  }
  function DayName({ dayName, style, type, theme }) {
    const eventBus = useEventBus();
    const [, getNow] = usePrimaryTimezone();
    const today = getNow();
    const { day } = dayName;
    const color = type === "week" ? getWeekDayNameColor({ dayName, theme, today }) : getMonthDayNameColor({ dayName, theme });
    const templateType = `${type}DayName`;
    const handleClick = () => {
      if (isWeekDayName(type)) {
        eventBus.fire("clickDayName", { date: toFormat(dayName.dateInstance, "YYYY-MM-DD") });
      }
    };
    return /* @__PURE__ */ y$3("div", {
      className: cls("day-name-item", type),
      style
    }, /* @__PURE__ */ y$3("span", {
      className: cls({ [`holiday-${getDayName(day)}`]: isWeekend(day) }),
      style: { color },
      onClick: handleClick,
      "data-testid": `dayName-${type}-${getDayName(day)}`
    }, /* @__PURE__ */ y$3(Template, {
      template: templateType,
      param: dayName
    })));
  }
  const commonThemeSelector = topLevelStateSelector("common");
  const monthThemeSelector = topLevelStateSelector("month");
  const weekDayGridLeftSelector = (theme) => theme.week.dayGridLeft;
  const weekTimeGridLeftSelector = (theme) => theme.week.timeGridLeft;
  const monthMoreViewSelector = (theme) => theme.month.moreView;
  const monthGridCellSelector = (theme) => theme.month.gridCell;
  const DEFAULT_COMMON_THEME = {
    border: "1px solid #e5e5e5",
    backgroundColor: "white",
    holiday: {
      color: "#ff4040"
    },
    saturday: {
      color: "#333"
    },
    dayName: {
      color: "#333"
    },
    today: {
      color: "#fff"
    },
    gridSelection: {
      backgroundColor: "rgba(81, 92, 230, 0.05)",
      border: "1px solid #515ce6"
    }
  };
  const DEFAULT_WEEK_THEME = {
    dayName: {
      borderLeft: "none",
      borderTop: "1px solid #e5e5e5",
      borderBottom: "1px solid #e5e5e5",
      backgroundColor: "inherit"
    },
    weekend: {
      backgroundColor: "inherit"
    },
    today: {
      color: "inherit",
      backgroundColor: "rgba(81, 92, 230, 0.05)"
    },
    pastDay: {
      color: "#bbb"
    },
    panelResizer: {
      border: "1px solid #e5e5e5"
    },
    dayGrid: {
      borderRight: "1px solid #e5e5e5",
      backgroundColor: "inherit"
    },
    dayGridLeft: {
      borderRight: "1px solid #e5e5e5",
      backgroundColor: "inherit",
      width: "72px"
    },
    timeGrid: {
      borderRight: "1px solid #e5e5e5"
    },
    timeGridLeft: {
      backgroundColor: "inherit",
      borderRight: "1px solid #e5e5e5",
      width: "72px"
    },
    timeGridLeftAdditionalTimezone: {
      backgroundColor: "white"
    },
    timeGridHalfHourLine: {
      borderBottom: "none"
    },
    timeGridHourLine: {
      borderBottom: "1px solid #e5e5e5"
    },
    nowIndicatorLabel: {
      color: "#515ce6"
    },
    nowIndicatorPast: {
      border: "1px dashed #515ce6"
    },
    nowIndicatorBullet: {
      backgroundColor: "#515ce6"
    },
    nowIndicatorToday: {
      border: "1px solid #515ce6"
    },
    nowIndicatorFuture: {
      border: "none"
    },
    pastTime: {
      color: "#bbb"
    },
    futureTime: {
      color: "#333"
    },
    gridSelection: {
      color: "#515ce6"
    }
  };
  const DEFAULT_MONTH_THEME = {
    dayName: {
      borderLeft: "none",
      backgroundColor: "inherit"
    },
    holidayExceptThisMonth: {
      color: "rgba(255, 64, 64, 0.4)"
    },
    dayExceptThisMonth: {
      color: "rgba(51, 51, 51, 0.4)"
    },
    weekend: {
      backgroundColor: "inherit"
    },
    moreView: {
      border: "1px solid #d5d5d5",
      boxShadow: "0 2px 6px 0 rgba(0, 0, 0, 0.1)",
      backgroundColor: "white",
      width: null,
      height: null
    },
    gridCell: {
      headerHeight: 31,
      footerHeight: null
    },
    moreViewTitle: {
      backgroundColor: "inherit"
    }
  };
  function createCommonTheme(commonTheme = {}) {
    return {
      common: mergeObject(DEFAULT_COMMON_THEME, commonTheme)
    };
  }
  function createThemeDispatch(set) {
    return {
      setTheme: (theme) => {
        set(
          produce((state) => {
            state.common = mergeObject(state.common, theme.common);
            state.week = mergeObject(state.week, theme.week);
            state.month = mergeObject(state.month, theme.month);
          })
        );
      },
      setCommonTheme: (commonTheme) => {
        set(
          produce((state) => {
            state.common = mergeObject(state.common, commonTheme);
          })
        );
      },
      setWeekTheme: (weekTheme) => {
        set(
          produce((state) => {
            state.week = mergeObject(state.week, weekTheme);
          })
        );
      },
      setMonthTheme: (monthTheme) => {
        set(
          produce((state) => {
            state.month = mergeObject(state.month, monthTheme);
          })
        );
      }
    };
  }
  function createMonthTheme(monthTheme = {}) {
    return {
      month: mergeObject(DEFAULT_MONTH_THEME, monthTheme)
    };
  }
  function createWeekTheme(weekTheme = {}) {
    return {
      week: mergeObject(DEFAULT_WEEK_THEME, weekTheme)
    };
  }
  const themeStoreCreator = (themeOptions = {}) => (set) => {
    return __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, createCommonTheme(themeOptions == null ? void 0 : themeOptions.common)), createWeekTheme(themeOptions == null ? void 0 : themeOptions.week)), createMonthTheme(themeOptions == null ? void 0 : themeOptions.month)), {
      dispatch: __spreadValues({}, createThemeDispatch(set))
    });
  };
  const initThemeStore = (themeOptions = {}) => createStore(themeStoreCreator(themeOptions));
  const {
    StoreProvider: ThemeProvider,
    useInternalStore: useInternalThemeStore,
    useStore: useTheme
  } = createStoreContext();
  function useCommonTheme() {
    return useTheme(commonThemeSelector);
  }
  function useMonthTheme() {
    return useTheme(monthThemeSelector);
  }
  function weekDayNameSelector(theme) {
    return {
      common: {
        saturday: theme.common.saturday,
        holiday: theme.common.holiday,
        today: theme.common.today,
        dayName: theme.common.dayName
      },
      week: {
        pastDay: theme.week.pastDay,
        today: theme.week.today,
        dayName: theme.week.dayName
      }
    };
  }
  function monthDayNameSelector(theme) {
    return {
      common: {
        saturday: theme.common.saturday,
        holiday: theme.common.holiday,
        today: theme.common.today,
        dayName: theme.common.dayName
      },
      month: {
        dayName: theme.month.dayName
      }
    };
  }
  function GridHeader({
    dayNames,
    marginLeft = DEFAULT_DAY_NAME_MARGIN_LEFT,
    rowStyleInfo,
    type = "month"
  }) {
    var _a, _b;
    const theme = useTheme(type === "month" ? monthDayNameSelector : weekDayNameSelector);
    const _c = (_b = (_a = theme[type]) == null ? void 0 : _a.dayName) != null ? _b : {}, { backgroundColor = "white", borderLeft = null } = _c, rest = __objRest(_c, ["backgroundColor", "borderLeft"]);
    const { borderTop = null, borderBottom = null } = rest;
    return /* @__PURE__ */ y$3("div", {
      "data-testid": `grid-header-${type}`,
      className: cls("day-names", type),
      style: {
        backgroundColor,
        borderTop,
        borderBottom
      }
    }, /* @__PURE__ */ y$3("div", {
      className: cls("day-name-container"),
      style: { marginLeft }
    }, dayNames.map((dayName, index) => /* @__PURE__ */ y$3(DayName, {
      type,
      key: `dayNames-${dayName.day}`,
      dayName,
      style: {
        width: toPercent(rowStyleInfo[index].width),
        left: toPercent(rowStyleInfo[index].left),
        borderLeft
      },
      theme
    }))));
  }
  const DEFAULT_VISIBLE_WEEKS = 6;
  var CellBarType = /* @__PURE__ */ ((CellBarType2) => {
    CellBarType2["header"] = "header";
    CellBarType2["footer"] = "footer";
    return CellBarType2;
  })(CellBarType || {});
  function getCollisionGroup(events, usingTravelTime = true) {
    const collisionGroups = [];
    let previousEventList;
    if (!events.length) {
      return collisionGroups;
    }
    collisionGroups[0] = [events[0].cid()];
    events.slice(1).forEach((event, index) => {
      previousEventList = events.slice(0, index + 1).reverse();
      const found = previousEventList.find(
        (previous) => event.collidesWith(previous, usingTravelTime)
      );
      if (!found) {
        collisionGroups.push([event.cid()]);
      } else {
        collisionGroups.slice().reverse().some((group) => {
          if (~group.indexOf(found.cid())) {
            group.push(event.cid());
            return true;
          }
          return false;
        });
      }
    });
    return collisionGroups;
  }
  function getLastRowInColumn(matrix, col) {
    let { length: row } = matrix;
    while (row > 0) {
      row -= 1;
      if (!isUndefined_1(matrix[row][col])) {
        return row;
      }
    }
    return -1;
  }
  function getMatrices(collection, collisionGroups, usingTravelTime = true) {
    const result = [];
    collisionGroups.forEach((group) => {
      const matrix = [[]];
      group.forEach((eventID) => {
        const event = collection.get(eventID);
        let col = 0;
        let found = false;
        let nextRow;
        let lastRowInColumn;
        while (!found) {
          lastRowInColumn = getLastRowInColumn(matrix, col);
          if (lastRowInColumn === -1) {
            matrix[0].push(event);
            found = true;
          } else if (!event.collidesWith(matrix[lastRowInColumn][col], usingTravelTime)) {
            nextRow = lastRowInColumn + 1;
            if (isUndefined_1(matrix[nextRow])) {
              matrix[nextRow] = [];
            }
            matrix[nextRow][col] = event;
            found = true;
          }
          col += 1;
        }
      });
      result.push(matrix);
    });
    return result;
  }
  function getEventInDateRangeFilter(start, end) {
    return (model) => {
      const ownStarts = model.getStarts();
      const ownEnds = model.getEnds();
      return !(ownEnds < start || ownStarts > end);
    };
  }
  function positionUIModels(start, end, matrices, iteratee) {
    const ymdListToRender = makeDateRange(start, end, MS_PER_DAY).map(
      (date2) => toFormat(date2, "YYYYMMDD")
    );
    matrices.forEach((matrix) => {
      matrix.forEach((column) => {
        column.forEach((uiModel, index) => {
          if (!uiModel) {
            return;
          }
          const ymd = toFormat(uiModel.getStarts(), "YYYYMMDD");
          const dateLength = makeDateRange(
            toStartOfDay(uiModel.getStarts()),
            toEndOfDay(uiModel.getEnds()),
            MS_PER_DAY
          ).length;
          uiModel.top = index;
          uiModel.left = ymdListToRender.indexOf(ymd);
          uiModel.width = dateLength;
          iteratee == null ? void 0 : iteratee(uiModel);
        });
      });
    });
  }
  function limit$1(start, end, uiModel) {
    if (uiModel.getStarts() < start) {
      uiModel.exceedLeft = true;
      uiModel.renderStarts = new TZDate(start);
    }
    if (uiModel.getEnds() > end) {
      uiModel.exceedRight = true;
      uiModel.renderEnds = new TZDate(end);
    }
    return uiModel;
  }
  function limitRenderRange(start, end, uiModelColl) {
    if (uiModelColl instanceof Collection) {
      uiModelColl.each((uiModel) => {
        limit$1(start, end, uiModel);
        return true;
      });
      return null;
    }
    return limit$1(start, end, uiModelColl);
  }
  function convertToUIModel(eventCollection) {
    const uiModelColl = new Collection((uiModel) => {
      return uiModel.cid();
    });
    eventCollection.each(function(event) {
      uiModelColl.add(new EventUIModel(event));
    });
    return uiModelColl;
  }
  function _isAllday({ model }) {
    return model.isAllday || model.hasMultiDates;
  }
  function _isNotAllday(uiModel) {
    return !_isAllday(uiModel);
  }
  function _weightTopValue(uiModel) {
    uiModel.top = uiModel.top || 0;
    uiModel.top += 1;
  }
  function _adjustRenderRange(start, end, uiModelColl) {
    uiModelColl.each((uiModel) => {
      if (uiModel.model.isAllday || uiModel.model.hasMultiDates) {
        limitRenderRange(toStartOfDay(start), toEndOfDay(end), uiModel);
      }
    });
  }
  function _getAlldayMaxTopIndexAtYMD(idsOfDay, ymd, uiModelAlldayColl) {
    const topIndexesInDate = [];
    idsOfDay[ymd].forEach((cid) => {
      uiModelAlldayColl.doWhenHas(cid, (uiModel) => {
        topIndexesInDate.push(uiModel.top);
      });
    });
    if (topIndexesInDate.length > 0) {
      return Math.max(...topIndexesInDate);
    }
    return 0;
  }
  function _adjustTimeTopIndex(idsOfDay, uiModelColl) {
    const vAlldayColl = uiModelColl.filter(_isAllday);
    const sortedTimeEvents = uiModelColl.filter(_isNotAllday).sort(array.compare.event.asc);
    const maxIndexInYMD = {};
    sortedTimeEvents.forEach((timeUIModel) => {
      const eventYMD = toFormat(timeUIModel.getStarts(), "YYYYMMDD");
      let alldayMaxTopInYMD = maxIndexInYMD[eventYMD];
      if (isUndefined_1(alldayMaxTopInYMD)) {
        alldayMaxTopInYMD = maxIndexInYMD[eventYMD] = _getAlldayMaxTopIndexAtYMD(
          idsOfDay,
          eventYMD,
          vAlldayColl
        );
      }
      maxIndexInYMD[eventYMD] = timeUIModel.top = alldayMaxTopInYMD + 1;
    });
  }
  function _stackTimeFromTop(idsOfDay, uiModelColl) {
    const uiModelAlldayColl = uiModelColl.filter(_isAllday);
    const sortedTimeEvents = uiModelColl.filter(_isNotAllday).sort(array.compare.event.asc);
    const indiceInYMD = {};
    sortedTimeEvents.forEach((timeUIModel) => {
      const eventYMD = toFormat(timeUIModel.getStarts(), "YYYYMMDD");
      let topArrayInYMD = indiceInYMD[eventYMD];
      if (isUndefined_1(topArrayInYMD)) {
        topArrayInYMD = indiceInYMD[eventYMD] = [];
        idsOfDay[eventYMD].forEach((cid) => {
          uiModelAlldayColl.doWhenHas(cid, (uiModel) => {
            topArrayInYMD.push(uiModel.top);
          });
        });
      }
      if (topArrayInYMD.indexOf(timeUIModel.top) >= 0) {
        const maxTopInYMD = Math.max(...topArrayInYMD) + 1;
        for (let i2 = 1; i2 <= maxTopInYMD; i2 += 1) {
          timeUIModel.top = i2;
          if (topArrayInYMD.indexOf(timeUIModel.top) < 0) {
            break;
          }
        }
      }
      topArrayInYMD.push(timeUIModel.top);
    });
  }
  function _addMultiDatesInfo$1(uiModelColl) {
    uiModelColl.each((uiModel) => {
      const { model } = uiModel;
      const start = model.getStarts();
      const end = model.getEnds();
      model.hasMultiDates = !isSameDate(start, end);
      if (!model.isAllday && model.hasMultiDates) {
        uiModel.renderStarts = toStartOfDay(start);
        uiModel.renderEnds = toEndOfDay(end);
      }
    });
  }
  function findByDateRange$1(calendarData, condition) {
    const { start, end, andFilters = [], alldayFirstMode = false } = condition;
    const { events, idsOfDay } = calendarData;
    const filterFn = Collection.and(...[getEventInDateRangeFilter(start, end)].concat(andFilters));
    const coll = events.filter(filterFn);
    const uiModelColl = convertToUIModel(coll);
    _addMultiDatesInfo$1(uiModelColl);
    _adjustRenderRange(start, end, uiModelColl);
    const vList = uiModelColl.sort(array.compare.event.asc);
    const usingTravelTime = false;
    const collisionGroup = getCollisionGroup(vList, usingTravelTime);
    const matrices = getMatrices(uiModelColl, collisionGroup, usingTravelTime);
    positionUIModels(start, end, matrices, _weightTopValue);
    if (alldayFirstMode) {
      _adjustTimeTopIndex(idsOfDay, uiModelColl);
    } else {
      _stackTimeFromTop(idsOfDay, uiModelColl);
    }
    return matrices;
  }
  function _makeHourRangeFilter(hStart, hEnd) {
    return (uiModel) => {
      const ownHourStart = uiModel.getStarts();
      const ownHourEnd = uiModel.getEnds();
      const ownHourStartTime = ownHourStart.getTime();
      const ownHourEndTime = ownHourEnd.getTime();
      const yyyy = ownHourStart.getFullYear();
      const mm = ownHourStart.getMonth();
      const dd = ownHourStart.getDate();
      const hourStart = new TZDate(yyyy, mm, dd).setHours(hStart);
      const hourEnd = new TZDate(yyyy, mm, dd).setHours(hEnd);
      return ownHourStartTime >= hourStart && ownHourStartTime < hourEnd || ownHourEndTime > hourStart && ownHourEndTime <= hourEnd || ownHourStartTime < hourStart && ownHourEndTime > hourStart || ownHourEndTime > hourEnd && ownHourStartTime < hourEnd;
    };
  }
  function _makeGetUIModelFuncForTimeView(hourStart, hourEnd) {
    if (hourStart === 0 && hourEnd === 24) {
      return (uiModelColl) => {
        return uiModelColl.sort(array.compare.event.asc);
      };
    }
    return (uiModelColl) => {
      return uiModelColl.filter(_makeHourRangeFilter(hourStart, hourEnd)).sort(array.compare.event.asc);
    };
  }
  function splitEventByDateRange(idsOfDay, start, end, uiModelColl) {
    const result = {};
    const range2 = getDateRange(start, end);
    range2.forEach((date2) => {
      const ymd = toFormat(date2, "YYYYMMDD");
      const ids = idsOfDay[ymd];
      const collection = result[ymd] = new Collection((event) => {
        return event.cid();
      });
      if (ids && ids.length) {
        ids.forEach((id) => {
          uiModelColl.doWhenHas(id, (event) => {
            collection.add(event);
          });
        });
      }
    }, {});
    return result;
  }
  function getUIModelForTimeView(idsOfDay, condition) {
    const { start, end, uiModelTimeColl, hourStart, hourEnd } = condition;
    const ymdSplitted = splitEventByDateRange(idsOfDay, start, end, uiModelTimeColl);
    const result = {};
    const _getUIModel = _makeGetUIModelFuncForTimeView(hourStart, hourEnd);
    const usingTravelTime = true;
    Object.entries(ymdSplitted).forEach(([ymd, uiModelColl]) => {
      const uiModels = _getUIModel(uiModelColl);
      const collisionGroups = getCollisionGroup(uiModels, usingTravelTime);
      const matrices = getMatrices(uiModelColl, collisionGroups, usingTravelTime);
      result[ymd] = matrices;
    });
    return result;
  }
  function _addMultiDatesInfo(uiModelColl) {
    uiModelColl.each((uiModel) => {
      const { model } = uiModel;
      model.hasMultiDates = true;
      uiModel.renderStarts = toStartOfDay(model.getStarts());
      uiModel.renderEnds = toEndOfDay(model.getEnds());
    });
  }
  function getUIModelForAlldayView(start, end, uiModelColl) {
    if (!uiModelColl || !uiModelColl.size) {
      return [];
    }
    _addMultiDatesInfo(uiModelColl);
    limitRenderRange(start, end, uiModelColl);
    const uiModels = uiModelColl.sort(array.compare.event.asc);
    const usingTravelTime = true;
    const collisionGroups = getCollisionGroup(uiModels, usingTravelTime);
    const matrices = getMatrices(uiModelColl, collisionGroups, usingTravelTime);
    positionUIModels(start, end, matrices);
    return matrices;
  }
  function findByDateRange(calendarData, condition) {
    var _a, _b;
    const { start, end, panels, andFilters = [], options } = condition;
    const { events, idsOfDay } = calendarData;
    const hourStart = (_a = options == null ? void 0 : options.hourStart) != null ? _a : 0;
    const hourEnd = (_b = options == null ? void 0 : options.hourEnd) != null ? _b : 24;
    const filterFn = Collection.and(...[getEventInDateRangeFilter(start, end)].concat(andFilters));
    const uiModelColl = convertToUIModel(events.filter(filterFn));
    const group = uiModelColl.groupBy(filterByCategory);
    return panels.reduce(
      (acc, cur) => {
        const { name, type } = cur;
        if (isNil(group[name])) {
          return acc;
        }
        return __spreadProps(__spreadValues({}, acc), {
          [name]: type === "daygrid" ? getUIModelForAlldayView(start, end, group[name]) : getUIModelForTimeView(idsOfDay, {
            start,
            end,
            uiModelTimeColl: group[name],
            hourStart,
            hourEnd
          })
        });
      },
      {
        milestone: [],
        task: [],
        allday: [],
        time: {}
      }
    );
  }
  function limit(value, minArr, maxArr) {
    const v2 = Math.max(value, ...minArr);
    return Math.min(v2, ...maxArr);
  }
  function ratio(a2, b2, y2) {
    return b2 * y2 / a2;
  }
  function isBetween$1(value, min2, max2) {
    return min2 <= value && value <= max2;
  }
  const EVENT_HEIGHT = 22;
  const TOTAL_WIDTH = 100;
  function forEachMatrix3d(matrices, iteratee) {
    matrices.forEach((matrix) => {
      matrix.forEach((row) => {
        row.forEach((value, index) => {
          iteratee(value, index);
        });
      });
    });
  }
  function isWithinHeight(containerHeight, eventHeight) {
    return ({ top }) => containerHeight >= top * eventHeight;
  }
  function isExceededHeight(containerHeight, eventHeight) {
    return ({ top }) => containerHeight < top * eventHeight;
  }
  function getExceedCount(uiModel, containerHeight, eventHeight) {
    return uiModel.filter(isExceededHeight(containerHeight, eventHeight)).length;
  }
  const getWeekendCount = (row) => row.filter((cell) => isWeekend(cell.getDay())).length;
  function getGridWidthAndLeftPercentValues(row, narrowWeekend, totalWidth) {
    const weekendCount = getWeekendCount(row);
    const gridCellCount = row.length;
    const isAllWeekend = weekendCount === gridCellCount;
    const widthPerDay = totalWidth / (narrowWeekend && !isAllWeekend ? gridCellCount * 2 - weekendCount : gridCellCount);
    const widthList = row.map((cell) => {
      const day = cell.getDay();
      if (!narrowWeekend || isAllWeekend) {
        return widthPerDay;
      }
      return isWeekend(day) ? widthPerDay : widthPerDay * 2;
    });
    const leftList = widthList.reduce(
      (acc, _2, index) => index ? [...acc, acc[index - 1] + widthList[index - 1]] : [0],
      []
    );
    return {
      widthList,
      leftList
    };
  }
  function getWidth(widthList, start, end) {
    return widthList.reduce((acc, width, index) => {
      if (start <= index && index <= end) {
        return acc + width;
      }
      return acc;
    }, 0);
  }
  const isInGrid = (gridDate) => {
    return (uiModel) => {
      const eventStart = toStartOfDay(uiModel.getStarts());
      const eventEnd = toStartOfDay(uiModel.getEnds());
      return eventStart <= gridDate && gridDate <= eventEnd;
    };
  };
  function getGridDateIndex(date2, row) {
    return row.findIndex((cell) => date2 >= toStartOfDay(cell) && date2 <= toEndOfDay(cell));
  }
  const getLeftAndWidth = (startIndex, endIndex, row, narrowWeekend) => {
    const { widthList } = getGridWidthAndLeftPercentValues(row, narrowWeekend, TOTAL_WIDTH);
    return {
      left: !startIndex ? 0 : getWidth(widthList, 0, startIndex - 1),
      width: getWidth(widthList, startIndex != null ? startIndex : 0, endIndex < 0 ? row.length - 1 : endIndex)
    };
  };
  const getEventLeftAndWidth = (start, end, row, narrowWeekend) => {
    const { widthList } = getGridWidthAndLeftPercentValues(row, narrowWeekend, TOTAL_WIDTH);
    let gridStartIndex = 0;
    let gridEndIndex = row.length - 1;
    row.forEach((cell, index) => {
      if (cell <= start) {
        gridStartIndex = index;
      }
      if (cell <= end) {
        gridEndIndex = index;
      }
    });
    return {
      width: getWidth(widthList, gridStartIndex, gridEndIndex),
      left: !gridStartIndex ? 0 : getWidth(widthList, 0, gridStartIndex - 1)
    };
  };
  function getEventUIModelWithPosition(uiModel, row, narrowWeekend = false) {
    const modelStart = uiModel.getStarts();
    const modelEnd = uiModel.getEnds();
    const { width, left } = getEventLeftAndWidth(modelStart, modelEnd, row, narrowWeekend);
    uiModel.width = width;
    uiModel.left = left;
    return uiModel;
  }
  function getRenderedEventUIModels(row, calendarData, narrowWeekend) {
    const { idsOfDay } = calendarData;
    const eventUIModels = findByDateRange$1(calendarData, {
      start: row[0],
      end: toEndOfDay(row[row.length - 1])
    });
    const idEventModelMap = [];
    forEachMatrix3d(eventUIModels, (uiModel) => {
      const cid = uiModel.model.cid();
      idEventModelMap[cid] = getEventUIModelWithPosition(uiModel, row, narrowWeekend);
    });
    const gridDateEventModelMap = Object.keys(idsOfDay).reduce(
      (acc, ymd) => {
        const ids = idsOfDay[ymd];
        acc[ymd] = ids.map((cid) => idEventModelMap[cid]).filter((vm) => !!vm);
        return acc;
      },
      {}
    );
    return {
      uiModels: Object.values(idEventModelMap),
      gridDateEventModelMap
    };
  }
  const getDayGridEventModels = (eventModels, row, narrowWeekend = false) => {
    forEachMatrix3d(eventModels, (uiModel) => {
      const modelStart = uiModel.getStarts();
      const modelEnd = uiModel.getEnds();
      const { width, left } = getEventLeftAndWidth(modelStart, modelEnd, row, narrowWeekend);
      uiModel.width = width;
      uiModel.left = left;
      uiModel.top += 1;
    });
    return flattenMatrix3d(eventModels);
  };
  const getModels = (models) => models.filter((model) => !!model);
  function flattenMatrix3d(matrices) {
    return matrices.flatMap((matrix) => matrix.flatMap((models) => getModels(models)));
  }
  const getTimeGridEventModels = (eventMatrix) => Array.from(
    new Set(
      Object.values(eventMatrix).reduce(
        (result, matrix3d) => result.concat(...flattenMatrix3d(matrix3d)),
        []
      )
    )
  );
  const getWeekViewEvents = (row, calendarData, {
    narrowWeekend,
    hourStart,
    hourEnd,
    weekStartDate,
    weekEndDate
  }) => {
    const panels = [
      {
        name: "milestone",
        type: "daygrid",
        show: true
      },
      {
        name: "task",
        type: "daygrid",
        show: true
      },
      {
        name: "allday",
        type: "daygrid",
        show: true
      },
      {
        name: "time",
        type: "timegrid",
        show: true
      }
    ];
    const eventModels = findByDateRange(calendarData, {
      start: weekStartDate,
      end: weekEndDate,
      panels,
      andFilters: [],
      options: {
        hourStart,
        hourEnd
      }
    });
    return Object.keys(eventModels).reduce(
      (acc, cur) => {
        const events = eventModels[cur];
        return __spreadProps(__spreadValues({}, acc), {
          [cur]: Array.isArray(events) ? getDayGridEventModels(events, row, narrowWeekend) : getTimeGridEventModels(events)
        });
      },
      {
        milestone: [],
        allday: [],
        task: [],
        time: []
      }
    );
  };
  function createDateMatrixOfMonth(renderTargetDate, {
    workweek = false,
    visibleWeeksCount = 0,
    startDayOfWeek = 0,
    isAlways6Weeks = true
  }) {
    const targetDate = new TZDate(renderTargetDate);
    const shouldApplyVisibleWeeksCount = visibleWeeksCount > 0;
    const baseDate = shouldApplyVisibleWeeksCount ? targetDate : toStartOfMonth(targetDate);
    const firstDateOfMatrix = subtractDate(
      baseDate,
      baseDate.getDay() - startDayOfWeek + (baseDate.getDay() < startDayOfWeek ? WEEK_DAYS : 0)
    );
    const dayOfFirstDateOfMatrix = firstDateOfMatrix.getDay();
    const totalDatesCountOfMonth = toEndOfMonth(targetDate).getDate();
    const initialDifference = getDateDifference(firstDateOfMatrix, baseDate);
    const totalDatesOfMatrix = totalDatesCountOfMonth + Math.abs(initialDifference);
    let totalWeeksOfMatrix = DEFAULT_VISIBLE_WEEKS;
    if (shouldApplyVisibleWeeksCount) {
      totalWeeksOfMatrix = visibleWeeksCount;
    } else if (isAlways6Weeks === false) {
      totalWeeksOfMatrix = Math.ceil(totalDatesOfMatrix / WEEK_DAYS);
    }
    return range_1(0, totalWeeksOfMatrix).map(
      (weekIndex) => range_1(0, WEEK_DAYS).reduce((weekRow, dayOfWeek) => {
        const steps = weekIndex * WEEK_DAYS + dayOfWeek;
        const currentDay = (steps + dayOfFirstDateOfMatrix) % WEEK_DAYS;
        if (!workweek || workweek && !isWeekend(currentDay)) {
          const date2 = addDate(firstDateOfMatrix, steps);
          weekRow.push(date2);
        }
        return weekRow;
      }, [])
    );
  }
  function getWeekDates(renderDate, { startDayOfWeek = Day$2.SUN, workweek }) {
    const now = toStartOfDay(renderDate);
    const nowDay = now.getDay();
    const prevDateCount = nowDay - startDayOfWeek;
    const weekDayList = prevDateCount >= 0 ? range_1(-prevDateCount, WEEK_DAYS - prevDateCount) : range_1(-WEEK_DAYS - prevDateCount, -prevDateCount);
    return weekDayList.reduce((acc, day) => {
      const date2 = addDate(now, day);
      if (workweek && isWeekend(date2.getDay())) {
        return acc;
      }
      acc.push(date2);
      return acc;
    }, []);
  }
  function getColumnsData(datesOfWeek, narrowWeekend = false) {
    const datesCount = datesOfWeek.length;
    const shouldApplyNarrowWeekend = datesCount > 5 && narrowWeekend;
    const defaultWidthByColumns = shouldApplyNarrowWeekend ? 100 / (datesCount - 1) : 100 / datesCount;
    return datesOfWeek.map((date2) => {
      const width = shouldApplyNarrowWeekend && isWeekend(date2.getDay()) ? defaultWidthByColumns / 2 : defaultWidthByColumns;
      return {
        date: date2,
        width
      };
    }).reduce((result, currentDateAndWidth, index) => {
      const prev = result[index - 1];
      result.push(__spreadProps(__spreadValues({}, currentDateAndWidth), {
        left: index === 0 ? 0 : prev.left + prev.width
      }));
      return result;
    }, []);
  }
  function createTimeGridData(datesOfWeek, options) {
    var _a;
    const columns = getColumnsData(datesOfWeek, (_a = options.narrowWeekend) != null ? _a : false);
    const { timeStep } = options;
    const steps = (options.hourEnd - options.hourStart) * timeStep.length;
    const baseHeight = 100 / steps;
    let count = 0;
    const rows = range_1(steps).map((step, index) => {
      count = count === timeStep.length ? 0 : count;
      const hour = options.hourStart + Math.floor(step / timeStep.length);
      const startTime = `${hour}:${timeStep[count] !== 0 ? timeStep[count] : "00"}`.padStart(
        5,
        "0"
      );
      const endTime = (count === timeStep.length - 1 ? `${hour + 1}:00` : `${hour}:${timeStep[count + 1]}`).padStart(5, "0");
      count += 1;
      return {
        top: baseHeight * index,
        height: baseHeight,
        startTime,
        endTime
      };
    });
    return {
      columns,
      rows
    };
  }
  function getRelativeMousePosition({ clientX, clientY }, { left, top, clientLeft, clientTop }) {
    return [clientX - left - clientLeft, clientY - top - clientTop];
  }
  function getIndexFromPosition(arrayLength, maxRange, currentPosition) {
    const calculatedIndex = Math.floor(ratio(maxRange, arrayLength, currentPosition));
    return limit(calculatedIndex, [0], [arrayLength - 1]);
  }
  function createGridPositionFinder({
    rowsCount,
    columnsCount,
    container,
    narrowWeekend = false,
    startDayOfWeek = Day$2.SUN
  }) {
    if (isNil(container)) {
      return () => null;
    }
    const dayRange = range_1(startDayOfWeek, startDayOfWeek + columnsCount).map(
      (day) => day % WEEK_DAYS
    );
    const narrowColumnCount = narrowWeekend ? dayRange.filter((day) => isWeekend(day)).length : 0;
    return function gridPositionFinder(mousePosition) {
      const {
        left: containerLeft,
        top: containerTop,
        width: containerWidth,
        height: containerHeight
      } = container.getBoundingClientRect();
      const [left, top] = getRelativeMousePosition(mousePosition, {
        left: containerLeft,
        top: containerTop,
        clientLeft: container.clientLeft,
        clientTop: container.clientTop
      });
      if (left < 0 || top < 0 || left > containerWidth || top > containerHeight) {
        return null;
      }
      const unitWidth = narrowWeekend ? containerWidth / (columnsCount - narrowColumnCount + 1) : containerWidth / columnsCount;
      const columnWidthList = dayRange.map(
        (dayOfWeek) => narrowWeekend && isWeekend(dayOfWeek) ? unitWidth / 2 : unitWidth
      );
      const columnLeftList = [];
      columnWidthList.forEach((width, index) => {
        if (index === 0) {
          columnLeftList.push(0);
        } else {
          columnLeftList.push(columnLeftList[index - 1] + columnWidthList[index - 1]);
        }
      });
      const columnIndex = findLastIndex(columnLeftList, (columnLeft) => left >= columnLeft);
      return {
        columnIndex,
        rowIndex: getIndexFromPosition(rowsCount, containerHeight, top)
      };
    };
  }
  function commonGridSelectionSelector(theme) {
    return theme.common.gridSelection;
  }
  function GridSelection$1({ type, gridSelectionData, weekDates, narrowWeekend }) {
    const { backgroundColor, border } = useTheme(commonGridSelectionSelector);
    const { startCellIndex, endCellIndex } = gridSelectionData;
    const { left, width } = getLeftAndWidth(
      Math.min(startCellIndex, endCellIndex),
      Math.max(startCellIndex, endCellIndex),
      weekDates,
      narrowWeekend
    );
    const style = {
      left: toPercent(left),
      width: toPercent(width),
      height: toPercent(100),
      backgroundColor,
      border
    };
    return width > 0 ? /* @__PURE__ */ y$3("div", {
      className: cls(type, "grid-selection"),
      style
    }) : null;
  }
  function createSortedGridSelection(initPos, currentPos, isReversed) {
    return {
      startColumnIndex: isReversed ? currentPos.columnIndex : initPos.columnIndex,
      startRowIndex: isReversed ? currentPos.rowIndex : initPos.rowIndex,
      endColumnIndex: isReversed ? initPos.columnIndex : currentPos.columnIndex,
      endRowIndex: isReversed ? initPos.rowIndex : currentPos.rowIndex
    };
  }
  function calculateTimeGridSelectionByCurrentIndex(timeGridSelection, columnIndex, maxRowIndex) {
    if (isNil(timeGridSelection)) {
      return null;
    }
    const { startColumnIndex, endColumnIndex, endRowIndex, startRowIndex } = timeGridSelection;
    if (!isBetween$1(columnIndex, startColumnIndex, endColumnIndex)) {
      return null;
    }
    const hasMultipleColumns = startColumnIndex !== endColumnIndex;
    const isStartingColumn = columnIndex === startColumnIndex;
    const resultGridSelection = {
      startRowIndex,
      endRowIndex,
      isSelectingMultipleColumns: hasMultipleColumns,
      isStartingColumn
    };
    if (startColumnIndex < columnIndex && columnIndex < endColumnIndex) {
      resultGridSelection.startRowIndex = 0;
      resultGridSelection.endRowIndex = maxRowIndex;
    } else if (startColumnIndex !== endColumnIndex) {
      if (startColumnIndex === columnIndex) {
        resultGridSelection.endRowIndex = maxRowIndex;
      } else if (endColumnIndex === columnIndex) {
        resultGridSelection.startRowIndex = 0;
      }
    }
    return resultGridSelection;
  }
  const timeGridSelectionHelper = {
    sortSelection: (initPos, currentPos) => {
      const isReversed = initPos.columnIndex > currentPos.columnIndex || initPos.columnIndex === currentPos.columnIndex && initPos.rowIndex > currentPos.rowIndex;
      return createSortedGridSelection(initPos, currentPos, isReversed);
    },
    getDateFromCollection: (dateCollection, gridSelection) => {
      const timeGridData = dateCollection;
      const startDate = setTimeStrToDate(
        timeGridData.columns[gridSelection.startColumnIndex].date,
        timeGridData.rows[gridSelection.startRowIndex].startTime
      );
      const endDate = setTimeStrToDate(
        timeGridData.columns[gridSelection.endColumnIndex].date,
        timeGridData.rows[gridSelection.endRowIndex].endTime
      );
      return [startDate, endDate];
    },
    calculateSelection: calculateTimeGridSelectionByCurrentIndex
  };
  function calculateDayGridMonthSelectionByCurrentIndex(gridSelection, currentIndex, weekLength) {
    if (!(isPresent(gridSelection) && isPresent(currentIndex) && isPresent(weekLength))) {
      return null;
    }
    const { startRowIndex, startColumnIndex, endRowIndex, endColumnIndex } = gridSelection;
    if (!isBetween$1(
      currentIndex,
      Math.min(startRowIndex, endRowIndex),
      Math.max(startRowIndex, endRowIndex)
    )) {
      return null;
    }
    let startCellIndex = startColumnIndex;
    let endCellIndex = endColumnIndex;
    if (startRowIndex < currentIndex) {
      startCellIndex = 0;
    }
    if (endRowIndex > currentIndex) {
      endCellIndex = weekLength - 1;
    }
    return { startCellIndex, endCellIndex };
  }
  const dayGridMonthSelectionHelper = {
    sortSelection: (initPos, currentPos) => {
      const isReversed = initPos.rowIndex > currentPos.rowIndex || initPos.rowIndex === currentPos.rowIndex && initPos.columnIndex > currentPos.columnIndex;
      return createSortedGridSelection(initPos, currentPos, isReversed);
    },
    getDateFromCollection: (dateCollection, gridSelection) => {
      const dateMatrix = dateCollection;
      return [
        dateMatrix[gridSelection.startRowIndex][gridSelection.startColumnIndex],
        dateMatrix[gridSelection.endRowIndex][gridSelection.endColumnIndex]
      ];
    },
    calculateSelection: calculateDayGridMonthSelectionByCurrentIndex
  };
  function calculateAlldayGridRowSelectionByCurrentIndex(gridSelection) {
    return isPresent(gridSelection) ? {
      startCellIndex: gridSelection.startColumnIndex,
      endCellIndex: gridSelection.endColumnIndex
    } : null;
  }
  const alldayGridRowSelectionHelper = {
    sortSelection: (initPos, currentPos) => {
      const isReversed = initPos.columnIndex > currentPos.columnIndex;
      return createSortedGridSelection(initPos, currentPos, isReversed);
    },
    getDateFromCollection: (dateCollection, gridSelection) => {
      const weekDates = dateCollection;
      return [weekDates[gridSelection.startColumnIndex], weekDates[gridSelection.endColumnIndex]];
    },
    calculateSelection: calculateAlldayGridRowSelectionByCurrentIndex
  };
  function dayGridWeekSelectionSelector(state) {
    return alldayGridRowSelectionHelper.calculateSelection(state.gridSelection.dayGridWeek);
  }
  function AlldayGridSelection({ weekDates, narrowWeekend }) {
    const calculatedGridSelection = useStore(dayGridWeekSelectionSelector);
    if (isNil(calculatedGridSelection)) {
      return null;
    }
    return /* @__PURE__ */ y$3(GridSelection$1, {
      type: "allday",
      gridSelectionData: calculatedGridSelection,
      weekDates,
      narrowWeekend
    });
  }
  function S$1(n2, t2) {
    for (var e2 in t2)
      n2[e2] = t2[e2];
    return n2;
  }
  function C$1(n2, t2) {
    for (var e2 in n2)
      if ("__source" !== e2 && !(e2 in t2))
        return true;
    for (var r2 in t2)
      if ("__source" !== r2 && n2[r2] !== t2[r2])
        return true;
    return false;
  }
  function E(n2, t2) {
    this.props = n2, this.context = t2;
  }
  function w$1(n2, e2) {
    function r2(n3) {
      var t2 = this.props.ref, r3 = t2 == n3.ref;
      return !r3 && t2 && (t2.call ? t2(null) : t2.current = null), e2 ? !e2(this.props, n3) || !r3 : C$1(this.props, n3);
    }
    function u2(e3) {
      return this.shouldComponentUpdate = r2, y$3(n2, e3);
    }
    return u2.displayName = "Memo(" + (n2.displayName || n2.name) + ")", u2.prototype.isReactComponent = true, u2.__f = true, u2;
  }
  (E.prototype = new b$2()).isPureReactComponent = true, E.prototype.shouldComponentUpdate = function(n2, t2) {
    return C$1(this.props, n2) || C$1(this.state, t2);
  };
  var x$1 = l$3.__b;
  l$3.__b = function(n2) {
    n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), x$1 && x$1(n2);
  };
  var R = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
  function N(n2) {
    function t2(t3) {
      var e2 = S$1({}, t3);
      return delete e2.ref, n2(e2, t3.ref || null);
    }
    return t2.$$typeof = R, t2.render = t2, t2.prototype.isReactComponent = t2.__f = true, t2.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t2;
  }
  var M = l$3.__e;
  l$3.__e = function(n2, t2, e2, r2) {
    if (n2.then) {
      for (var u2, o2 = t2; o2 = o2.__; )
        if ((u2 = o2.__c) && u2.__c)
          return null == t2.__e && (t2.__e = e2.__e, t2.__k = e2.__k), u2.__c(n2, t2);
    }
    M(n2, t2, e2, r2);
  };
  var O$1 = l$3.unmount;
  function T(n2, t2, e2) {
    return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
      "function" == typeof n3.__c && n3.__c();
    }), n2.__c.__H = null), null != (n2 = S$1({}, n2)).__c && (n2.__c.__P === e2 && (n2.__c.__P = t2), n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
      return T(n3, t2, e2);
    })), n2;
  }
  function F$1(n2, t2, e2) {
    return n2 && e2 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
      return F$1(n3, t2, e2);
    }), n2.__c && n2.__c.__P === t2 && (n2.__e && e2.appendChild(n2.__e), n2.__c.__e = true, n2.__c.__P = e2)), n2;
  }
  function I() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function L(n2) {
    var t2 = n2.__.__c;
    return t2 && t2.__a && t2.__a(n2);
  }
  function D() {
    this.u = null, this.o = null;
  }
  l$3.unmount = function(n2) {
    var t2 = n2.__c;
    t2 && t2.__R && t2.__R(), t2 && 32 & n2.__u && (n2.type = null), O$1 && O$1(n2);
  }, (I.prototype = new b$2()).__c = function(n2, t2) {
    var e2 = t2.__c, r2 = this;
    null == r2.t && (r2.t = []), r2.t.push(e2);
    var u2 = L(r2.__v), o2 = false, i2 = function() {
      o2 || (o2 = true, e2.__R = null, u2 ? u2(l2) : l2());
    };
    e2.__R = i2;
    var l2 = function() {
      if (!--r2.__u) {
        if (r2.state.__a) {
          var n3 = r2.state.__a;
          r2.__v.__k[0] = F$1(n3, n3.__c.__P, n3.__c.__O);
        }
        var t3;
        for (r2.setState({ __a: r2.__b = null }); t3 = r2.t.pop(); )
          t3.forceUpdate();
      }
    };
    r2.__u++ || 32 & t2.__u || r2.setState({ __a: r2.__b = r2.__v.__k[0] }), n2.then(i2, i2);
  }, I.prototype.componentWillUnmount = function() {
    this.t = [];
  }, I.prototype.render = function(n2, e2) {
    if (this.__b) {
      if (this.__v.__k) {
        var r2 = document.createElement("div"), o2 = this.__v.__k[0].__c;
        this.__v.__k[0] = T(this.__b, r2, o2.__O = o2.__P);
      }
      this.__b = null;
    }
    var i2 = e2.__a && y$3(g$2, null, n2.fallback);
    return i2 && (i2.__u &= -33), [y$3(g$2, null, e2.__a ? null : n2.children), i2];
  };
  var V = function(n2, t2, e2) {
    if (++e2[1] === e2[0] && n2.o.delete(t2), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.o.size))
      for (e2 = n2.u; e2; ) {
        for (; e2.length > 3; )
          e2.pop()();
        if (e2[1] < e2[0])
          break;
        n2.u = e2 = e2[2];
      }
  };
  function W(n2) {
    return this.getChildContext = function() {
      return n2.context;
    }, n2.children;
  }
  function P(n2) {
    var e2 = this, r2 = n2.i;
    e2.componentWillUnmount = function() {
      N$2(null, e2.l), e2.l = null, e2.i = null;
    }, e2.i && e2.i !== r2 && e2.componentWillUnmount(), e2.l || (e2.i = r2, e2.l = { nodeType: 1, parentNode: r2, childNodes: [], appendChild: function(n3) {
      this.childNodes.push(n3), e2.i.appendChild(n3);
    }, insertBefore: function(n3, t2) {
      this.childNodes.push(n3), e2.i.appendChild(n3);
    }, removeChild: function(n3) {
      this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), e2.i.removeChild(n3);
    } }), N$2(y$3(W, { context: e2.context }, n2.__v), e2.l);
  }
  function j$1(n2, e2) {
    var r2 = y$3(P, { __v: n2, i: e2 });
    return r2.containerInfo = e2, r2;
  }
  (D.prototype = new b$2()).__a = function(n2) {
    var t2 = this, e2 = L(t2.__v), r2 = t2.o.get(n2);
    return r2[0]++, function(u2) {
      var o2 = function() {
        t2.props.revealOrder ? (r2.push(u2), V(t2, n2, r2)) : u2();
      };
      e2 ? e2(o2) : o2();
    };
  }, D.prototype.render = function(n2) {
    this.u = null, this.o = /* @__PURE__ */ new Map();
    var t2 = $$1(n2.children);
    n2.revealOrder && "b" === n2.revealOrder[0] && t2.reverse();
    for (var e2 = t2.length; e2--; )
      this.o.set(t2[e2], this.u = [1, 0, this.u]);
    return n2.children;
  }, D.prototype.componentDidUpdate = D.prototype.componentDidMount = function() {
    var n2 = this;
    this.o.forEach(function(t2, e2) {
      V(n2, e2, t2);
    });
  };
  var z = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103, B = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, H = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, Z = /[A-Z0-9]/g, Y = "undefined" != typeof document, $ = function(n2) {
    return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n2);
  };
  b$2.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t2) {
    Object.defineProperty(b$2.prototype, t2, { configurable: true, get: function() {
      return this["UNSAFE_" + t2];
    }, set: function(n2) {
      Object.defineProperty(this, t2, { configurable: true, writable: true, value: n2 });
    } });
  });
  var J = l$3.event;
  function K() {
  }
  function Q() {
    return this.cancelBubble;
  }
  function X() {
    return this.defaultPrevented;
  }
  l$3.event = function(n2) {
    return J && (n2 = J(n2)), n2.persist = K, n2.isPropagationStopped = Q, n2.isDefaultPrevented = X, n2.nativeEvent = n2;
  };
  var tn = { enumerable: false, configurable: true, get: function() {
    return this.class;
  } }, en = l$3.vnode;
  l$3.vnode = function(n2) {
    "string" == typeof n2.type && function(n3) {
      var t2 = n3.props, e2 = n3.type, u2 = {};
      for (var o2 in t2) {
        var i2 = t2[o2];
        if (!("value" === o2 && "defaultValue" in t2 && null == i2 || Y && "children" === o2 && "noscript" === e2 || "class" === o2 || "className" === o2)) {
          var l2 = o2.toLowerCase();
          "defaultValue" === o2 && "value" in t2 && null == t2.value ? o2 = "value" : "download" === o2 && true === i2 ? i2 = "" : "translate" === l2 && "no" === i2 ? i2 = false : "ondoubleclick" === l2 ? o2 = "ondblclick" : "onchange" !== l2 || "input" !== e2 && "textarea" !== e2 || $(t2.type) ? "onfocus" === l2 ? o2 = "onfocusin" : "onblur" === l2 ? o2 = "onfocusout" : H.test(o2) ? o2 = l2 : -1 === e2.indexOf("-") && B.test(o2) ? o2 = o2.replace(Z, "-$&").toLowerCase() : null === i2 && (i2 = void 0) : l2 = o2 = "oninput", "oninput" === l2 && u2[o2 = l2] && (o2 = "oninputCapture"), u2[o2] = i2;
        }
      }
      "select" == e2 && u2.multiple && Array.isArray(u2.value) && (u2.value = $$1(t2.children).forEach(function(n4) {
        n4.props.selected = -1 != u2.value.indexOf(n4.props.value);
      })), "select" == e2 && null != u2.defaultValue && (u2.value = $$1(t2.children).forEach(function(n4) {
        n4.props.selected = u2.multiple ? -1 != u2.defaultValue.indexOf(n4.props.value) : u2.defaultValue == n4.props.value;
      })), t2.class && !t2.className ? (u2.class = t2.class, Object.defineProperty(u2, "className", tn)) : (t2.className && !t2.class || t2.class && t2.className) && (u2.class = u2.className = t2.className), n3.props = u2;
    }(n2), n2.$$typeof = z, en && en(n2);
  };
  var rn = l$3.__r;
  l$3.__r = function(n2) {
    rn && rn(n2), n2.__c;
  };
  var un = l$3.diffed;
  l$3.diffed = function(n2) {
    un && un(n2);
    var t2 = n2.props, e2 = n2.__e;
    null != e2 && "textarea" === n2.type && "value" in t2 && t2.value !== e2.value && (e2.value = null == t2.value ? "" : t2.value);
  };
  function vn(n2) {
    return !!n2.__k && (N$2(null, n2), true);
  }
  function ExceedCount({ index, exceedCount, isClicked, onClickExceedCount }) {
    const clickExceedCount = () => onClickExceedCount(index);
    const style = { display: isClicked ? "none" : "" };
    return exceedCount && !isClicked ? /* @__PURE__ */ y$3("span", {
      className: cls("weekday-exceed-in-week"),
      onClick: clickExceedCount,
      style
    }, /* @__PURE__ */ y$3(Template, {
      template: "weekGridFooterExceed",
      param: exceedCount
    })) : null;
  }
  function CollapseButton({ isClicked, isClickedIndex, onClickCollapseButton }) {
    return isClicked && isClickedIndex ? /* @__PURE__ */ y$3("span", {
      className: cls("weekday-exceed-in-week"),
      onClick: onClickCollapseButton
    }, /* @__PURE__ */ y$3(Template, {
      template: "collapseBtnTitle"
    })) : null;
  }
  function GridCell$1({
    width,
    left,
    index,
    exceedCount,
    isClicked,
    onClickExceedCount,
    isClickedIndex,
    onClickCollapseButton,
    isLastCell
  }) {
    const { borderRight, backgroundColor } = useTheme(x$3((theme) => theme.week.dayGrid, []));
    const style = {
      width,
      left,
      borderRight: isLastCell ? "none" : borderRight,
      backgroundColor
    };
    return /* @__PURE__ */ y$3("div", {
      className: cls("panel-grid"),
      style
    }, /* @__PURE__ */ y$3(ExceedCount, {
      index,
      exceedCount,
      isClicked,
      onClickExceedCount
    }), /* @__PURE__ */ y$3(CollapseButton, {
      isClickedIndex,
      isClicked,
      onClickCollapseButton
    }));
  }
  const GridCells = w$1(function GridCells2({
    uiModels,
    weekDates,
    narrowWeekend,
    height,
    clickedIndex,
    isClickedCount,
    onClickExceedCount,
    onClickCollapseButton
  }) {
    const eventTopMargin = 2;
    const { widthList, leftList } = getGridWidthAndLeftPercentValues(
      weekDates,
      narrowWeekend,
      TOTAL_WIDTH
    );
    const lastCellIndex = weekDates.length - 1;
    return /* @__PURE__ */ y$3(g$2, null, weekDates.map((cell, index) => {
      const width = toPercent(widthList[index]);
      const left = toPercent(leftList[index]);
      const uiModelsInCell = uiModels.filter(isInGrid(cell));
      const exceedCount = getExceedCount(uiModelsInCell, height, EVENT_HEIGHT + eventTopMargin);
      const isClickedIndex = index === clickedIndex;
      const isLastCell = index === lastCellIndex;
      return /* @__PURE__ */ y$3(GridCell$1, {
        key: `panel-grid-${cell.getDate()}`,
        width,
        left,
        index,
        exceedCount,
        isClicked: isClickedCount,
        onClickExceedCount,
        isClickedIndex,
        onClickCollapseButton,
        isLastCell
      });
    }));
  });
  function HorizontalEventResizeIcon({ onMouseDown }) {
    return /* @__PURE__ */ y$3("span", {
      className: `${cls("weekday-resize-handle")} ${cls("handle-y")}`,
      onMouseDown,
      "data-testid": "horizontal-event-resize-icon"
    }, /* @__PURE__ */ y$3("i", {
      className: `${cls("icon")} ${cls("ic-handle-y")}`
    }));
  }
  const LayoutContainerContext = E$2(null);
  const LayoutContainerProvider = LayoutContainerContext.Provider;
  const useLayoutContainer = () => {
    const ref = P$2(LayoutContainerContext);
    if (isUndefined_1(ref)) {
      throw new Error("LayoutContainerProvider is not found");
    }
    return ref;
  };
  const DRAGGING_TYPE_CONSTANTS = {
    panelResizer: "panelResizer"
  };
  const DRAGGING_TYPE_CREATORS = {
    resizeEvent: (area, id) => `event/${area}/resize/${id}`,
    moveEvent: (area, id) => `event/${area}/move/${id}`,
    gridSelection: (type) => `gridSelection/${type}`
  };
  function useCalendarById(calendarId) {
    return useStore(
      x$3(
        (state) => state.calendar.calendars.find((cal) => cal.id === calendarId),
        [calendarId]
      )
    );
  }
  function useCalendarColor(model) {
    var _a;
    const calendar = useCalendarById((_a = model == null ? void 0 : model.calendarId) != null ? _a : null);
    return q$1(
      () => ({
        color: calendar == null ? void 0 : calendar.color,
        borderColor: calendar == null ? void 0 : calendar.borderColor,
        backgroundColor: calendar == null ? void 0 : calendar.backgroundColor,
        dragBackgroundColor: calendar == null ? void 0 : calendar.dragBackgroundColor
      }),
      [calendar]
    );
  }
  var KEY = /* @__PURE__ */ ((KEY2) => {
    KEY2["ESCAPE"] = "Escape";
    return KEY2;
  })(KEY || {});
  const KEYCODE = {
    ["Escape"]: 27
  };
  const MINIMUM_DRAG_MOUSE_DISTANCE = 3;
  function useTransientUpdate(selector, subscriber) {
    const store = useInternalStore();
    const selectorRef = F$2(selector);
    const subscriberRef = F$2(subscriber);
    _$2(() => {
      selectorRef.current = selector;
      subscriberRef.current = subscriber;
    }, [selector, subscriber]);
    _$2(
      () => store.subscribe(
        (slice) => subscriberRef.current(slice),
        (state) => selectorRef.current(state)
      ),
      [selector, store]
    );
  }
  function isKeyPressed(e2, key) {
    return e2.key ? e2.key === key : e2.keyCode === KEYCODE[key];
  }
  function isLeftClick(buttonNum) {
    return buttonNum === 0;
  }
  function isMouseMoved(initX, initY, x2, y2) {
    return Math.abs(initX - x2) >= MINIMUM_DRAG_MOUSE_DISTANCE || Math.abs(initY - y2) >= MINIMUM_DRAG_MOUSE_DISTANCE;
  }
  function useDrag(draggingItemType, { onInit, onDragStart, onDrag, onMouseUp, onPressESCKey } = {}) {
    const { initDrag, setDragging, cancelDrag, reset } = useDispatch("dnd");
    const store = useInternalStore();
    const dndSliceRef = F$2(store.getState().dnd);
    useTransientUpdate(dndSelector, (dndState) => {
      dndSliceRef.current = dndState;
    });
    const [isStarted, setStarted] = p$2(false);
    const handleMouseMoveRef = F$2(null);
    const handleMouseUpRef = F$2(null);
    const handleKeyDownRef = F$2(null);
    const handleMouseDown = x$3(
      (e2) => {
        if (!isLeftClick(e2.button)) {
          return;
        }
        if (e2.currentTarget) {
          e2.currentTarget.ondragstart = function() {
            return false;
          };
        }
        e2.preventDefault();
        setStarted(true);
        initDrag({
          draggingItemType,
          initX: e2.clientX,
          initY: e2.clientY
        });
        onInit == null ? void 0 : onInit(e2, dndSliceRef.current);
      },
      [onInit, draggingItemType, initDrag]
    );
    const handleMouseMove = x$3(
      (e2) => {
        const {
          initX,
          initY,
          draggingState,
          draggingItemType: currentDraggingItemType
        } = dndSliceRef.current;
        if (currentDraggingItemType !== draggingItemType) {
          setStarted(false);
          reset();
          return;
        }
        if (isPresent(initX) && isPresent(initY) && !isMouseMoved(initX, initY, e2.clientX, e2.clientY)) {
          return;
        }
        if (draggingState <= DraggingState.INIT) {
          setDragging({ x: e2.clientX, y: e2.clientY });
          onDragStart == null ? void 0 : onDragStart(e2, dndSliceRef.current);
          return;
        }
        setDragging({ x: e2.clientX, y: e2.clientY });
        onDrag == null ? void 0 : onDrag(e2, dndSliceRef.current);
      },
      [draggingItemType, onDrag, onDragStart, setDragging, reset]
    );
    const handleMouseUp = x$3(
      (e2) => {
        e2.stopPropagation();
        if (isStarted) {
          onMouseUp == null ? void 0 : onMouseUp(e2, dndSliceRef.current);
          setStarted(false);
          reset();
        }
      },
      [isStarted, onMouseUp, reset]
    );
    const handleKeyDown = x$3(
      (e2) => {
        if (isKeyPressed(e2, KEY.ESCAPE)) {
          setStarted(false);
          cancelDrag();
          onPressESCKey == null ? void 0 : onPressESCKey(e2, dndSliceRef.current);
        }
      },
      [onPressESCKey, cancelDrag]
    );
    _$2(() => {
      handleMouseMoveRef.current = handleMouseMove;
      handleMouseUpRef.current = handleMouseUp;
      handleKeyDownRef.current = handleKeyDown;
    }, [handleKeyDown, handleMouseMove, handleMouseUp]);
    _$2(() => {
      const wrappedHandleMouseMove = (e2) => {
        var _a;
        return (_a = handleMouseMoveRef.current) == null ? void 0 : _a.call(handleMouseMoveRef, e2);
      };
      const wrappedHandleMouseUp = (e2) => {
        var _a;
        return (_a = handleMouseUpRef.current) == null ? void 0 : _a.call(handleMouseUpRef, e2);
      };
      const wrappedHandleKeyDown = (e2) => {
        var _a;
        return (_a = handleKeyDownRef.current) == null ? void 0 : _a.call(handleKeyDownRef, e2);
      };
      if (isStarted) {
        document.addEventListener("mousemove", wrappedHandleMouseMove);
        document.addEventListener("mouseup", wrappedHandleMouseUp);
        document.addEventListener("keydown", wrappedHandleKeyDown);
        return () => {
          document.removeEventListener("mousemove", wrappedHandleMouseMove);
          document.removeEventListener("mouseup", wrappedHandleMouseUp);
          document.removeEventListener("keydown", wrappedHandleKeyDown);
        };
      }
      return noop;
    }, [isStarted, reset]);
    return handleMouseDown;
  }
  function passConditionalProp(condition, prop) {
    return condition ? prop : void 0;
  }
  function getMargins(flat) {
    return {
      vertical: flat ? 5 : 2,
      horizontal: 8
    };
  }
  function getBorderRadius(exceedLeft, exceedRight) {
    const leftBorderRadius = exceedLeft ? 0 : "2px";
    const rightBorderRadius = exceedRight ? 0 : "2px";
    return `${leftBorderRadius} ${rightBorderRadius} ${rightBorderRadius} ${leftBorderRadius}`;
  }
  function getEventItemStyle({
    uiModel,
    flat,
    eventHeight,
    isDraggingTarget,
    calendarColor
  }) {
    const { exceedLeft, exceedRight } = uiModel;
    const { color, backgroundColor, dragBackgroundColor, borderColor } = getEventColors(
      uiModel,
      calendarColor
    );
    const defaultItemStyle = {
      color,
      backgroundColor: isDraggingTarget ? dragBackgroundColor : backgroundColor,
      borderLeft: exceedLeft ? "none" : `3px solid ${borderColor}`,
      borderRadius: getBorderRadius(exceedLeft, exceedRight),
      overflow: "hidden",
      height: eventHeight,
      lineHeight: toPx(eventHeight),
      opacity: isDraggingTarget ? 0.5 : 1
    };
    const margins = getMargins(flat);
    return flat ? __spreadValues({
      marginTop: margins.vertical
    }, defaultItemStyle) : __spreadValues({
      marginLeft: exceedLeft ? 0 : margins.horizontal,
      marginRight: exceedRight ? 0 : margins.horizontal
    }, defaultItemStyle);
  }
  function getContainerStyle({
    flat,
    uiModel,
    resizingWidth,
    movingLeft,
    eventHeight,
    headerHeight
  }) {
    const { top, left, width, model } = uiModel;
    const margins = getMargins(flat);
    const baseStyle = flat ? {} : {
      width: resizingWidth || toPercent(width),
      left: toPercent(movingLeft != null ? movingLeft : left),
      top: (top - 1) * (eventHeight + margins.vertical) + headerHeight,
      position: "absolute"
    };
    return Object.assign(baseStyle, model.customStyle);
  }
  function getTestId({ model }) {
    const calendarId = model.calendarId ? `${model.calendarId}-` : "";
    const id = model.id ? `${model.id}-` : "";
    return `${calendarId}${id}${model.title}`;
  }
  const classNames$k = {
    eventBody: cls("weekday-event"),
    eventTitle: cls("weekday-event-title"),
    eventDot: cls("weekday-event-dot"),
    moveEvent: cls("dragging--move-event"),
    resizeEvent: cls("dragging--resize-horizontal-event")
  };
  function HorizontalEvent({
    flat = false,
    uiModel,
    eventHeight,
    headerHeight,
    resizingWidth = null,
    movingLeft = null
  }) {
    const { currentView } = useStore(viewSelector);
    const { useDetailPopup, isReadOnly: isReadOnlyCalendar } = useStore(optionsSelector);
    const { setDraggingEventUIModel } = useDispatch("dnd");
    const { showDetailPopup } = useDispatch("popup");
    const layoutContainer = useLayoutContainer();
    const eventBus = useEventBus();
    const calendarColor = useCalendarColor(uiModel.model);
    const [isDraggingTarget, setIsDraggingTarget] = p$2(false);
    const eventContainerRef = F$2(null);
    const { isReadOnly, id, calendarId } = uiModel.model;
    const isDraggingGuideEvent = isPresent(resizingWidth) || isPresent(movingLeft);
    const isDraggableEvent2 = !isReadOnlyCalendar && !isReadOnly && !isDraggingGuideEvent;
    const startDragEvent = (className2) => {
      setDraggingEventUIModel(uiModel);
      layoutContainer == null ? void 0 : layoutContainer.classList.add(className2);
    };
    const endDragEvent = (className2) => {
      setIsDraggingTarget(false);
      layoutContainer == null ? void 0 : layoutContainer.classList.remove(className2);
    };
    useTransientUpdate(dndSelector, ({ draggingEventUIModel, draggingState }) => {
      if (draggingState === DraggingState.DRAGGING && (draggingEventUIModel == null ? void 0 : draggingEventUIModel.cid()) === uiModel.cid() && !isDraggingGuideEvent) {
        setIsDraggingTarget(true);
      } else {
        setIsDraggingTarget(false);
      }
    });
    _$2(() => {
      if (!isDraggingGuideEvent) {
        eventBus.fire("afterRenderEvent", uiModel.model.toEventObject());
      }
    }, []);
    const onResizeStart = useDrag(DRAGGING_TYPE_CREATORS.resizeEvent("dayGrid", `${uiModel.cid()}`), {
      onDragStart: () => startDragEvent(classNames$k.resizeEvent),
      onMouseUp: () => endDragEvent(classNames$k.resizeEvent),
      onPressESCKey: () => endDragEvent(classNames$k.resizeEvent)
    });
    const onMoveStart = useDrag(DRAGGING_TYPE_CREATORS.moveEvent("dayGrid", `${uiModel.cid()}`), {
      onDragStart: () => {
        if (isDraggableEvent2) {
          startDragEvent(classNames$k.moveEvent);
        }
      },
      onMouseUp: (e2, { draggingState }) => {
        endDragEvent(classNames$k.moveEvent);
        const isClick = draggingState <= DraggingState.INIT;
        if (isClick && useDetailPopup && eventContainerRef.current) {
          showDetailPopup(
            {
              event: uiModel.model,
              eventRect: eventContainerRef.current.getBoundingClientRect()
            },
            flat
          );
        }
        if (isClick) {
          eventBus.fire("clickEvent", { event: uiModel.model.toEventObject(), nativeEvent: e2 });
        }
      },
      onPressESCKey: () => endDragEvent(classNames$k.moveEvent)
    });
    const handleResizeStart = (e2) => {
      e2.stopPropagation();
      if (isDraggableEvent2) {
        onResizeStart(e2);
      }
    };
    const handleMoveStart = (e2) => {
      e2.stopPropagation();
      onMoveStart(e2);
    };
    const isDotEvent = !isDraggingTarget && currentView === "month" && uiModel.model.category === "time" && isSameDate(uiModel.model.start, uiModel.model.end);
    const shouldHideResizeHandler = !isDraggableEvent2 || flat || isDraggingTarget || uiModel.exceedRight;
    const containerStyle = getContainerStyle({
      uiModel,
      eventHeight,
      headerHeight,
      flat,
      movingLeft,
      resizingWidth
    });
    const eventItemStyle = getEventItemStyle({
      uiModel,
      flat,
      eventHeight,
      isDraggingTarget,
      calendarColor
    });
    return /* @__PURE__ */ y$3("div", {
      className: cls("weekday-event-block", {
        "weekday-exceed-left": uiModel.exceedLeft,
        "weekday-exceed-right": uiModel.exceedRight
      }),
      style: containerStyle,
      "data-testid": passConditionalProp(isDraggableEvent2, getTestId(uiModel)),
      "data-calendar-id": calendarId,
      "data-event-id": id,
      ref: eventContainerRef
    }, /* @__PURE__ */ y$3("div", {
      className: classNames$k.eventBody,
      style: __spreadProps(__spreadValues({}, eventItemStyle), {
        backgroundColor: isDotEvent ? null : eventItemStyle.backgroundColor,
        borderLeft: isDotEvent ? null : eventItemStyle.borderLeft
      }),
      onMouseDown: handleMoveStart
    }, isDotEvent ? /* @__PURE__ */ y$3("span", {
      className: classNames$k.eventDot,
      style: { backgroundColor: eventItemStyle.backgroundColor }
    }) : null, /* @__PURE__ */ y$3("span", {
      className: classNames$k.eventTitle
    }, /* @__PURE__ */ y$3(Template, {
      template: uiModel.model.category,
      param: uiModel.model
    })), !shouldHideResizeHandler ? /* @__PURE__ */ y$3(HorizontalEventResizeIcon, {
      onMouseDown: handleResizeStart
    }) : null));
  }
  function useWhen(callback, condition) {
    const callbackRef = F$2(callback);
    _$2(() => {
      callbackRef.current = callback;
    }, [callback]);
    _$2(() => {
      const invoke = () => callbackRef.current();
      if (condition) {
        invoke();
      }
    }, [condition]);
  }
  function useCurrentPointerPositionInGrid(gridPositionFinder) {
    const [currentGridPos, setCurrentGridPos] = p$2(null);
    useTransientUpdate(dndSelector, (dndState) => {
      if (isPresent(dndState.x) && isPresent(dndState.y)) {
        const gridPosition = gridPositionFinder({
          clientX: dndState.x,
          clientY: dndState.y
        });
        if (gridPosition) {
          setCurrentGridPos(gridPosition);
        }
      }
    });
    const clearCurrentGridPos = x$3(() => setCurrentGridPos(null), []);
    return [currentGridPos, clearCurrentGridPos];
  }
  const getTargetEventId = (itemType, area, behavior) => {
    function isEventDraggingType(_itemType) {
      return new RegExp(`^event/${area}/${behavior}/\\d+$`).test(_itemType);
    }
    if (isNil(itemType)) {
      return null;
    }
    return isEventDraggingType(itemType) ? last(itemType.split("/")) : null;
  };
  function useDraggingEvent(area, behavior) {
    const [isDraggingEnd, setIsDraggingEnd] = p$2(false);
    const [isDraggingCanceled, setIsDraggingCanceled] = p$2(false);
    const [draggingEvent, setDraggingEvent] = p$2(null);
    useTransientUpdate(dndSelector, ({ draggingItemType, draggingEventUIModel, draggingState }) => {
      const targetEventId = getTargetEventId(draggingItemType, area, behavior);
      const hasMatchingTargetEvent = Number(targetEventId) === (draggingEventUIModel == null ? void 0 : draggingEventUIModel.cid());
      const isIdle = draggingState === DraggingState.IDLE;
      const isCanceled = draggingState === DraggingState.CANCELED;
      if (isNil(draggingEvent) && hasMatchingTargetEvent) {
        setDraggingEvent(draggingEventUIModel);
      }
      if (isPresent(draggingEvent) && (isIdle || isCanceled)) {
        setIsDraggingEnd(true);
        setIsDraggingCanceled(isCanceled);
      }
    });
    const clearDraggingEvent = () => {
      setDraggingEvent(null);
      setIsDraggingEnd(false);
      setIsDraggingCanceled(false);
    };
    return {
      isDraggingEnd,
      isDraggingCanceled,
      draggingEvent,
      clearDraggingEvent
    };
  }
  function useAlldayGridRowEventMove({ rowStyleInfo, gridPositionFinder }) {
    const eventBus = useEventBus();
    const {
      isDraggingEnd,
      isDraggingCanceled,
      draggingEvent: movingEvent,
      clearDraggingEvent
    } = useDraggingEvent("dayGrid", "move");
    const startGridXRef = F$2(null);
    const [currentGridPos, clearCurrentGridPos] = useCurrentPointerPositionInGrid(gridPositionFinder);
    const { columnIndex } = currentGridPos != null ? currentGridPos : {};
    const targetEventStartGridX = q$1(
      () => isNil(movingEvent) ? null : rowStyleInfo.findIndex(({ left }) => left === movingEvent.left),
      [rowStyleInfo, movingEvent]
    );
    const currentMovingLeft = q$1(() => {
      if (isNil(columnIndex) || isNil(startGridXRef.current) || isNil(targetEventStartGridX)) {
        return null;
      }
      const newColumnIndex = targetEventStartGridX + columnIndex - startGridXRef.current;
      return newColumnIndex < 0 ? -rowStyleInfo[-newColumnIndex].left : rowStyleInfo[newColumnIndex].left;
    }, [columnIndex, rowStyleInfo, targetEventStartGridX]);
    _$2(() => {
      if (isNil(startGridXRef.current) && isPresent(columnIndex)) {
        startGridXRef.current = columnIndex;
      }
    }, [columnIndex]);
    useWhen(() => {
      const shouldUpdate = !isDraggingCanceled && isPresent(movingEvent) && isPresent(columnIndex) && isPresent(currentMovingLeft) && columnIndex !== startGridXRef.current;
      if (shouldUpdate && isPresent(startGridXRef.current)) {
        const dateOffset = columnIndex - startGridXRef.current;
        const newStartDate = new TZDate(movingEvent.model.getStarts());
        const newEndDate = new TZDate(movingEvent.model.getEnds());
        newStartDate.addDate(dateOffset);
        newEndDate.addDate(dateOffset);
        eventBus.fire("beforeUpdateEvent", {
          event: movingEvent.model.toEventObject(),
          changes: {
            start: newStartDate,
            end: newEndDate
          }
        });
      }
      clearDraggingEvent();
      clearCurrentGridPos();
      startGridXRef.current = null;
    }, isDraggingEnd);
    return q$1(
      () => ({
        movingEvent,
        movingLeft: currentMovingLeft
      }),
      [currentMovingLeft, movingEvent]
    );
  }
  function MovingEventShadow$2({
    rowStyleInfo,
    gridPositionFinder
  }) {
    const { movingEvent, movingLeft } = useAlldayGridRowEventMove({
      rowStyleInfo,
      gridPositionFinder
    });
    if (isNil(movingEvent)) {
      return null;
    }
    return /* @__PURE__ */ y$3(HorizontalEvent, {
      uiModel: movingEvent,
      eventHeight: EVENT_HEIGHT,
      headerHeight: 0,
      movingLeft
    });
  }
  function getEventColIndex(uiModel, row) {
    const start = getGridDateIndex(uiModel.getStarts(), row);
    const end = getGridDateIndex(uiModel.getEnds(), row);
    return { start, end };
  }
  function useAlldayGridRowEventResize({
    weekDates,
    gridColWidthMap,
    gridPositionFinder
  }) {
    const eventBus = useEventBus();
    const {
      isDraggingEnd,
      isDraggingCanceled,
      draggingEvent: resizingEvent,
      clearDraggingEvent
    } = useDraggingEvent("dayGrid", "resize");
    const [currentGridPos, clearCurrentGridPos] = useCurrentPointerPositionInGrid(gridPositionFinder);
    const { columnIndex } = currentGridPos != null ? currentGridPos : {};
    const targetEventGridIndices = q$1(() => {
      if (resizingEvent) {
        return getEventColIndex(resizingEvent, weekDates);
      }
      return { start: -1, end: -1 };
    }, [weekDates, resizingEvent]);
    const resizingWidth = q$1(() => {
      if (targetEventGridIndices.start > -1 && isPresent(columnIndex)) {
        return gridColWidthMap[targetEventGridIndices.start][columnIndex];
      }
      return null;
    }, [columnIndex, gridColWidthMap, targetEventGridIndices.start]);
    useWhen(() => {
      const shouldUpdateEvent = !isDraggingCanceled && isPresent(resizingEvent) && isPresent(columnIndex) && targetEventGridIndices.start <= columnIndex && targetEventGridIndices.end !== columnIndex;
      if (shouldUpdateEvent) {
        const targetDate = weekDates[columnIndex];
        eventBus.fire("beforeUpdateEvent", {
          event: resizingEvent.model.toEventObject(),
          changes: { end: targetDate }
        });
      }
      clearCurrentGridPos();
      clearDraggingEvent();
    }, isDraggingEnd);
    return q$1(
      () => ({
        resizingEvent,
        resizingWidth
      }),
      [resizingWidth, resizingEvent]
    );
  }
  function ResizingEventShadow({ weekDates, gridColWidthMap, gridPositionFinder }) {
    const { resizingEvent, resizingWidth } = useAlldayGridRowEventResize({
      weekDates,
      gridColWidthMap,
      gridPositionFinder
    });
    if (isNil(resizingEvent)) {
      return null;
    }
    return /* @__PURE__ */ y$3(HorizontalEvent, {
      uiModel: resizingEvent,
      eventHeight: EVENT_HEIGHT,
      headerHeight: 0,
      resizingWidth
    });
  }
  function useDOMNode() {
    const [node, setNode] = p$2(null);
    const setNodeRef = x$3((ref) => {
      if (ref) {
        setNode(ref);
      }
    }, []);
    return [node, setNodeRef];
  }
  function useGridRowHeightController(maxTop, category) {
    const [clickedIndex, setClickedIndex] = p$2(0);
    const [isClickedCount, setClickedCount] = p$2(false);
    const { updateDayGridRowHeight } = useDispatch("weekViewLayout");
    const onClickExceedCount = x$3(
      (index) => {
        setClickedCount(true);
        setClickedIndex(index);
        updateDayGridRowHeight({
          rowName: category,
          height: (maxTop + 1) * EVENT_HEIGHT
        });
      },
      [category, maxTop, updateDayGridRowHeight]
    );
    const onClickCollapseButton = x$3(() => {
      setClickedCount(false);
      updateDayGridRowHeight({
        rowName: category,
        height: DEFAULT_PANEL_HEIGHT
      });
    }, [category, updateDayGridRowHeight]);
    return {
      clickedIndex,
      isClickedCount,
      onClickExceedCount,
      onClickCollapseButton
    };
  }
  function requestTimeout(fn2, delay, registerCancel) {
    let start;
    const loop = (timestamp) => {
      if (!start) {
        start = timestamp;
      }
      const elapsed = timestamp - start;
      if (elapsed >= delay) {
        fn2();
        registerCancel(noop);
        return;
      }
      const raf2 = requestAnimationFrame(loop);
      registerCancel(() => cancelAnimationFrame(raf2));
    };
    const raf = requestAnimationFrame(loop);
    registerCancel(() => cancelAnimationFrame(raf));
  }
  function useClickPrevention({
    onClick,
    onDblClick,
    delay = 300
  }) {
    const cancelCallback = F$2(noop);
    const registerCancel = (fn2) => {
      cancelCallback.current = fn2;
    };
    const cancelScheduledWork = () => {
      cancelCallback.current();
    };
    _$2(() => cancelScheduledWork, []);
    const handleClick = (e2) => {
      cancelScheduledWork();
      requestTimeout(onClick.bind(null, e2), delay, registerCancel);
    };
    const handleDblClick = (e2) => {
      cancelScheduledWork();
      onDblClick(e2);
    };
    return [handleClick, handleDblClick];
  }
  const GRID_SELECTION_TYPE_MAP = {
    dayGridMonth: "month",
    dayGridWeek: "allday",
    timeGrid: "time"
  };
  function sortDates(a2, b2) {
    const isIncreased = a2 < b2;
    return isIncreased ? [a2, b2] : [b2, a2];
  }
  function useGridSelection({
    type,
    selectionSorter,
    dateGetter,
    dateCollection,
    gridPositionFinder
  }) {
    const { useFormPopup, gridSelection: gridSelectionOptions } = useStore(optionsSelector);
    const { enableDblClick, enableClick } = gridSelectionOptions;
    const { setGridSelection, addGridSelection, clearAll } = useDispatch("gridSelection");
    const { hideAllPopup, showFormPopup } = useDispatch("popup");
    const eventBus = useEventBus();
    const layoutContainer = useLayoutContainer();
    const [initMousePosition, setInitMousePosition] = p$2(null);
    const [initGridPosition, setInitGridPosition] = p$2(null);
    const isSelectingGridRef = F$2(false);
    const gridSelectionRef = F$2(null);
    useTransientUpdate(
      x$3((state) => state.gridSelection[type], [type]),
      (gridSelection) => {
        gridSelectionRef.current = gridSelection;
      }
    );
    useTransientUpdate(dndSelector, ({ draggingState, draggingItemType }) => {
      isSelectingGridRef.current = draggingItemType === currentGridSelectionType && draggingState >= DraggingState.INIT;
    });
    const currentGridSelectionType = DRAGGING_TYPE_CREATORS.gridSelection(type);
    const setGridSelectionByPosition = (e2) => {
      const gridPosition = gridPositionFinder(e2);
      if (isPresent(initGridPosition) && isPresent(gridPosition)) {
        setGridSelection(type, selectionSorter(initGridPosition, gridPosition));
      }
    };
    const [handleClickWithDebounce, handleDblClickPreventingClick] = useClickPrevention({
      onClick: (e2) => {
        if (enableClick) {
          onMouseUp(e2, true);
        }
      },
      onDblClick: (e2) => {
        if (enableDblClick) {
          onMouseUp(e2, true);
        }
      },
      delay: 250
    });
    const onMouseUpWithClick = (e2) => {
      const isClick = e2.detail <= 1;
      if (!enableClick && (!enableDblClick || isClick)) {
        return;
      }
      if (enableClick) {
        if (isClick) {
          handleClickWithDebounce(e2);
        } else {
          handleDblClickPreventingClick(e2);
        }
        return;
      }
      onMouseUp(e2, true);
    };
    const onMouseUp = (e2, isClickEvent) => {
      var _a;
      if (isClickEvent) {
        setGridSelectionByPosition(e2);
      }
      if (isPresent(gridSelectionRef.current)) {
        const [startDate, endDate] = sortDates(
          ...dateGetter(dateCollection, gridSelectionRef.current)
        );
        if (useFormPopup && isPresent(initMousePosition)) {
          const popupArrowPointPosition = {
            top: (e2.clientY + initMousePosition.y) / 2,
            left: (e2.clientX + initMousePosition.x) / 2
          };
          showFormPopup({
            isCreationPopup: true,
            title: "",
            location: "",
            start: startDate,
            end: endDate,
            isAllday: type !== "timeGrid",
            isPrivate: false,
            popupArrowPointPosition,
            close: clearAll
          });
        }
        const gridSelectionSelector = `.${cls(GRID_SELECTION_TYPE_MAP[type])}.${cls(
        "grid-selection"
      )}`;
        const gridSelectionElements = Array.from(
          (_a = layoutContainer == null ? void 0 : layoutContainer.querySelectorAll(gridSelectionSelector)) != null ? _a : []
        );
        eventBus.fire("selectDateTime", {
          start: startDate.toDate(),
          end: endDate.toDate(),
          isAllday: type !== "timeGrid",
          nativeEvent: e2,
          gridSelectionElements
        });
      }
    };
    const clearGridSelection = x$3(() => {
      setInitMousePosition(null);
      setInitGridPosition(null);
      setGridSelection(type, null);
    }, [setGridSelection, type]);
    const onMouseDown = useDrag(currentGridSelectionType, {
      onInit: (e2) => {
        if (useFormPopup) {
          setInitMousePosition({
            x: e2.clientX,
            y: e2.clientY
          });
          hideAllPopup();
        }
        const gridPosition = gridPositionFinder(e2);
        if (isPresent(gridPosition)) {
          setInitGridPosition(gridPosition);
        }
        if (!useFormPopup) {
          addGridSelection(type, gridSelectionRef.current);
        }
      },
      onDragStart: (e2) => {
        setGridSelectionByPosition(e2);
      },
      onDrag: (e2) => {
        if (isSelectingGridRef.current) {
          setGridSelectionByPosition(e2);
        }
      },
      onMouseUp: (e2, { draggingState }) => {
        e2.stopPropagation();
        const isClickEvent = draggingState <= DraggingState.INIT;
        if (isClickEvent) {
          onMouseUpWithClick(e2);
        } else {
          onMouseUp(e2, isClickEvent);
        }
      },
      onPressESCKey: clearGridSelection
    });
    _$2(() => clearGridSelection, [clearGridSelection]);
    return onMouseDown;
  }
  const rowTitleTemplate = `alldayTitle`;
  function AlldayGridRow({
    events,
    weekDates,
    height = DEFAULT_PANEL_HEIGHT,
    options = {},
    rowStyleInfo,
    gridColWidthMap
  }) {
    const { isReadOnly } = useStore(optionsSelector);
    const dayGridLeftTheme = useTheme(weekDayGridLeftSelector);
    const [panelContainer, setPanelContainerRef] = useDOMNode();
    const { narrowWeekend = false, startDayOfWeek = Day$2.SUN } = options;
    const maxTop = q$1(() => Math.max(0, ...events.map(({ top }) => top)), [events]);
    const gridPositionFinder = q$1(
      () => createGridPositionFinder({
        container: panelContainer,
        rowsCount: 1,
        columnsCount: weekDates.length,
        narrowWeekend,
        startDayOfWeek
      }),
      [panelContainer, weekDates.length, narrowWeekend, startDayOfWeek]
    );
    const { clickedIndex, isClickedCount, onClickExceedCount, onClickCollapseButton } = useGridRowHeightController(maxTop, "allday");
    const horizontalEvents = q$1(
      () => events.filter(isWithinHeight(height, EVENT_HEIGHT + WEEK_EVENT_MARGIN_TOP)).map((uiModel) => /* @__PURE__ */ y$3(HorizontalEvent, {
        key: `allday-DayEvent-${uiModel.cid()}`,
        uiModel,
        eventHeight: EVENT_HEIGHT,
        headerHeight: 0
      })),
      [events, height]
    );
    const startGridSelection = useGridSelection({
      type: "dayGridWeek",
      gridPositionFinder,
      dateCollection: weekDates,
      selectionSorter: alldayGridRowSelectionHelper.sortSelection,
      dateGetter: alldayGridRowSelectionHelper.getDateFromCollection
    });
    const onMouseDown = (e2) => {
      const target = e2.target;
      if (isReadOnly || !target.classList.contains(cls("panel-grid"))) {
        return;
      }
      startGridSelection(e2);
    };
    return /* @__PURE__ */ y$3(g$2, null, /* @__PURE__ */ y$3("div", {
      className: cls("panel-title"),
      style: dayGridLeftTheme
    }, /* @__PURE__ */ y$3(Template, {
      template: rowTitleTemplate,
      param: "alldayTitle"
    })), /* @__PURE__ */ y$3("div", {
      className: cls("allday-panel"),
      ref: setPanelContainerRef,
      onMouseDown
    }, /* @__PURE__ */ y$3("div", {
      className: cls("panel-grid-wrapper")
    }, /* @__PURE__ */ y$3(GridCells, {
      uiModels: events,
      weekDates,
      narrowWeekend,
      height,
      clickedIndex,
      isClickedCount,
      onClickExceedCount,
      onClickCollapseButton
    })), /* @__PURE__ */ y$3("div", {
      className: cls(`panel-allday-events`)
    }, horizontalEvents), /* @__PURE__ */ y$3(ResizingEventShadow, {
      weekDates,
      gridPositionFinder,
      gridColWidthMap
    }), /* @__PURE__ */ y$3(MovingEventShadow$2, {
      rowStyleInfo,
      gridPositionFinder
    }), /* @__PURE__ */ y$3(AlldayGridSelection, {
      weekDates,
      narrowWeekend
    })));
  }
  function OtherGridRow({
    events,
    weekDates,
    category,
    height = DEFAULT_PANEL_HEIGHT,
    options = {}
  }) {
    const dayGridLeftTheme = useTheme(weekDayGridLeftSelector);
    const maxTop = q$1(() => Math.max(0, ...events.map(({ top }) => top)), [events]);
    const { narrowWeekend = false } = options;
    const rowTitleTemplate2 = `${category}Title`;
    const { clickedIndex, isClickedCount, onClickExceedCount, onClickCollapseButton } = useGridRowHeightController(maxTop, category);
    const horizontalEvents = q$1(
      () => events.filter(isWithinHeight(height, EVENT_HEIGHT + WEEK_EVENT_MARGIN_TOP)).map((uiModel) => /* @__PURE__ */ y$3(HorizontalEvent, {
        key: `${category}-DayEvent-${uiModel.cid()}`,
        uiModel,
        eventHeight: EVENT_HEIGHT,
        headerHeight: 0
      })),
      [category, events, height]
    );
    return /* @__PURE__ */ y$3(g$2, null, /* @__PURE__ */ y$3("div", {
      className: cls("panel-title"),
      style: dayGridLeftTheme
    }, /* @__PURE__ */ y$3(Template, {
      template: rowTitleTemplate2,
      param: category
    })), /* @__PURE__ */ y$3("div", {
      className: cls("allday-panel")
    }, /* @__PURE__ */ y$3("div", {
      className: cls("panel-grid-wrapper")
    }, /* @__PURE__ */ y$3(GridCells, {
      uiModels: events,
      weekDates,
      narrowWeekend,
      height,
      clickedIndex,
      isClickedCount,
      onClickExceedCount,
      onClickCollapseButton
    })), /* @__PURE__ */ y$3("div", {
      className: cls(`panel-${category}-events`)
    }, horizontalEvents)));
  }
  const classNames$j = {
    detailItem: cls("detail-item"),
    detailItemIndent: cls("detail-item", "detail-item-indent"),
    detailItemSeparate: cls("detail-item", "detail-item-separate"),
    sectionDetail: cls("popup-section", "section-detail"),
    content: cls("content"),
    locationIcon: cls("icon", "ic-location-b"),
    repeatIcon: cls("icon", "ic-repeat-b"),
    userIcon: cls("icon", "ic-user-b"),
    stateIcon: cls("icon", "ic-state-b"),
    calendarDotIcon: cls("icon", "calendar-dot")
  };
  function EventDetailSectionDetail({ event }) {
    var _a, _b;
    const { location: location2, recurrenceRule, attendees, state, calendarId, body } = event;
    const calendar = useCalendarById(calendarId);
    return /* @__PURE__ */ y$3("div", {
      className: classNames$j.sectionDetail
    }, location2 && /* @__PURE__ */ y$3("div", {
      className: classNames$j.detailItem
    }, /* @__PURE__ */ y$3("span", {
      className: classNames$j.locationIcon
    }), /* @__PURE__ */ y$3("span", {
      className: classNames$j.content
    }, /* @__PURE__ */ y$3(Template, {
      template: "popupDetailLocation",
      param: event,
      as: "span"
    }))), recurrenceRule && /* @__PURE__ */ y$3("div", {
      className: classNames$j.detailItem
    }, /* @__PURE__ */ y$3("span", {
      className: classNames$j.repeatIcon
    }), /* @__PURE__ */ y$3("span", {
      className: classNames$j.content
    }, /* @__PURE__ */ y$3(Template, {
      template: "popupDetailRecurrenceRule",
      param: event,
      as: "span"
    }))), attendees && /* @__PURE__ */ y$3("div", {
      className: classNames$j.detailItemIndent
    }, /* @__PURE__ */ y$3("span", {
      className: classNames$j.userIcon
    }), /* @__PURE__ */ y$3("span", {
      className: classNames$j.content
    }, /* @__PURE__ */ y$3(Template, {
      template: "popupDetailAttendees",
      param: event,
      as: "span"
    }))), state && /* @__PURE__ */ y$3("div", {
      className: classNames$j.detailItem
    }, /* @__PURE__ */ y$3("span", {
      className: classNames$j.stateIcon
    }), /* @__PURE__ */ y$3("span", {
      className: classNames$j.content
    }, /* @__PURE__ */ y$3(Template, {
      template: "popupDetailState",
      param: event,
      as: "span"
    }))), calendar && /* @__PURE__ */ y$3("div", {
      className: classNames$j.detailItem
    }, /* @__PURE__ */ y$3("span", {
      className: classNames$j.calendarDotIcon,
      style: {
        backgroundColor: (_a = calendar == null ? void 0 : calendar.backgroundColor) != null ? _a : ""
      }
    }), /* @__PURE__ */ y$3("span", {
      className: classNames$j.content
    }, (_b = calendar == null ? void 0 : calendar.name) != null ? _b : "")), body && /* @__PURE__ */ y$3("div", {
      className: classNames$j.detailItemSeparate
    }, /* @__PURE__ */ y$3("span", {
      className: classNames$j.content
    }, /* @__PURE__ */ y$3(Template, {
      template: "popupDetailBody",
      param: event,
      as: "span"
    }))));
  }
  const classNames$i = {
    sectionHeader: cls("popup-section", "section-header"),
    content: cls("content"),
    eventTitle: cls("event-title")
  };
  function EventDetailSectionHeader({ event }) {
    return /* @__PURE__ */ y$3("div", {
      className: classNames$i.sectionHeader
    }, /* @__PURE__ */ y$3("div", {
      className: classNames$i.eventTitle
    }, /* @__PURE__ */ y$3(Template, {
      template: "popupDetailTitle",
      param: event,
      as: "span"
    })), /* @__PURE__ */ y$3("div", {
      className: classNames$i.content
    }, /* @__PURE__ */ y$3(Template, {
      template: "popupDetailDate",
      param: event,
      as: "span"
    })));
  }
  const SEE_MORE_POPUP_SLOT_CLASS_NAME = cls("see-more-popup-slot");
  const EVENT_FORM_POPUP_SLOT_CLASS_NAME = cls("event-form-popup-slot");
  const EVENT_DETAIL_POPUP_SLOT_CLASS_NAME = cls("event-detail-popup-slot");
  const HALF_OF_POPUP_ARROW_HEIGHT = 8;
  const BOOLEAN_KEYS_OF_EVENT_MODEL_DATA = [
    "isPrivate",
    "isAllday",
    "isPending",
    "isFocused",
    "isVisible",
    "isReadOnly"
  ];
  var DetailPopupArrowDirection = /* @__PURE__ */ ((DetailPopupArrowDirection2) => {
    DetailPopupArrowDirection2["right"] = "right";
    DetailPopupArrowDirection2["left"] = "left";
    return DetailPopupArrowDirection2;
  })(DetailPopupArrowDirection || {});
  var FormPopupArrowDirection = /* @__PURE__ */ ((FormPopupArrowDirection2) => {
    FormPopupArrowDirection2["top"] = "top";
    FormPopupArrowDirection2["bottom"] = "bottom";
    return FormPopupArrowDirection2;
  })(FormPopupArrowDirection || {});
  const FloatingLayerContext = E$2(null);
  function FloatingLayerProvider({ children }) {
    const [containerRef, containerRefCallback] = useDOMNode();
    const [seeMorePopupSlotRef, seeMorePopupSlotRefCallback] = useDOMNode();
    const [formPopupSlotRef, formPopupSlotRefCallback] = useDOMNode();
    const [detailPopupSlotRef, detailPopupSlotRefCallback] = useDOMNode();
    const floatingLayer = {
      container: containerRef,
      seeMorePopupSlot: seeMorePopupSlotRef,
      formPopupSlot: formPopupSlotRef,
      detailPopupSlot: detailPopupSlotRef
    };
    return /* @__PURE__ */ y$3(FloatingLayerContext.Provider, {
      value: floatingLayer
    }, children, /* @__PURE__ */ y$3("div", {
      ref: containerRefCallback,
      className: cls("floating-layer")
    }, /* @__PURE__ */ y$3("div", {
      ref: seeMorePopupSlotRefCallback,
      className: SEE_MORE_POPUP_SLOT_CLASS_NAME
    }), /* @__PURE__ */ y$3("div", {
      ref: formPopupSlotRefCallback,
      className: EVENT_FORM_POPUP_SLOT_CLASS_NAME
    }), /* @__PURE__ */ y$3("div", {
      ref: detailPopupSlotRefCallback,
      className: EVENT_DETAIL_POPUP_SLOT_CLASS_NAME
    })));
  }
  const useFloatingLayer = (floatingLayerType) => {
    var _a;
    const floatingLayers = P$2(FloatingLayerContext);
    if (isUndefined_1(floatingLayers)) {
      throw new Error("FloatingLayerProvider is not found");
    }
    return (_a = floatingLayers == null ? void 0 : floatingLayers[floatingLayerType]) != null ? _a : null;
  };
  function isTopOutOfLayout(top, layoutRect, popupRect) {
    return top + popupRect.height > layoutRect.top + layoutRect.height;
  }
  function isLeftOutOfLayout(left, layoutRect, popupRect) {
    return left + popupRect.width > layoutRect.left + layoutRect.width;
  }
  const eventFormPopupParamSelector = (state) => {
    return state.popup[PopupType.Form];
  };
  const eventDetailPopupParamSelector = (state) => {
    return state.popup[PopupType.Detail];
  };
  const seeMorePopupParamSelector = (state) => {
    return state.popup[PopupType.SeeMore];
  };
  const classNames$h = {
    popupContainer: cls("popup-container"),
    detailContainer: cls("detail-container"),
    topLine: cls("popup-top-line"),
    border: cls("popup-arrow-border"),
    fill: cls("popup-arrow-fill"),
    sectionButton: cls("popup-section", "section-button"),
    content: cls("content"),
    editIcon: cls("icon", "ic-edit"),
    deleteIcon: cls("icon", "ic-delete"),
    editButton: cls("edit-button"),
    deleteButton: cls("delete-button"),
    verticalLine: cls("vertical-line")
  };
  function calculatePopupPosition$1(eventRect, layoutRect, popupRect) {
    let top = eventRect.top + eventRect.height / 2 - popupRect.height / 2;
    let left = eventRect.left + eventRect.width;
    if (isTopOutOfLayout(top, layoutRect, popupRect)) {
      top = layoutRect.top + layoutRect.height - popupRect.height;
    }
    if (isLeftOutOfLayout(left, layoutRect, popupRect)) {
      left = eventRect.left - popupRect.width;
    }
    return [
      Math.max(top, layoutRect.top) + window.scrollY,
      Math.max(left, layoutRect.left) + window.scrollX
    ];
  }
  function calculatePopupArrowPosition(eventRect, layoutRect, popupRect) {
    const top = eventRect.top + eventRect.height / 2 + window.scrollY;
    const popupLeft = eventRect.left + eventRect.width;
    const isOutOfLayout = popupLeft + popupRect.width > layoutRect.left + layoutRect.width;
    const direction = isOutOfLayout ? DetailPopupArrowDirection.right : DetailPopupArrowDirection.left;
    return { top, direction };
  }
  function EventDetailPopup() {
    const { useFormPopup } = useStore(optionsSelector);
    const popupParams = useStore(eventDetailPopupParamSelector);
    const { event, eventRect } = popupParams != null ? popupParams : {};
    const { showFormPopup, hideDetailPopup } = useDispatch("popup");
    const calendarColor = useCalendarColor(event);
    const layoutContainer = useLayoutContainer();
    const detailPopupSlot = useFloatingLayer("detailPopupSlot");
    const eventBus = useEventBus();
    const popupContainerRef = F$2(null);
    const [style, setStyle] = p$2({});
    const [arrowTop, setArrowTop] = p$2(0);
    const [arrowDirection, setArrowDirection] = p$2(
      DetailPopupArrowDirection.left
    );
    const popupArrowClassName = q$1(() => {
      const right = arrowDirection === DetailPopupArrowDirection.right;
      const left = arrowDirection === DetailPopupArrowDirection.left;
      return cls("popup-arrow", { right, left });
    }, [arrowDirection]);
    A$2(() => {
      if (popupContainerRef.current && eventRect && layoutContainer) {
        const layoutRect = layoutContainer.getBoundingClientRect();
        const popupRect = popupContainerRef.current.getBoundingClientRect();
        const [top, left] = calculatePopupPosition$1(eventRect, layoutRect, popupRect);
        const { top: arrowTopPosition, direction } = calculatePopupArrowPosition(
          eventRect,
          layoutRect,
          popupRect
        );
        setStyle({ top, left });
        setArrowTop(arrowTopPosition - top - HALF_OF_POPUP_ARROW_HEIGHT);
        setArrowDirection(direction);
      }
    }, [eventRect, layoutContainer]);
    if (isNil(event) || isNil(eventRect) || isNil(detailPopupSlot)) {
      return null;
    }
    const {
      title = "",
      isAllday: isAllday2 = false,
      start = new TZDate(),
      end = new TZDate(),
      location: location2,
      state,
      isReadOnly,
      isPrivate
    } = event;
    const popupArrowPointPosition = {
      top: eventRect.top + eventRect.height / 2,
      left: eventRect.left + eventRect.width / 2
    };
    const onClickEditButton = () => {
      if (useFormPopup) {
        showFormPopup({
          isCreationPopup: false,
          event,
          title,
          location: location2,
          start,
          end,
          isAllday: isAllday2,
          isPrivate,
          eventState: state,
          popupArrowPointPosition
        });
      } else {
        eventBus.fire("beforeUpdateEvent", { event: event.toEventObject(), changes: {} });
      }
    };
    const onClickDeleteButton = () => {
      eventBus.fire("beforeDeleteEvent", event.toEventObject());
      hideDetailPopup();
    };
    return j$1(
      /* @__PURE__ */ y$3("div", {
        role: "dialog",
        className: classNames$h.popupContainer,
        ref: popupContainerRef,
        style
      }, /* @__PURE__ */ y$3("div", {
        className: classNames$h.detailContainer
      }, /* @__PURE__ */ y$3(EventDetailSectionHeader, {
        event
      }), /* @__PURE__ */ y$3(EventDetailSectionDetail, {
        event
      }), !isReadOnly && /* @__PURE__ */ y$3("div", {
        className: classNames$h.sectionButton
      }, /* @__PURE__ */ y$3("button", {
        type: "button",
        className: classNames$h.editButton,
        onClick: onClickEditButton
      }, /* @__PURE__ */ y$3("span", {
        className: classNames$h.editIcon
      }), /* @__PURE__ */ y$3("span", {
        className: classNames$h.content
      }, /* @__PURE__ */ y$3(Template, {
        template: "popupEdit",
        as: "span"
      }))), /* @__PURE__ */ y$3("div", {
        className: classNames$h.verticalLine
      }), /* @__PURE__ */ y$3("button", {
        type: "button",
        className: classNames$h.deleteButton,
        onClick: onClickDeleteButton
      }, /* @__PURE__ */ y$3("span", {
        className: classNames$h.deleteIcon
      }), /* @__PURE__ */ y$3("span", {
        className: classNames$h.content
      }, /* @__PURE__ */ y$3(Template, {
        template: "popupDelete",
        as: "span"
      }))))), /* @__PURE__ */ y$3("div", {
        className: classNames$h.topLine,
        style: { backgroundColor: calendarColor.backgroundColor }
      }), /* @__PURE__ */ y$3("div", {
        className: popupArrowClassName
      }, /* @__PURE__ */ y$3("div", {
        className: classNames$h.border,
        style: { top: arrowTop }
      }, /* @__PURE__ */ y$3("div", {
        className: classNames$h.fill
      })))),
      detailPopupSlot
    );
  }
  const classNames$g = {
    dropdownMenu: cls("dropdown-menu"),
    dropdownMenuItem: cls("dropdown-menu-item"),
    dotIcon: cls("icon", "dot"),
    content: cls("content")
  };
  function DropdownMenuItem({ index, name, backgroundColor, onClick }) {
    return /* @__PURE__ */ y$3("li", {
      className: classNames$g.dropdownMenuItem,
      onClick: (e2) => onClick(e2, index)
    }, /* @__PURE__ */ y$3("span", {
      className: classNames$g.dotIcon,
      style: { backgroundColor }
    }), /* @__PURE__ */ y$3("span", {
      className: classNames$g.content
    }, name));
  }
  function CalendarDropdownMenu({ calendars, setOpened, onChangeIndex }) {
    const handleDropdownMenuItemClick = (e2, index) => {
      e2.stopPropagation();
      setOpened(false);
      onChangeIndex(index);
    };
    return /* @__PURE__ */ y$3("ul", {
      className: classNames$g.dropdownMenu
    }, calendars.map(({ name, backgroundColor = "000" }, index) => /* @__PURE__ */ y$3(DropdownMenuItem, {
      key: `dropdown-${name}-${index}`,
      index,
      name,
      backgroundColor,
      onClick: handleDropdownMenuItemClick
    })));
  }
  function PopupSection({
    children,
    classNames: classNames2 = [],
    onClick = noop
  }) {
    return /* @__PURE__ */ y$3("div", {
      className: cls("popup-section", ...classNames2),
      onClick
    }, children);
  }
  function useDropdownState() {
    const [isOpened, setOpened] = p$2(false);
    const toggleDropdown = () => setOpened((prev) => !prev);
    return { isOpened, setOpened, toggleDropdown };
  }
  var FormStateActionType = /* @__PURE__ */ ((FormStateActionType2) => {
    FormStateActionType2["init"] = "init";
    FormStateActionType2["setCalendarId"] = "setCalendarId";
    FormStateActionType2["setTitle"] = "setTitle";
    FormStateActionType2["setLocation"] = "setLocation";
    FormStateActionType2["setPrivate"] = "setPrivate";
    FormStateActionType2["setAllday"] = "setAllday";
    FormStateActionType2["setState"] = "setState";
    FormStateActionType2["reset"] = "reset";
    return FormStateActionType2;
  })(FormStateActionType || {});
  const defaultFormState = {
    title: "",
    location: "",
    isAllday: false,
    isPrivate: false,
    state: "Busy"
  };
  function formStateReducer(state, action) {
    switch (action.type) {
      case "init":
        return __spreadValues(__spreadValues({}, defaultFormState), action.event);
      case "setCalendarId":
        return __spreadProps(__spreadValues({}, state), { calendarId: action.calendarId });
      case "setTitle":
        return __spreadProps(__spreadValues({}, state), { title: action.title });
      case "setLocation":
        return __spreadProps(__spreadValues({}, state), { location: action.location });
      case "setPrivate":
        return __spreadProps(__spreadValues({}, state), { isPrivate: action.isPrivate });
      case "setAllday":
        return __spreadProps(__spreadValues({}, state), { isAllday: action.isAllday });
      case "setState":
        return __spreadProps(__spreadValues({}, state), { state: action.state });
      case "reset":
        return __spreadValues(__spreadValues({}, state), defaultFormState);
      default:
        return state;
    }
  }
  function useFormState(initCalendarId) {
    return y$2(formStateReducer, __spreadValues({ calendarId: initCalendarId }, defaultFormState));
  }
  const classNames$f = {
    popupSection: ["dropdown-section", "calendar-section"],
    popupSectionItem: cls("popup-section-item", "popup-button"),
    dotIcon: cls("icon", "dot"),
    content: cls("content", "event-calendar")
  };
  function CalendarSelector({ calendars, selectedCalendarId, formStateDispatch }) {
    const { isOpened, setOpened, toggleDropdown } = useDropdownState();
    const selectedCalendar = calendars.find((calendar) => calendar.id === selectedCalendarId);
    const { backgroundColor = "", name = "" } = selectedCalendar != null ? selectedCalendar : {};
    const changeIndex = (index) => formStateDispatch({ type: FormStateActionType.setCalendarId, calendarId: calendars[index].id });
    return /* @__PURE__ */ y$3(PopupSection, {
      onClick: toggleDropdown,
      classNames: classNames$f.popupSection
    }, /* @__PURE__ */ y$3("button", {
      type: "button",
      className: classNames$f.popupSectionItem
    }, /* @__PURE__ */ y$3("span", {
      className: classNames$f.dotIcon,
      style: { backgroundColor }
    }), /* @__PURE__ */ y$3("span", {
      className: classNames$f.content
    }, name), /* @__PURE__ */ y$3("span", {
      className: cls("icon", "ic-dropdown-arrow", { open: isOpened })
    })), isOpened && /* @__PURE__ */ y$3(CalendarDropdownMenu, {
      calendars,
      setOpened,
      onChangeIndex: changeIndex
    }));
  }
  const classNames$e = {
    closeButton: cls("popup-button", "popup-close"),
    closeIcon: cls("icon", "ic-close")
  };
  function ClosePopupButton({ type, close }) {
    const { hideAllPopup } = useDispatch("popup");
    const onClickHandler = () => {
      hideAllPopup();
      if (isFunction$2(close)) {
        close();
      }
    };
    return /* @__PURE__ */ y$3("button", {
      type: "button",
      className: classNames$e.closeButton,
      onClick: onClickHandler
    }, type === "moreEvents" ? /* @__PURE__ */ y$3(Template, {
      template: "monthMoreClose"
    }) : /* @__PURE__ */ y$3("i", {
      className: classNames$e.closeIcon
    }));
  }
  const classNames$d = {
    confirmButton: cls("popup-button", "popup-confirm")
  };
  function ConfirmPopupButton({ children }) {
    return /* @__PURE__ */ y$3("button", {
      type: "submit",
      className: classNames$d.confirmButton
    }, /* @__PURE__ */ y$3("span", null, children));
  }
  function useStringOnlyTemplate({
    template,
    model,
    defaultValue = ""
  }) {
    const templates2 = useStore(templateSelector);
    const templateFunc = templates2[template];
    if (isNil(templateFunc)) {
      return defaultValue;
    }
    let result = templateFunc(model);
    if (!isString_1(result)) {
      result = defaultValue;
    }
    return result;
  }
  const classNames$c = {
    datePickerContainer: cls("datepicker-container"),
    datePicker: cls("popup-section-item", "popup-date-picker"),
    allday: cls("popup-section-item", "popup-section-allday"),
    dateIcon: cls("icon", "ic-date"),
    dateDash: cls("popup-date-dash"),
    content: cls("content")
  };
  const DateSelector = N(function DateSelector2({ start, end, isAllday: isAllday2 = false, formStateDispatch }, ref) {
    const { usageStatistics } = useStore(optionsSelector);
    const startPickerContainerRef = F$2(null);
    const startPickerInputRef = F$2(null);
    const endPickerContainerRef = F$2(null);
    const endPickerInputRef = F$2(null);
    const startDatePlaceholder = useStringOnlyTemplate({
      template: "startDatePlaceholder",
      defaultValue: "Start Date"
    });
    const endDatePlaceholder = useStringOnlyTemplate({
      template: "endDatePlaceholder",
      defaultValue: "End Date"
    });
    const toggleAllday = () => formStateDispatch({ type: FormStateActionType.setAllday, isAllday: !isAllday2 });
    _$2(() => {
      if (startPickerContainerRef.current && startPickerInputRef.current && endPickerContainerRef.current && endPickerInputRef.current) {
        const startDate = new TZDate(start);
        const endDate = new TZDate(end);
        if (isAllday2) {
          startDate.setHours(12, 0, 0);
          endDate.setHours(13, 0, 0);
        }
        ref.current = DatePicker.createRangePicker({
          startpicker: {
            date: startDate.toDate(),
            input: startPickerInputRef.current,
            container: startPickerContainerRef.current
          },
          endpicker: {
            date: endDate.toDate(),
            input: endPickerInputRef.current,
            container: endPickerContainerRef.current
          },
          format: isAllday2 ? "yyyy-MM-dd" : "yyyy-MM-dd HH:mm",
          timePicker: isAllday2 ? false : {
            showMeridiem: false,
            usageStatistics
          },
          usageStatistics
        });
      }
    }, [start, end, isAllday2, usageStatistics, ref]);
    return /* @__PURE__ */ y$3(PopupSection, null, /* @__PURE__ */ y$3("div", {
      className: classNames$c.datePicker
    }, /* @__PURE__ */ y$3("span", {
      className: classNames$c.dateIcon
    }), /* @__PURE__ */ y$3("input", {
      name: "start",
      className: classNames$c.content,
      placeholder: startDatePlaceholder,
      ref: startPickerInputRef
    }), /* @__PURE__ */ y$3("div", {
      className: classNames$c.datePickerContainer,
      ref: startPickerContainerRef
    })), /* @__PURE__ */ y$3("span", {
      className: classNames$c.dateDash
    }, "-"), /* @__PURE__ */ y$3("div", {
      className: classNames$c.datePicker
    }, /* @__PURE__ */ y$3("span", {
      className: classNames$c.dateIcon
    }), /* @__PURE__ */ y$3("input", {
      name: "end",
      className: classNames$c.content,
      placeholder: endDatePlaceholder,
      ref: endPickerInputRef
    }), /* @__PURE__ */ y$3("div", {
      className: classNames$c.datePickerContainer,
      ref: endPickerContainerRef
    })), /* @__PURE__ */ y$3("div", {
      className: classNames$c.allday,
      onClick: toggleAllday
    }, /* @__PURE__ */ y$3("span", {
      className: cls("icon", {
        "ic-checkbox-normal": !isAllday2,
        "ic-checkbox-checked": isAllday2
      })
    }), /* @__PURE__ */ y$3("span", {
      className: classNames$c.content
    }, /* @__PURE__ */ y$3(Template, {
      template: "popupIsAllday"
    })), /* @__PURE__ */ y$3("input", {
      name: "isAllday",
      type: "checkbox",
      className: cls("hidden-input"),
      value: isAllday2 ? "true" : "false",
      checked: isAllday2
    })));
  });
  const EVENT_STATES = ["Busy", "Free"];
  const classNames$b = {
    popupSectionItem: cls("popup-section-item", "dropdown-menu-item"),
    dropdownMenu: cls("dropdown-menu"),
    icon: cls("icon"),
    content: cls("content")
  };
  function StateDropdownMenu({ setOpened, setEventState }) {
    const onClickDropdown = (e2, state) => {
      e2.stopPropagation();
      setOpened(false);
      setEventState(state);
    };
    return /* @__PURE__ */ y$3("ul", {
      className: classNames$b.dropdownMenu
    }, EVENT_STATES.map((state) => /* @__PURE__ */ y$3("li", {
      key: state,
      className: classNames$b.popupSectionItem,
      onClick: (e2) => onClickDropdown(e2, state)
    }, /* @__PURE__ */ y$3("span", {
      className: classNames$b.icon
    }), /* @__PURE__ */ y$3("span", {
      className: classNames$b.content
    }, state === "Busy" ? /* @__PURE__ */ y$3(Template, {
      template: "popupStateBusy"
    }) : /* @__PURE__ */ y$3(Template, {
      template: "popupStateFree"
    })))));
  }
  const classNames$a = {
    popupSection: ["dropdown-section", "state-section"],
    popupSectionItem: cls("popup-section-item", "popup-button"),
    stateIcon: cls("icon", "ic-state"),
    arrowIcon: cls("icon", "ic-dropdown-arrow"),
    content: cls("content", "event-state")
  };
  function EventStateSelector({ eventState = "Busy", formStateDispatch }) {
    const { isOpened, setOpened, toggleDropdown } = useDropdownState();
    const handleChangeEventState = (state) => formStateDispatch({ type: FormStateActionType.setState, state });
    return /* @__PURE__ */ y$3(PopupSection, {
      onClick: toggleDropdown,
      classNames: classNames$a.popupSection
    }, /* @__PURE__ */ y$3("button", {
      type: "button",
      className: classNames$a.popupSectionItem
    }, /* @__PURE__ */ y$3("span", {
      className: classNames$a.stateIcon
    }), /* @__PURE__ */ y$3("span", {
      className: classNames$a.content
    }, eventState === "Busy" ? /* @__PURE__ */ y$3(Template, {
      template: "popupStateBusy"
    }) : /* @__PURE__ */ y$3(Template, {
      template: "popupStateFree"
    })), /* @__PURE__ */ y$3("span", {
      className: classNames$a.arrowIcon
    })), isOpened && /* @__PURE__ */ y$3(StateDropdownMenu, {
      setOpened,
      setEventState: handleChangeEventState
    }));
  }
  const classNames$9 = {
    popupSectionItem: cls("popup-section-item", "popup-section-location"),
    locationIcon: cls("icon", "ic-location"),
    content: cls("content")
  };
  function LocationInputBox({ location: location2, formStateDispatch }) {
    const locationPlaceholder = useStringOnlyTemplate({
      template: "locationPlaceholder",
      defaultValue: "Location"
    });
    const handleLocationChange = (e2) => {
      formStateDispatch({ type: FormStateActionType.setLocation, location: e2.currentTarget.value });
    };
    return /* @__PURE__ */ y$3(PopupSection, null, /* @__PURE__ */ y$3("div", {
      className: classNames$9.popupSectionItem
    }, /* @__PURE__ */ y$3("span", {
      className: classNames$9.locationIcon
    }), /* @__PURE__ */ y$3("input", {
      name: "location",
      className: classNames$9.content,
      placeholder: locationPlaceholder,
      value: location2,
      onChange: handleLocationChange
    })));
  }
  const classNames$8 = {
    popupSectionItem: cls("popup-section-item", "popup-section-title"),
    privateButton: cls("popup-section-item", "popup-section-private", "popup-button"),
    titleIcon: cls("icon", "ic-title"),
    content: cls("content")
  };
  function TitleInputBox({ title, isPrivate = false, formStateDispatch }) {
    const titlePlaceholder = useStringOnlyTemplate({
      template: "titlePlaceholder",
      defaultValue: "Subject"
    });
    const togglePrivate = () => formStateDispatch({ type: FormStateActionType.setPrivate, isPrivate: !isPrivate });
    const handleInputChange = (e2) => {
      formStateDispatch({ type: FormStateActionType.setTitle, title: e2.currentTarget.value });
    };
    return /* @__PURE__ */ y$3(PopupSection, null, /* @__PURE__ */ y$3("div", {
      className: classNames$8.popupSectionItem
    }, /* @__PURE__ */ y$3("span", {
      className: classNames$8.titleIcon
    }), /* @__PURE__ */ y$3("input", {
      name: "title",
      className: classNames$8.content,
      placeholder: titlePlaceholder,
      value: title,
      onChange: handleInputChange,
      required: true
    })), /* @__PURE__ */ y$3("button", {
      type: "button",
      className: classNames$8.privateButton,
      onClick: togglePrivate
    }, /* @__PURE__ */ y$3("span", {
      className: cls("icon", { "ic-private": isPrivate, "ic-public": !isPrivate })
    }), /* @__PURE__ */ y$3("input", {
      name: "isPrivate",
      type: "checkbox",
      className: cls("hidden-input"),
      value: isPrivate ? "true" : "false",
      checked: isPrivate
    })));
  }
  const classNames$7 = {
    popupContainer: cls("popup-container"),
    formContainer: cls("form-container"),
    popupArrowBorder: cls("popup-arrow-border"),
    popupArrowFill: cls("popup-arrow-fill")
  };
  function calculatePopupPosition(popupArrowPointPosition, layoutRect, popupRect) {
    let top = popupArrowPointPosition.top - popupRect.height - HALF_OF_POPUP_ARROW_HEIGHT;
    let left = popupArrowPointPosition.left - popupRect.width / 2;
    let direction = FormPopupArrowDirection.bottom;
    if (top < layoutRect.top) {
      direction = FormPopupArrowDirection.top;
      top = popupArrowPointPosition.top + HALF_OF_POPUP_ARROW_HEIGHT;
    }
    if (isTopOutOfLayout(top, layoutRect, popupRect)) {
      top = layoutRect.top + layoutRect.height - popupRect.height;
    }
    if (isLeftOutOfLayout(left, layoutRect, popupRect)) {
      left = layoutRect.left + layoutRect.width - popupRect.width;
    }
    return {
      top: top + window.scrollY,
      left: Math.max(left, layoutRect.left) + window.scrollX,
      direction
    };
  }
  function isBooleanKey(key) {
    return BOOLEAN_KEYS_OF_EVENT_MODEL_DATA.indexOf(key) !== -1;
  }
  function getChanges(event, eventObject) {
    return Object.entries(eventObject).reduce((changes, [key, value]) => {
      const eventObjectKey = key;
      if (event[eventObjectKey] instanceof TZDate) {
        if (compare(event[eventObjectKey], value) !== 0) {
          changes[eventObjectKey] = value;
        }
      } else if (event[eventObjectKey] !== value) {
        changes[eventObjectKey] = value;
      }
      return changes;
    }, {});
  }
  function EventFormPopup() {
    var _a;
    const { calendars } = useStore(calendarSelector);
    const { hideAllPopup } = useDispatch("popup");
    const popupParams = useStore(eventFormPopupParamSelector);
    const { start, end, popupArrowPointPosition, close, isCreationPopup, event } = popupParams != null ? popupParams : {};
    const eventBus = useEventBus();
    const formPopupSlot = useFloatingLayer("formPopupSlot");
    const [formState, formStateDispatch] = useFormState((_a = calendars[0]) == null ? void 0 : _a.id);
    const datePickerRef = F$2(null);
    const popupContainerRef = F$2(null);
    const [style, setStyle] = p$2({});
    const [arrowLeft, setArrowLeft] = p$2(0);
    const [arrowDirection, setArrowDirection] = p$2(
      FormPopupArrowDirection.bottom
    );
    const layoutContainer = useLayoutContainer();
    const popupArrowClassName = q$1(() => {
      const top = arrowDirection === FormPopupArrowDirection.top;
      const bottom = arrowDirection === FormPopupArrowDirection.bottom;
      return cls("popup-arrow", { top, bottom });
    }, [arrowDirection]);
    A$2(() => {
      if (popupContainerRef.current && popupArrowPointPosition && layoutContainer) {
        const layoutRect = layoutContainer.getBoundingClientRect();
        const popupRect = popupContainerRef.current.getBoundingClientRect();
        const { top, left, direction } = calculatePopupPosition(
          popupArrowPointPosition,
          layoutRect,
          popupRect
        );
        const arrowLeftPosition = popupArrowPointPosition.left - left;
        setStyle({ left, top });
        setArrowLeft(arrowLeftPosition);
        setArrowDirection(direction);
      }
    }, [layoutContainer, popupArrowPointPosition]);
    _$2(() => {
      if (isPresent(popupParams) && isPresent(event)) {
        formStateDispatch({
          type: FormStateActionType.init,
          event: {
            title: popupParams.title,
            location: popupParams.location,
            isAllday: popupParams.isAllday,
            isPrivate: popupParams.isPrivate,
            calendarId: event.calendarId,
            state: popupParams.eventState
          }
        });
      }
    }, [calendars, event, formStateDispatch, popupParams]);
    _$2(() => {
      if (isNil(popupParams)) {
        formStateDispatch({ type: FormStateActionType.reset });
      }
    }, [formStateDispatch, popupParams]);
    if (isNil(start) || isNil(end) || isNil(formPopupSlot)) {
      return null;
    }
    const onSubmit = (e2) => {
      var _a2, _b;
      e2.preventDefault();
      const formData = new FormData(e2.target);
      const eventData = __spreadValues({}, formState);
      formData.forEach((data, key) => {
        eventData[key] = isBooleanKey(key) ? data === "true" : data;
      });
      eventData.start = new TZDate((_a2 = datePickerRef.current) == null ? void 0 : _a2.getStartDate());
      eventData.end = new TZDate((_b = datePickerRef.current) == null ? void 0 : _b.getEndDate());
      if (isCreationPopup) {
        eventBus.fire("beforeCreateEvent", eventData);
      } else if (event) {
        const changes = getChanges(event, eventData);
        eventBus.fire("beforeUpdateEvent", { event: event.toEventObject(), changes });
      }
      hideAllPopup();
    };
    return j$1(
      /* @__PURE__ */ y$3("div", {
        role: "dialog",
        className: classNames$7.popupContainer,
        ref: popupContainerRef,
        style
      }, /* @__PURE__ */ y$3("form", {
        onSubmit
      }, /* @__PURE__ */ y$3("div", {
        className: classNames$7.formContainer
      }, (calendars == null ? void 0 : calendars.length) ? /* @__PURE__ */ y$3(CalendarSelector, {
        selectedCalendarId: formState.calendarId,
        calendars,
        formStateDispatch
      }) : /* @__PURE__ */ y$3(PopupSection, null), /* @__PURE__ */ y$3(TitleInputBox, {
        title: formState.title,
        isPrivate: formState.isPrivate,
        formStateDispatch
      }), /* @__PURE__ */ y$3(LocationInputBox, {
        location: formState.location,
        formStateDispatch
      }), /* @__PURE__ */ y$3(DateSelector, {
        start,
        end,
        isAllday: formState.isAllday,
        formStateDispatch,
        ref: datePickerRef
      }), /* @__PURE__ */ y$3(EventStateSelector, {
        eventState: formState.state,
        formStateDispatch
      }), /* @__PURE__ */ y$3(ClosePopupButton, {
        type: "form",
        close
      }), /* @__PURE__ */ y$3(PopupSection, null, /* @__PURE__ */ y$3(ConfirmPopupButton, null, isCreationPopup ? /* @__PURE__ */ y$3(Template, {
        template: "popupSave"
      }) : /* @__PURE__ */ y$3(Template, {
        template: "popupUpdate"
      })))), /* @__PURE__ */ y$3("div", {
        className: popupArrowClassName
      }, /* @__PURE__ */ y$3("div", {
        className: classNames$7.popupArrowBorder,
        style: { left: arrowLeft }
      }, /* @__PURE__ */ y$3("div", {
        className: classNames$7.popupArrowFill
      }))))),
      formPopupSlot
    );
  }
  function shownPopupParamSelector(state) {
    return Object.values(state.popup).find((popup) => isPresent(popup));
  }
  function PopupOverlay() {
    const shownPopupParam = useStore(shownPopupParamSelector);
    const { hideAllPopup } = useDispatch("popup");
    const isPopupShown = isPresent(shownPopupParam);
    const onClick = (ev) => {
      var _a;
      ev.stopPropagation();
      (_a = shownPopupParam == null ? void 0 : shownPopupParam.close) == null ? void 0 : _a.call(shownPopupParam);
      hideAllPopup();
    };
    return /* @__PURE__ */ y$3("div", {
      className: cls("popup-overlay"),
      style: { display: isPopupShown ? "block" : "none" },
      onClick
    });
  }
  const classNames$6 = {
    container: cls("see-more-container"),
    seeMore: cls("see-more"),
    header: cls("see-more-header"),
    list: cls("month-more-list")
  };
  function SeeMoreEventsPopup() {
    const popupParams = useStore(seeMorePopupParamSelector);
    const { date: date2, events = [], popupPosition } = popupParams != null ? popupParams : {};
    const { moreView, moreViewTitle } = useMonthTheme();
    const seeMorePopupSlot = useFloatingLayer("seeMorePopupSlot");
    const eventBus = useEventBus();
    const moreEventsPopupContainerRef = F$2(null);
    const isHidden = isNil(date2) || isNil(popupPosition) || isNil(seeMorePopupSlot);
    _$2(() => {
      if (!isHidden && moreEventsPopupContainerRef.current) {
        eventBus.fire("clickMoreEventsBtn", {
          date: date2.toDate(),
          target: moreEventsPopupContainerRef.current
        });
      }
    }, [date2, eventBus, isHidden]);
    if (isHidden) {
      return null;
    }
    const style = {
      height: MONTH_MORE_VIEW_HEADER_HEIGHT,
      marginBottom: MONTH_MORE_VIEW_HEADER_MARGIN_BOTTOM,
      padding: MONTH_MORE_VIEW_HEADER_PADDING,
      backgroundColor: moreViewTitle.backgroundColor
    };
    const moreTitle = {
      ymd: toFormat(date2, "YYYY-MM-DD"),
      day: date2.getDay(),
      date: date2.getDate().toString().padStart(2, "0")
    };
    const moreViewListStyle = {
      height: `calc(100% - ${MONTH_MORE_VIEW_HEADER_HEIGHT + MONTH_MORE_VIEW_HEADER_MARGIN_BOTTOM + MONTH_MORE_VIEW_HEADER_PADDING_TOP}px)`
    };
    return j$1(
      /* @__PURE__ */ y$3("div", {
        role: "dialog",
        className: classNames$6.container,
        style: popupPosition,
        ref: moreEventsPopupContainerRef
      }, /* @__PURE__ */ y$3("div", {
        className: classNames$6.seeMore,
        style: moreView
      }, /* @__PURE__ */ y$3("div", {
        className: classNames$6.header,
        style
      }, /* @__PURE__ */ y$3(Template, {
        template: "monthMoreTitleDate",
        param: moreTitle
      }), /* @__PURE__ */ y$3(ClosePopupButton, {
        type: "moreEvents"
      })), /* @__PURE__ */ y$3("div", {
        className: classNames$6.list,
        style: moreViewListStyle
      }, events.map((uiModel) => /* @__PURE__ */ y$3(HorizontalEvent, {
        key: `see-more-event-item-${uiModel.cid()}`,
        uiModel,
        eventHeight: MONTH_EVENT_HEIGHT,
        headerHeight: MONTH_MORE_VIEW_HEADER_HEIGHT,
        flat: true
      }))))),
      seeMorePopupSlot
    );
  }
  function getLayoutStylesFromInfo(width, height) {
    const styles = { height: toPercent(100) };
    if (width) {
      styles.width = width;
    }
    if (height) {
      styles.height = height;
    }
    return styles;
  }
  function Layout({
    children,
    width,
    height,
    className: className2 = "",
    autoAdjustPanels = false
  }) {
    const { backgroundColor } = useTheme(commonThemeSelector);
    const [container, containerRefCallback] = useDOMNode();
    const { setLastPanelType, updateLayoutHeight } = useDispatch("weekViewLayout");
    const layoutClassName = q$1(() => `${cls("layout")} ${className2}`, [className2]);
    A$2(() => {
      if (container) {
        const onResizeWindow = () => updateLayoutHeight(container.offsetHeight);
        onResizeWindow();
        window.addEventListener("resize", onResizeWindow);
        return () => window.removeEventListener("resize", onResizeWindow);
      }
      return noop;
    }, [container, updateLayoutHeight]);
    A$2(() => {
      if (container && autoAdjustPanels) {
        const childArray = $$1(children);
        const lastChild = childArray[childArray.length - 1];
        if (!isString_1(lastChild) && !isNumber_1(lastChild) && !isNil(lastChild)) {
          setLastPanelType(lastChild.props.name);
        }
      }
    }, [children, setLastPanelType, autoAdjustPanels, container]);
    return /* @__PURE__ */ y$3(LayoutContainerProvider, {
      value: container
    }, /* @__PURE__ */ y$3("div", {
      ref: containerRefCallback,
      className: layoutClassName,
      style: __spreadProps(__spreadValues({}, getLayoutStylesFromInfo(width, height)), { backgroundColor })
    }, container ? children : null), /* @__PURE__ */ y$3(EventFormPopup, null), /* @__PURE__ */ y$3(EventDetailPopup, null), /* @__PURE__ */ y$3(SeeMoreEventsPopup, null), /* @__PURE__ */ y$3(PopupOverlay, null));
  }
  function getDefaultStyle(height, border) {
    return {
      height,
      width: "100%",
      cursor: "row-resize",
      borderTop: border,
      borderBottom: border
    };
  }
  function PanelResizer({ name, height }) {
    const border = useTheme(x$3((theme) => theme.week.panelResizer.border, []));
    const style = getDefaultStyle(height, border);
    const defaultGuideStyle = __spreadProps(__spreadValues({}, style), {
      display: "none",
      border: "none",
      backgroundColor: "#999"
    });
    const [guideStyle, setGuideStyle] = p$2(defaultGuideStyle);
    const startPos = F$2(null);
    const { updateDayGridRowHeightByDiff } = useDispatch("weekViewLayout");
    const onMouseDown = useDrag(DRAGGING_TYPE_CONSTANTS.panelResizer, {
      onDragStart: (e2) => {
        startPos.current = { left: e2.pageX, top: e2.pageY };
      },
      onDrag: (e2) => {
        if (startPos.current) {
          const top = e2.pageY - startPos.current.top;
          setGuideStyle((prev) => __spreadProps(__spreadValues({}, prev), { top, display: null }));
        }
      },
      onMouseUp: (e2) => {
        if (startPos.current) {
          const diff = e2.pageY - startPos.current.top;
          startPos.current = null;
          setGuideStyle(defaultGuideStyle);
          updateDayGridRowHeightByDiff({ rowName: name, diff });
        }
      }
    });
    return /* @__PURE__ */ y$3("div", {
      style: { position: "relative" }
    }, /* @__PURE__ */ y$3("div", {
      className: cls("panel-resizer"),
      style,
      onMouseDown
    }), /* @__PURE__ */ y$3("div", {
      className: cls("panel-resizer-guide"),
      style: guideStyle
    }));
  }
  function getPanelSide(side, maxExpandableSide) {
    return maxExpandableSide ? Math.min(maxExpandableSide, side) : side;
  }
  function getPanelStyle({
    initialHeight,
    initialWidth,
    overflowX,
    overflowY,
    maxExpandableWidth,
    maxExpandableHeight,
    minHeight,
    maxHeight,
    minWidth,
    maxWidth
  }) {
    const style = {};
    if (initialWidth) {
      style.width = getPanelSide(initialWidth, maxExpandableWidth);
      style.height = "100%";
    }
    if (initialHeight) {
      style.width = "100%";
      style.height = getPanelSide(initialHeight, maxExpandableHeight);
    }
    if (overflowX) {
      style.overflowX = "auto";
    }
    if (overflowY) {
      style.overflowY = "auto";
    }
    return __spreadProps(__spreadValues({}, style), { minHeight, maxHeight, minWidth, maxWidth });
  }
  const Panel = N(function Panel2({
    name,
    initialWidth = DEFAULT_PANEL_HEIGHT,
    initialHeight = DEFAULT_PANEL_HEIGHT,
    overflowX,
    overflowY,
    maxExpandableWidth,
    maxExpandableHeight,
    minHeight,
    maxHeight,
    minWidth,
    maxWidth,
    resizerWidth = DEFAULT_RESIZER_LENGTH,
    resizerHeight = DEFAULT_RESIZER_LENGTH,
    resizable,
    children
  }, ref) {
    const { updateDayGridRowHeight } = useDispatch("weekViewLayout");
    const { height: dayGridRowHeight } = useStore(
      x$3((state) => {
        var _a;
        return (_a = state.weekViewLayout.dayGridRows[name]) != null ? _a : {};
      }, [name])
    );
    const height = dayGridRowHeight != null ? dayGridRowHeight : initialHeight;
    A$2(() => {
      updateDayGridRowHeight({ rowName: name, height: initialHeight });
    }, [initialHeight, name, updateDayGridRowHeight]);
    const styles = getPanelStyle({
      initialWidth,
      initialHeight: height,
      overflowX,
      overflowY,
      maxExpandableWidth,
      maxExpandableHeight,
      minHeight,
      maxHeight,
      minWidth,
      maxWidth
    });
    const isResizable = q$1(() => {
      if (isNil(resizable) || isBoolean_1(resizable)) {
        return !!resizable;
      }
      return resizable.includes(name);
    }, [resizable, name]);
    return /* @__PURE__ */ y$3(g$2, null, /* @__PURE__ */ y$3("div", {
      className: cls("panel", name),
      style: styles,
      ref
    }, children), isResizable ? /* @__PURE__ */ y$3(PanelResizer, {
      name,
      width: resizerWidth,
      height: resizerHeight
    }) : null);
  });
  const className = "timegrid";
  const addTimeGridPrefix = (selector) => `${className}-${selector}`;
  const timeFormats = {
    second: "HH:mm:ss",
    minute: "HH:mm",
    hour: "HH:mm",
    date: "HH:mm",
    month: "MM.DD",
    year: "YYYY.MM.DD"
  };
  const classNames$5 = {
    time: cls("event-time"),
    content: cls("event-time-content"),
    travelTime: cls("travel-time"),
    resizeHandleX: cls("resize-handler-x"),
    moveEvent: cls("dragging--move-event"),
    resizeEvent: cls("dragging--resize-vertical-event")
  };
  function getMarginLeft(left) {
    const { percent, px } = extractPercentPx(`${left}`);
    return left > 0 || percent > 0 || px > 0 ? TIME_EVENT_CONTAINER_MARGIN_LEFT : 0;
  }
  function getContainerWidth(width, marginLeft) {
    if (isString_1(width)) {
      return width;
    }
    if (width >= 0) {
      return `calc(${toPercent(width)} - ${marginLeft}px)`;
    }
    return "";
  }
  function getStyles({
    uiModel,
    isDraggingTarget,
    hasNextStartTime,
    calendarColor,
    minHeight
  }) {
    const {
      top,
      left,
      height,
      width,
      duplicateLeft,
      duplicateWidth,
      goingDurationHeight,
      modelDurationHeight,
      comingDurationHeight,
      croppedStart,
      croppedEnd
    } = uiModel;
    const travelBorderColor = "white";
    const borderRadius = 2;
    const defaultMarginBottom = 2;
    const marginLeft = getMarginLeft(left);
    const { color, backgroundColor, borderColor, dragBackgroundColor } = getEventColors(
      uiModel,
      calendarColor
    );
    const containerStyle = {
      width: getContainerWidth(duplicateWidth || width, marginLeft),
      height: `calc(${toPercent(Math.max(height, minHeight))} - ${defaultMarginBottom}px)`,
      top: toPercent(top),
      left: duplicateLeft || toPercent(left),
      borderRadius,
      borderLeft: `3px solid ${borderColor}`,
      marginLeft,
      color,
      backgroundColor: isDraggingTarget ? dragBackgroundColor : backgroundColor,
      opacity: isDraggingTarget ? 0.5 : 1,
      zIndex: hasNextStartTime ? 1 : 0
    };
    const goingDurationStyle = {
      height: toPercent(goingDurationHeight),
      borderBottom: `1px dashed ${travelBorderColor}`
    };
    const modelDurationStyle = {
      height: toPercent(modelDurationHeight)
    };
    const comingDurationStyle = {
      height: toPercent(comingDurationHeight),
      borderTop: `1px dashed ${travelBorderColor}`
    };
    if (croppedStart) {
      containerStyle.borderTopLeftRadius = 0;
      containerStyle.borderTopRightRadius = 0;
    }
    if (croppedEnd) {
      containerStyle.borderBottomLeftRadius = 0;
      containerStyle.borderBottomRightRadius = 0;
    }
    return {
      containerStyle,
      goingDurationStyle,
      modelDurationStyle,
      comingDurationStyle
    };
  }
  function isDraggableEvent({
    uiModel,
    isReadOnlyCalendar,
    isDraggingTarget,
    hasNextStartTime
  }) {
    const { model } = uiModel;
    return !isReadOnlyCalendar && !model.isReadOnly && !isDraggingTarget && !hasNextStartTime;
  }
  function TimeEvent({
    uiModel,
    nextStartTime,
    isResizingGuide = false,
    minHeight = 0
  }) {
    const {
      useDetailPopup,
      isReadOnly: isReadOnlyCalendar,
      week: weekOptions
    } = useStore(optionsSelector);
    const calendarColor = useCalendarColor(uiModel.model);
    const { collapseDuplicateEvents } = weekOptions;
    const layoutContainer = useLayoutContainer();
    const { showDetailPopup } = useDispatch("popup");
    const { setDraggingEventUIModel } = useDispatch("dnd");
    const { setSelectedDuplicateEventCid } = useDispatch("weekViewLayout");
    const eventBus = useEventBus();
    const eventContainerRef = F$2(null);
    const [isDraggingTarget, setIsDraggingTarget] = p$2(false);
    const { model, goingDurationHeight, modelDurationHeight, comingDurationHeight, croppedEnd } = uiModel;
    const { id, calendarId, customStyle } = model;
    const hasNextStartTime = isPresent(nextStartTime);
    const { containerStyle, goingDurationStyle, modelDurationStyle, comingDurationStyle } = getStyles(
      { uiModel, isDraggingTarget, hasNextStartTime, calendarColor, minHeight }
    );
    const isGuide = hasNextStartTime || isResizingGuide;
    useTransientUpdate(dndSelector, ({ draggingEventUIModel, draggingState }) => {
      if (draggingState === DraggingState.DRAGGING && (draggingEventUIModel == null ? void 0 : draggingEventUIModel.cid()) === uiModel.cid() && !hasNextStartTime && !isResizingGuide) {
        setIsDraggingTarget(true);
      } else {
        setIsDraggingTarget(false);
      }
    });
    _$2(() => {
      if (!isResizingGuide) {
        eventBus.fire("afterRenderEvent", uiModel.model.toEventObject());
      }
    }, []);
    const startDragEvent = (className2) => {
      setDraggingEventUIModel(uiModel);
      layoutContainer == null ? void 0 : layoutContainer.classList.add(className2);
    };
    const endDragEvent = (className2) => {
      setIsDraggingTarget(false);
      layoutContainer == null ? void 0 : layoutContainer.classList.remove(className2);
    };
    const onMoveStart = useDrag(DRAGGING_TYPE_CREATORS.moveEvent("timeGrid", `${uiModel.cid()}`), {
      onDragStart: () => {
        if (isDraggable) {
          startDragEvent(classNames$5.moveEvent);
        }
      },
      onMouseUp: (e2, { draggingState }) => {
        endDragEvent(classNames$5.moveEvent);
        const isClick = draggingState <= DraggingState.INIT;
        if (isClick && collapseDuplicateEvents) {
          const selectedDuplicateEventCid = uiModel.duplicateEvents.length > 0 ? uiModel.cid() : DEFAULT_DUPLICATE_EVENT_CID;
          setSelectedDuplicateEventCid(selectedDuplicateEventCid);
        }
        if (isClick && useDetailPopup && eventContainerRef.current) {
          showDetailPopup(
            {
              event: uiModel.model,
              eventRect: eventContainerRef.current.getBoundingClientRect()
            },
            false
          );
        }
        if (isClick) {
          eventBus.fire("clickEvent", { event: uiModel.model.toEventObject(), nativeEvent: e2 });
        }
      },
      onPressESCKey: () => endDragEvent(classNames$5.moveEvent)
    });
    const handleMoveStart = (e2) => {
      e2.stopPropagation();
      onMoveStart(e2);
    };
    const onResizeStart = useDrag(
      DRAGGING_TYPE_CREATORS.resizeEvent("timeGrid", `${uiModel.cid()}`),
      {
        onDragStart: () => startDragEvent(classNames$5.resizeEvent),
        onMouseUp: () => endDragEvent(classNames$5.resizeEvent),
        onPressESCKey: () => endDragEvent(classNames$5.resizeEvent)
      }
    );
    const handleResizeStart = (e2) => {
      e2.stopPropagation();
      onResizeStart(e2);
    };
    const isDraggable = isDraggableEvent({
      uiModel,
      isReadOnlyCalendar,
      isDraggingTarget,
      hasNextStartTime
    });
    const shouldShowResizeHandle = isDraggable && !croppedEnd;
    return /* @__PURE__ */ y$3("div", {
      "data-testid": `${isGuide ? "guide-" : ""}time-event-${model.title}-${uiModel.cid()}`,
      "data-calendar-id": calendarId,
      "data-event-id": id,
      className: classNames$5.time,
      style: __spreadValues(__spreadValues({}, containerStyle), customStyle),
      onMouseDown: handleMoveStart,
      ref: eventContainerRef
    }, goingDurationHeight ? /* @__PURE__ */ y$3("div", {
      className: classNames$5.travelTime,
      style: goingDurationStyle
    }, /* @__PURE__ */ y$3(Template, {
      template: "goingDuration",
      param: model
    })) : null, modelDurationHeight ? /* @__PURE__ */ y$3("div", {
      className: classNames$5.content,
      style: modelDurationStyle
    }, /* @__PURE__ */ y$3(Template, {
      template: "time",
      param: __spreadProps(__spreadValues({}, model.toEventObject()), {
        start: hasNextStartTime ? nextStartTime : model.start
      })
    })) : null, comingDurationHeight ? /* @__PURE__ */ y$3("div", {
      className: classNames$5.travelTime,
      style: comingDurationStyle
    }, /* @__PURE__ */ y$3(Template, {
      template: "comingDuration",
      param: model
    })) : null, shouldShowResizeHandle ? /* @__PURE__ */ y$3("div", {
      className: classNames$5.resizeHandleX,
      onMouseDown: handleResizeStart
    }) : null);
  }
  function GridSelection({ top, height, text }) {
    const { backgroundColor, border } = useTheme(
      x$3((theme) => theme.common.gridSelection, [])
    );
    const color = useTheme(x$3((theme) => theme.week.gridSelection.color, []));
    const style = {
      top: toPercent(top),
      height: toPercent(height),
      backgroundColor,
      border
    };
    return /* @__PURE__ */ y$3("div", {
      className: cls("time", "grid-selection"),
      style,
      "data-testid": `time-grid-selection-${top}-${height}`
    }, text.length > 0 ? /* @__PURE__ */ y$3("span", {
      className: cls("grid-selection-label"),
      style: { color }
    }, text) : null);
  }
  function GridSelectionByColumn({ columnIndex, timeGridRows }) {
    const gridSelectionData = useStore(
      x$3(
        (state) => timeGridSelectionHelper.calculateSelection(
          state.gridSelection.timeGrid,
          columnIndex,
          timeGridRows.length - 1
        ),
        [columnIndex, timeGridRows]
      )
    );
    const gridSelectionProps = q$1(() => {
      if (!gridSelectionData) {
        return null;
      }
      const { startRowIndex, endRowIndex, isStartingColumn, isSelectingMultipleColumns } = gridSelectionData;
      const { top: startRowTop, startTime: startRowStartTime } = timeGridRows[startRowIndex];
      const {
        top: endRowTop,
        height: endRowHeight,
        endTime: endRowEndTime
      } = timeGridRows[endRowIndex];
      const gridSelectionHeight = endRowTop + endRowHeight - startRowTop;
      let text = `${startRowStartTime} - ${endRowEndTime}`;
      if (isSelectingMultipleColumns) {
        text = isStartingColumn ? startRowStartTime : "";
      }
      return {
        top: startRowTop,
        height: gridSelectionHeight,
        text
      };
    }, [gridSelectionData, timeGridRows]);
    if (isNil(gridSelectionProps)) {
      return null;
    }
    return /* @__PURE__ */ y$3(GridSelection, __spreadValues({}, gridSelectionProps));
  }
  function useTimeGridEventResize({
    gridPositionFinder,
    totalUIModels,
    columnIndex,
    timeGridData
  }) {
    const eventBus = useEventBus();
    const {
      isDraggingEnd,
      isDraggingCanceled,
      draggingEvent: resizingStartUIModel,
      clearDraggingEvent
    } = useDraggingEvent("timeGrid", "resize");
    const [currentGridPos, clearCurrentGridPos] = useCurrentPointerPositionInGrid(gridPositionFinder);
    const [guideUIModel, setGuideUIModel] = p$2(null);
    const clearStates = x$3(() => {
      setGuideUIModel(null);
      clearDraggingEvent();
      clearCurrentGridPos();
    }, [clearCurrentGridPos, clearDraggingEvent]);
    const baseResizingInfo = q$1(() => {
      if (isNil(resizingStartUIModel)) {
        return null;
      }
      const { columns, rows } = timeGridData;
      const resizeTargetUIModelColumns = totalUIModels.map(
        (uiModels) => uiModels.filter(
          (uiModel) => uiModel.cid() === resizingStartUIModel.cid()
        )
      );
      const findRowIndexOf = (targetDate, targetColumnIndex) => (row) => {
        const rowStartTZDate = setTimeStrToDate(columns[targetColumnIndex].date, row.startTime);
        const rowEndTZDate = setTimeStrToDate(
          timeGridData.columns[targetColumnIndex].date,
          row.endTime
        );
        return rowStartTZDate <= targetDate && targetDate < rowEndTZDate;
      };
      const eventStartDateColumnIndex = resizeTargetUIModelColumns.findIndex((row) => row.length > 0);
      const resizingStartEventUIModel = resizeTargetUIModelColumns[eventStartDateColumnIndex][0];
      const { goingDuration = 0 } = resizingStartEventUIModel.model;
      const renderStart = addMinutes(resizingStartEventUIModel.getStarts(), -goingDuration);
      const eventStartDateRowIndex = Math.max(
        rows.findIndex(findRowIndexOf(renderStart, eventStartDateColumnIndex)),
        0
      );
      const eventEndDateColumnIndex = findLastIndex(
        resizeTargetUIModelColumns,
        (row) => row.length > 0
      );
      const resizingEndEventUIModel = resizeTargetUIModelColumns[eventEndDateColumnIndex][0];
      const { comingDuration = 0 } = resizingEndEventUIModel.model;
      const renderEnd = addMinutes(resizingEndEventUIModel.getStarts(), comingDuration);
      let eventEndDateRowIndex = rows.findIndex(findRowIndexOf(renderEnd, eventEndDateColumnIndex));
      eventEndDateRowIndex = eventEndDateRowIndex >= 0 ? eventEndDateRowIndex : rows.length - 1;
      return {
        eventStartDateColumnIndex,
        eventStartDateRowIndex,
        eventEndDateColumnIndex,
        eventEndDateRowIndex,
        resizeTargetUIModelColumns
      };
    }, [resizingStartUIModel, timeGridData, totalUIModels]);
    const canCalculateGuideUIModel = isPresent(baseResizingInfo) && isPresent(resizingStartUIModel) && isPresent(currentGridPos);
    const oneRowHeight = q$1(
      () => baseResizingInfo ? timeGridData.rows[0].height : 0,
      [baseResizingInfo, timeGridData.rows]
    );
    _$2(() => {
      if (canCalculateGuideUIModel) {
        const { eventStartDateRowIndex, eventStartDateColumnIndex, eventEndDateColumnIndex } = baseResizingInfo;
        if (columnIndex === eventEndDateColumnIndex && eventStartDateColumnIndex === eventEndDateColumnIndex) {
          const clonedUIModel = resizingStartUIModel.clone();
          const { height, goingDurationHeight, comingDurationHeight } = clonedUIModel;
          const newHeight = Math.max(
            oneRowHeight + goingDurationHeight * height / 100 + comingDurationHeight * height / 100,
            timeGridData.rows[currentGridPos.rowIndex].top - timeGridData.rows[eventStartDateRowIndex].top + oneRowHeight
          );
          const newGoingDurationHeight = goingDurationHeight * height / newHeight;
          const newComingDurationHeight = comingDurationHeight * height / newHeight;
          clonedUIModel.setUIProps({
            height: newHeight,
            goingDurationHeight: newGoingDurationHeight,
            comingDurationHeight: newComingDurationHeight,
            modelDurationHeight: 100 - (newGoingDurationHeight + newComingDurationHeight)
          });
          setGuideUIModel(clonedUIModel);
        }
      }
    }, [
      baseResizingInfo,
      canCalculateGuideUIModel,
      columnIndex,
      currentGridPos,
      resizingStartUIModel,
      timeGridData.rows,
      oneRowHeight
    ]);
    _$2(() => {
      if (canCalculateGuideUIModel) {
        const { resizeTargetUIModelColumns, eventStartDateColumnIndex, eventEndDateColumnIndex } = baseResizingInfo;
        if ((columnIndex === eventStartDateColumnIndex || columnIndex === eventEndDateColumnIndex) && eventStartDateColumnIndex !== eventEndDateColumnIndex) {
          let clonedUIModel;
          if (columnIndex === eventStartDateColumnIndex) {
            clonedUIModel = resizeTargetUIModelColumns[columnIndex][0].clone();
          } else {
            clonedUIModel = resizingStartUIModel.clone();
            clonedUIModel.setUIProps({
              height: timeGridData.rows[currentGridPos.rowIndex].top + oneRowHeight
            });
          }
          setGuideUIModel(clonedUIModel);
        }
      }
    }, [
      baseResizingInfo,
      canCalculateGuideUIModel,
      columnIndex,
      currentGridPos,
      resizingStartUIModel,
      timeGridData.rows,
      oneRowHeight
    ]);
    useWhen(() => {
      const shouldUpdate = !isDraggingCanceled && isPresent(baseResizingInfo) && isPresent(currentGridPos) && isPresent(resizingStartUIModel) && baseResizingInfo.eventEndDateColumnIndex === columnIndex;
      if (shouldUpdate) {
        const { comingDuration = 0 } = resizingStartUIModel.model;
        const targetEndDate = addMinutes(
          setTimeStrToDate(
            timeGridData.columns[columnIndex].date,
            timeGridData.rows[currentGridPos.rowIndex].endTime
          ),
          -comingDuration
        );
        const { STEP_MINUTES } = getTimeSteps(timeGridData.rows);
        const minEndDate = addMinutes(resizingStartUIModel.getStarts(), STEP_MINUTES);
        eventBus.fire("beforeUpdateEvent", {
          event: resizingStartUIModel.model.toEventObject(),
          changes: {
            end: max(minEndDate, targetEndDate)
          }
        });
      }
      clearStates();
    }, isDraggingEnd);
    return guideUIModel;
  }
  function ResizingGuideByColumn({
    gridPositionFinder,
    totalUIModels,
    columnIndex,
    timeGridData
  }) {
    const guideUIModel = useTimeGridEventResize({
      gridPositionFinder,
      totalUIModels,
      columnIndex,
      timeGridData
    });
    if (isNil(guideUIModel)) {
      return null;
    }
    return /* @__PURE__ */ y$3(TimeEvent, {
      uiModel: guideUIModel,
      isResizingGuide: true
    });
  }
  const classNames$4 = {
    column: cls("column"),
    backgrounds: cls("background-events"),
    events: cls("events")
  };
  function VerticalEvents({
    eventUIModels,
    minEventHeight
  }) {
    const style = { marginRight: 8 };
    return /* @__PURE__ */ y$3("div", {
      className: classNames$4.events,
      style
    }, eventUIModels.map((eventUIModel) => /* @__PURE__ */ y$3(TimeEvent, {
      key: `${eventUIModel.valueOf()}-${eventUIModel.cid()}`,
      uiModel: eventUIModel,
      minHeight: minEventHeight
    })));
  }
  function backgroundColorSelector$1(theme) {
    return {
      defaultBackgroundColor: theme.week.dayGrid.backgroundColor,
      todayBackgroundColor: theme.week.today.backgroundColor,
      weekendBackgroundColor: theme.week.weekend.backgroundColor
    };
  }
  function getBackgroundColor({
    today,
    columnDate,
    defaultBackgroundColor,
    todayBackgroundColor,
    weekendBackgroundColor
  }) {
    const isTodayColumn = isSameDate(today, columnDate);
    const isWeekendColumn = isWeekend(columnDate.getDay());
    if (isTodayColumn) {
      return todayBackgroundColor;
    }
    if (isWeekendColumn) {
      return weekendBackgroundColor;
    }
    return defaultBackgroundColor;
  }
  const Column = w$1(function Column2({
    columnDate,
    columnWidth,
    columnIndex,
    totalUIModels,
    gridPositionFinder,
    timeGridData,
    isLastColumn
  }) {
    const { rows: timeGridRows } = timeGridData;
    const borderRight = useTheme(x$3((theme) => theme.week.timeGrid.borderRight, []));
    const backgroundColorTheme = useTheme(backgroundColorSelector$1);
    const [, getNow] = usePrimaryTimezone();
    const today = getNow();
    const backgroundColor = getBackgroundColor(__spreadValues({ today, columnDate }, backgroundColorTheme));
    const style = {
      width: columnWidth,
      backgroundColor,
      borderRight: isLastColumn ? "none" : borderRight
    };
    const uiModelsByColumn = totalUIModels[columnIndex];
    const minEventHeight = timeGridRows[0].height;
    return /* @__PURE__ */ y$3("div", {
      className: classNames$4.column,
      style,
      "data-testid": `timegrid-column-${columnDate.getDay()}`
    }, /* @__PURE__ */ y$3(VerticalEvents, {
      eventUIModels: uiModelsByColumn,
      minEventHeight
    }), /* @__PURE__ */ y$3(ResizingGuideByColumn, {
      gridPositionFinder,
      totalUIModels,
      columnIndex,
      timeGridData
    }), /* @__PURE__ */ y$3(GridSelectionByColumn, {
      columnIndex,
      timeGridRows
    }));
  });
  function gridLineBorderSelector(theme) {
    return {
      halfHourLineBorder: theme.week.timeGridHalfHourLine.borderBottom,
      hourLineBorder: theme.week.timeGridHourLine.borderBottom
    };
  }
  const GridLines = w$1(function GridLines2({
    timeGridRows
  }) {
    const { STEPS } = getTimeSteps(timeGridRows);
    const { halfHourLineBorder, hourLineBorder } = useTheme(gridLineBorderSelector);
    let count = 1;
    return /* @__PURE__ */ y$3("div", {
      className: cls("gridlines")
    }, timeGridRows.map((time) => {
      count = count === STEPS + 1 ? 1 : count;
      const isUpperLine = count !== STEPS;
      count += 1;
      return /* @__PURE__ */ y$3("div", {
        key: `gridline-${time.startTime}-${time.endTime}`,
        className: cls("gridline-half"),
        style: {
          top: toPercent(time.top),
          height: toPercent(time.height),
          borderBottom: isUpperLine ? halfHourLineBorder : hourLineBorder
        },
        "data-testid": `gridline-${time.startTime}-${time.endTime}`
      });
    }));
  });
  function getCurrentIndexByTime(time, hourStart, STEP_MINUTES) {
    const hour = time.getHours() - hourStart;
    const minutes = time.getMinutes();
    return hour * (60 / STEP_MINUTES) + Math.floor(minutes / STEP_MINUTES);
  }
  function getMovingEventPosition({
    draggingEvent,
    columnDiff,
    rowDiff,
    timeGridDataRows,
    currentDate
  }) {
    const { STEP_MINUTES, MS_PER_STEP_MINUTES } = getTimeSteps(timeGridDataRows);
    const rowHeight = timeGridDataRows[0].height;
    const maxHeight = rowHeight * timeGridDataRows.length;
    const millisecondsDiff = rowDiff * MS_PER_STEP_MINUTES + columnDiff * MS_PER_DAY;
    const hourStart = Number(timeGridDataRows[0].startTime.split(":")[0]);
    const { goingDuration = 0, comingDuration = 0 } = draggingEvent.model;
    const goingStart = addMinutes(draggingEvent.getStarts(), -goingDuration);
    const comingEnd = addMinutes(draggingEvent.getEnds(), comingDuration);
    const nextStart = addMilliseconds(goingStart, millisecondsDiff);
    const nextEnd = addMilliseconds(comingEnd, millisecondsDiff);
    const startIndex = Math.max(getCurrentIndexByTime(nextStart, hourStart, STEP_MINUTES), 0);
    const endIndex = Math.min(
      getCurrentIndexByTime(nextEnd, hourStart, STEP_MINUTES),
      timeGridDataRows.length - 1
    );
    const isStartAtPrevDate = nextStart.getFullYear() < currentDate.getFullYear() || nextStart.getMonth() < currentDate.getMonth() || nextStart.getDate() < currentDate.getDate();
    const isEndAtNextDate = nextEnd.getFullYear() > currentDate.getFullYear() || nextEnd.getMonth() > currentDate.getMonth() || nextEnd.getDate() > currentDate.getDate();
    const indexDiff = endIndex - (isStartAtPrevDate ? 0 : startIndex);
    const top = isStartAtPrevDate ? 0 : timeGridDataRows[startIndex].top;
    const height = isEndAtNextDate ? maxHeight : Math.max(indexDiff, 1) * rowHeight;
    return { top, height };
  }
  const initXSelector = (state) => state.dnd.initX;
  const initYSelector = (state) => state.dnd.initY;
  function useTimeGridEventMove({
    gridPositionFinder,
    timeGridData
  }) {
    const { MS_PER_STEP_MINUTES } = getTimeSteps(timeGridData.rows);
    const initX = useStore(initXSelector);
    const initY = useStore(initYSelector);
    const eventBus = useEventBus();
    const { isDraggingEnd, isDraggingCanceled, draggingEvent, clearDraggingEvent } = useDraggingEvent(
      "timeGrid",
      "move"
    );
    const [currentGridPos, clearCurrentGridPos] = useCurrentPointerPositionInGrid(gridPositionFinder);
    const initGridPosRef = F$2(null);
    _$2(() => {
      if (isPresent(initX) && isPresent(initY)) {
        initGridPosRef.current = gridPositionFinder({
          clientX: initX,
          clientY: initY
        });
      }
    }, [gridPositionFinder, initX, initY]);
    const gridDiff = q$1(() => {
      if (isNil(initGridPosRef.current) || isNil(currentGridPos)) {
        return null;
      }
      return {
        columnDiff: currentGridPos.columnIndex - initGridPosRef.current.columnIndex,
        rowDiff: currentGridPos.rowIndex - initGridPosRef.current.rowIndex
      };
    }, [currentGridPos]);
    const startDateTime = q$1(() => {
      if (isNil(draggingEvent)) {
        return null;
      }
      return draggingEvent.getStarts();
    }, [draggingEvent]);
    const clearState = x$3(() => {
      clearCurrentGridPos();
      clearDraggingEvent();
      initGridPosRef.current = null;
    }, [clearCurrentGridPos, clearDraggingEvent]);
    const nextStartTime = q$1(() => {
      if (isNil(gridDiff) || isNil(startDateTime)) {
        return null;
      }
      return addMilliseconds(
        startDateTime,
        gridDiff.rowDiff * MS_PER_STEP_MINUTES + gridDiff.columnDiff * MS_PER_DAY
      );
    }, [gridDiff, startDateTime, MS_PER_STEP_MINUTES]);
    const movingEvent = q$1(() => {
      if (isNil(draggingEvent) || isNil(currentGridPos) || isNil(gridDiff)) {
        return null;
      }
      const clonedEvent = draggingEvent.clone();
      const { top, height } = getMovingEventPosition({
        draggingEvent: clonedEvent,
        columnDiff: gridDiff.columnDiff,
        rowDiff: gridDiff.rowDiff,
        timeGridDataRows: timeGridData.rows,
        currentDate: timeGridData.columns[currentGridPos.columnIndex].date
      });
      clonedEvent.setUIProps({
        left: timeGridData.columns[currentGridPos.columnIndex].left,
        width: timeGridData.columns[currentGridPos.columnIndex].width,
        top,
        height
      });
      return clonedEvent;
    }, [currentGridPos, draggingEvent, gridDiff, timeGridData.columns, timeGridData.rows]);
    useWhen(() => {
      const shouldUpdate = !isDraggingCanceled && isPresent(draggingEvent) && isPresent(currentGridPos) && isPresent(gridDiff) && isPresent(nextStartTime) && (gridDiff.rowDiff !== 0 || gridDiff.columnDiff !== 0);
      if (shouldUpdate) {
        const duration = draggingEvent.duration();
        const nextEndTime = addMilliseconds(nextStartTime, duration);
        eventBus.fire("beforeUpdateEvent", {
          event: draggingEvent.model.toEventObject(),
          changes: {
            start: nextStartTime,
            end: nextEndTime
          }
        });
      }
      clearState();
    }, isDraggingEnd);
    return {
      movingEvent,
      nextStartTime
    };
  }
  function MovingEventShadow$1({
    gridPositionFinder,
    timeGridData
  }) {
    const { movingEvent, nextStartTime } = useTimeGridEventMove({
      gridPositionFinder,
      timeGridData
    });
    if (isNil(movingEvent)) {
      return null;
    }
    return /* @__PURE__ */ y$3(TimeEvent, {
      uiModel: movingEvent,
      nextStartTime
    });
  }
  const TEST_IDS = {
    NOW_INDICATOR: "timegrid-now-indicator",
    NOW_INDICATOR_LABEL: "timegrid-now-indicator-label"
  };
  const classNames$3 = {
    line: cls(addTimeGridPrefix("now-indicator")),
    left: cls(addTimeGridPrefix("now-indicator-left")),
    marker: cls(addTimeGridPrefix("now-indicator-marker")),
    today: cls(addTimeGridPrefix("now-indicator-today")),
    right: cls(addTimeGridPrefix("now-indicator-right"))
  };
  function nowIndicatorTheme(theme) {
    return {
      pastBorder: theme.week.nowIndicatorPast.border,
      todayBorder: theme.week.nowIndicatorToday.border,
      futureBorder: theme.week.nowIndicatorFuture.border,
      bulletBackgroundColor: theme.week.nowIndicatorBullet.backgroundColor
    };
  }
  function NowIndicator({ top, columnWidth, columnCount, columnIndex }) {
    const { pastBorder, todayBorder, futureBorder, bulletBackgroundColor } = useTheme(nowIndicatorTheme);
    const layoutContainer = useLayoutContainer();
    const eventBus = useEventBus();
    const indicatorRef = F$2(null);
    const leftLine = {
      left: toPercent(columnWidth * columnIndex),
      width: toPercent(columnWidth * columnIndex)
    };
    const rightLine = {
      left: toPercent(columnWidth * (columnIndex + 1)),
      width: toPercent(columnWidth * (columnCount - columnIndex + 1))
    };
    _$2(() => {
      const scrollToNow = (behavior) => {
        var _a;
        const scrollArea = (_a = layoutContainer == null ? void 0 : layoutContainer.querySelector(`.${cls("panel")}.${cls("time")}`)) != null ? _a : null;
        if (scrollArea && indicatorRef.current) {
          const { offsetHeight: scrollAreaOffsetHeight } = scrollArea;
          const { offsetTop: targetOffsetTop } = indicatorRef.current;
          const newScrollTop = targetOffsetTop - scrollAreaOffsetHeight / 2;
          if (scrollArea.scrollTo) {
            scrollArea.scrollTo({ top: newScrollTop, behavior });
          } else {
            scrollArea.scrollTop = newScrollTop;
          }
        }
      };
      eventBus.on("scrollToNow", scrollToNow);
      return () => eventBus.off("scrollToNow", scrollToNow);
    }, [eventBus, layoutContainer]);
    _$2(() => {
      eventBus.fire("scrollToNow", "smooth");
    }, [eventBus]);
    return /* @__PURE__ */ y$3("div", {
      ref: indicatorRef,
      className: classNames$3.line,
      style: { top: toPercent(top) },
      "data-testid": TEST_IDS.NOW_INDICATOR
    }, /* @__PURE__ */ y$3("div", {
      className: classNames$3.left,
      style: { width: leftLine.width, borderTop: pastBorder }
    }), /* @__PURE__ */ y$3("div", {
      className: classNames$3.marker,
      style: { left: leftLine.left, backgroundColor: bulletBackgroundColor }
    }), /* @__PURE__ */ y$3("div", {
      className: classNames$3.today,
      style: {
        left: leftLine.left,
        width: toPercent(columnWidth),
        borderTop: todayBorder
      }
    }), /* @__PURE__ */ y$3("div", {
      className: classNames$3.right,
      style: {
        left: rightLine.left,
        borderTop: futureBorder
      }
    }));
  }
  const classNames$2 = {
    now: addTimeGridPrefix("current-time"),
    dayDifference: addTimeGridPrefix("day-difference")
  };
  function NowIndicatorLabel({ unit, top, now, zonedNow }) {
    const color = useTheme(x$3((theme) => theme.week.nowIndicatorLabel.color, []));
    const dateDifference = q$1(() => {
      return getDateDifference(zonedNow, now);
    }, [zonedNow, now]);
    const model = {
      unit,
      time: zonedNow,
      format: timeFormats[unit]
    };
    return /* @__PURE__ */ y$3("div", {
      className: cls(classNames$2.now),
      style: { top: toPercent(top), color },
      "data-testid": TEST_IDS.NOW_INDICATOR_LABEL
    }, dateDifference !== 0 && /* @__PURE__ */ y$3("span", {
      className: cls(classNames$2.dayDifference)
    }, `[${dateDifference > 0 ? "+" : "-"}${Math.abs(dateDifference)}]`), /* @__PURE__ */ y$3(Template, {
      template: "timegridNowIndicatorLabel",
      param: model,
      as: "span"
    }));
  }
  const monthVisibleEventCountSelector = (state) => {
    var _a;
    return (_a = state.options.month.visibleEventCount) != null ? _a : 6;
  };
  const showNowIndicatorOptionSelector = (state) => state.options.week.showNowIndicator;
  const showTimezoneCollapseButtonOptionSelector = (state) => {
    var _a;
    return (_a = state.options.week.showTimezoneCollapseButton) != null ? _a : false;
  };
  const timezonesCollapsedOptionSelector = (state) => {
    var _a;
    return (_a = state.options.week.timezonesCollapsed) != null ? _a : false;
  };
  const classNames$1 = {
    timeColumn: addTimeGridPrefix("time-column"),
    hourRows: addTimeGridPrefix("hour-rows"),
    time: addTimeGridPrefix("time"),
    timeLabel: addTimeGridPrefix("time-label"),
    first: addTimeGridPrefix("time-first"),
    last: addTimeGridPrefix("time-last"),
    hidden: addTimeGridPrefix("time-hidden")
  };
  function backgroundColorSelector(theme) {
    return {
      primaryTimezoneBackgroundColor: theme.week.timeGridLeft.backgroundColor,
      subTimezoneBackgroundColor: theme.week.timeGridLeftAdditionalTimezone.backgroundColor
    };
  }
  function timeColorSelector(theme) {
    return {
      pastTimeColor: theme.week.pastTime.color,
      futureTimeColor: theme.week.futureTime.color
    };
  }
  function HourRows({ rowsInfo, isPrimary, borderRight, width, nowIndicatorState }) {
    var _a;
    const showNowIndicator = useStore(showNowIndicatorOptionSelector);
    const { primaryTimezoneBackgroundColor, subTimezoneBackgroundColor } = useTheme(backgroundColorSelector);
    const { pastTimeColor, futureTimeColor } = useTheme(timeColorSelector);
    const zonedNow = isPresent(nowIndicatorState) ? addMinutes(nowIndicatorState.now, (_a = rowsInfo[0].diffFromPrimaryTimezone) != null ? _a : 0) : null;
    const backgroundColor = isPrimary ? primaryTimezoneBackgroundColor : subTimezoneBackgroundColor;
    return /* @__PURE__ */ y$3("div", {
      role: "rowgroup",
      className: cls(classNames$1.hourRows),
      style: { width: toPercent(width), borderRight, backgroundColor }
    }, rowsInfo.map(({ date: date2, top, className: className2 }) => {
      const isPast = isPresent(zonedNow) && date2 < zonedNow;
      const color = isPast ? pastTimeColor : futureTimeColor;
      return /* @__PURE__ */ y$3("div", {
        key: date2.getTime(),
        className: className2,
        style: {
          top: toPercent(top),
          color
        },
        role: "row"
      }, /* @__PURE__ */ y$3(Template, {
        template: `timegridDisplay${isPrimary ? "Primary" : ""}Time`,
        param: { time: date2 },
        as: "span"
      }));
    }), showNowIndicator && isPresent(nowIndicatorState) && isPresent(zonedNow) && /* @__PURE__ */ y$3(NowIndicatorLabel, {
      unit: "hour",
      top: nowIndicatorState.top,
      now: nowIndicatorState.now,
      zonedNow
    }));
  }
  const TimeColumn = w$1(function TimeColumn2({ timeGridRows, nowIndicatorState }) {
    const { STEPS } = getTimeSteps(timeGridRows);
    const showNowIndicator = useStore(showNowIndicatorOptionSelector);
    const timezones = useStore(timezonesSelector);
    const timezonesCollapsed = useStore(timezonesCollapsedOptionSelector);
    const tzConverter = useTZConverter();
    const { width, borderRight } = useTheme(weekTimeGridLeftSelector);
    const rowsByHour = q$1(
      () => timeGridRows.filter((_2, index) => index % STEPS === 0 || index === timeGridRows.length - 1),
      [timeGridRows, STEPS]
    );
    const hourRowsPropsMapper = x$3(
      (row, index, diffFromPrimaryTimezone) => {
        const shouldHideRow = ({ top: rowTop, height: rowHeight }) => {
          if (!showNowIndicator || isNil(nowIndicatorState)) {
            return false;
          }
          const indicatorTop = nowIndicatorState.top;
          return rowTop - rowHeight <= indicatorTop && indicatorTop <= rowTop + rowHeight;
        };
        const isFirst = index === 0;
        const isLast = index === rowsByHour.length - 1;
        const className2 = cls(classNames$1.time, {
          [classNames$1.first]: isFirst,
          [classNames$1.last]: isLast,
          [classNames$1.hidden]: shouldHideRow(row)
        });
        let date2 = setTimeStrToDate(new TZDate(), isLast ? row.endTime : row.startTime);
        if (isPresent(diffFromPrimaryTimezone)) {
          date2 = addMinutes(date2, diffFromPrimaryTimezone);
        }
        return {
          date: date2,
          top: row.top,
          className: className2,
          diffFromPrimaryTimezone
        };
      },
      [rowsByHour, nowIndicatorState, showNowIndicator]
    );
    const [primaryTimezone, ...otherTimezones] = timezones;
    const hourRowsWidth = otherTimezones.length > 0 ? 100 / (otherTimezones.length + 1) : 100;
    const primaryTimezoneHourRowsProps = rowsByHour.map(
      (row, index) => hourRowsPropsMapper(row, index)
    );
    const otherTimezoneHourRowsProps = q$1(() => {
      if (otherTimezones.length === 0) {
        return [];
      }
      return otherTimezones.reverse().map((timezone) => {
        const { timezoneName } = timezone;
        const primaryTimezoneOffset = tzConverter(primaryTimezone.timezoneName).getTimezoneOffset();
        const currentTimezoneOffset = tzConverter(timezoneName).getTimezoneOffset();
        const diffFromPrimaryTimezone = currentTimezoneOffset - primaryTimezoneOffset;
        return rowsByHour.map(
          (row, index) => hourRowsPropsMapper(row, index, diffFromPrimaryTimezone)
        );
      });
    }, [hourRowsPropsMapper, otherTimezones, primaryTimezone, rowsByHour, tzConverter]);
    return /* @__PURE__ */ y$3("div", {
      className: cls(classNames$1.timeColumn),
      style: { width },
      "data-testid": "timegrid-time-column"
    }, !timezonesCollapsed && otherTimezoneHourRowsProps.map((rowsInfo) => /* @__PURE__ */ y$3(HourRows, {
      key: rowsInfo[0].diffFromPrimaryTimezone,
      rowsInfo,
      isPrimary: false,
      borderRight,
      width: hourRowsWidth,
      nowIndicatorState
    })), /* @__PURE__ */ y$3(HourRows, {
      rowsInfo: primaryTimezoneHourRowsProps,
      isPrimary: true,
      borderRight,
      width: timezonesCollapsed ? 100 : hourRowsWidth,
      nowIndicatorState
    }));
  });
  function getTopPercentByTime(date2, start, end) {
    const startTime = start.getTime();
    const endTime = end.getTime();
    const time = limit(date2.getTime(), [startTime], [endTime]) - startTime;
    const max2 = endTime - startTime;
    const topPercent = ratio(max2, 100, time);
    return limit(topPercent, [0], [100]);
  }
  function getTopHeightByTime(start, end, minTime, maxTime) {
    const top = getTopPercentByTime(start, minTime, maxTime);
    const bottom = getTopPercentByTime(end, minTime, maxTime);
    const height = bottom - top;
    return {
      top,
      height
    };
  }
  const MIN_HEIGHT_PERCENT = 1;
  function isBetween(startColumnTime, endColumnTime) {
    return (uiModel) => {
      const { goingDuration = 0, comingDuration = 0 } = uiModel.model;
      const ownStarts = addMinutes(uiModel.getStarts(), -goingDuration);
      const ownEnds = addMinutes(uiModel.getEnds(), comingDuration);
      return !(ownEnds <= startColumnTime || ownStarts >= endColumnTime);
    };
  }
  function setInnerHeights(uiModel, options) {
    const { renderStart, renderEnd, modelStart, modelEnd } = options;
    const { goingDuration = 0, comingDuration = 0 } = uiModel.model;
    let modelDurationHeight = 100;
    if (goingDuration > 0) {
      const { height: goingDurationHeight } = getTopHeightByTime(
        renderStart,
        modelStart,
        renderStart,
        renderEnd
      );
      uiModel.goingDurationHeight = goingDurationHeight;
      modelDurationHeight -= goingDurationHeight;
    }
    if (comingDuration > 0) {
      const { height: comingDurationHeight } = getTopHeightByTime(
        modelEnd,
        renderEnd,
        renderStart,
        renderEnd
      );
      uiModel.comingDurationHeight = comingDurationHeight;
      modelDurationHeight -= comingDurationHeight;
    }
    uiModel.modelDurationHeight = modelDurationHeight;
  }
  function setCroppedEdges(uiModel, options) {
    const { goingStart, comingEnd, startColumnTime, endColumnTime } = options;
    if (goingStart < startColumnTime) {
      uiModel.croppedStart = true;
    }
    if (comingEnd > endColumnTime) {
      uiModel.croppedEnd = true;
    }
  }
  function getDuplicateLeft(uiModel, baseLeft) {
    const { duplicateEvents, duplicateEventIndex } = uiModel;
    const prevEvent = duplicateEvents[duplicateEventIndex - 1];
    let left = baseLeft;
    if (prevEvent) {
      const { percent: leftPercent, px: leftPx } = extractPercentPx(`${prevEvent.duplicateLeft}`);
      const { percent: widthPercent, px: widthPx } = extractPercentPx(`${prevEvent.duplicateWidth}`);
      const percent = leftPercent + widthPercent;
      const px = leftPx + widthPx + TIME_EVENT_CONTAINER_MARGIN_LEFT;
      if (percent !== 0) {
        left = `calc(${toPercent(percent)} ${px > 0 ? "+" : "-"} ${toPx(Math.abs(px))})`;
      } else {
        left = toPx(px);
      }
    } else {
      left = toPercent(left);
    }
    return left;
  }
  function getDuplicateWidth(uiModel, baseWidth) {
    const { collapse } = uiModel;
    return collapse ? `${COLLAPSED_DUPLICATE_EVENT_WIDTH_PX}px` : `calc(${toPercent(baseWidth)} - ${toPx(
    (COLLAPSED_DUPLICATE_EVENT_WIDTH_PX + TIME_EVENT_CONTAINER_MARGIN_LEFT) * (uiModel.duplicateEvents.length - 1) + TIME_EVENT_CONTAINER_MARGIN_LEFT
  )})`;
  }
  function setDimension(uiModel, options) {
    const { startColumnTime, endColumnTime, baseWidth, columnIndex, renderStart, renderEnd } = options;
    const { duplicateEvents } = uiModel;
    const { top, height } = getTopHeightByTime(
      renderStart,
      renderEnd,
      startColumnTime,
      endColumnTime
    );
    const dimension = {
      top,
      left: baseWidth * columnIndex,
      width: baseWidth,
      height: Math.max(MIN_HEIGHT_PERCENT, height),
      duplicateLeft: "",
      duplicateWidth: ""
    };
    if (duplicateEvents.length > 0) {
      dimension.duplicateLeft = getDuplicateLeft(uiModel, dimension.left);
      dimension.duplicateWidth = getDuplicateWidth(uiModel, dimension.width);
    }
    uiModel.setUIProps(dimension);
  }
  function getRenderInfoOptions(uiModel, columnIndex, baseWidth, startColumnTime, endColumnTime) {
    const { goingDuration = 0, comingDuration = 0 } = uiModel.model;
    const modelStart = uiModel.getStarts();
    const modelEnd = uiModel.getEnds();
    const goingStart = addMinutes(modelStart, -goingDuration);
    const comingEnd = addMinutes(modelEnd, comingDuration);
    const renderStart = max(goingStart, startColumnTime);
    const renderEnd = min(comingEnd, endColumnTime);
    return {
      baseWidth,
      columnIndex,
      modelStart,
      modelEnd,
      renderStart,
      renderEnd,
      goingStart,
      comingEnd,
      startColumnTime,
      endColumnTime,
      duplicateEvents: uiModel.duplicateEvents
    };
  }
  function setRenderInfo({
    uiModel,
    columnIndex,
    baseWidth,
    startColumnTime,
    endColumnTime,
    isDuplicateEvent = false
  }) {
    if (!isDuplicateEvent && uiModel.duplicateEvents.length > 0) {
      uiModel.duplicateEvents.forEach((event) => {
        setRenderInfo({
          uiModel: event,
          columnIndex,
          baseWidth,
          startColumnTime,
          endColumnTime,
          isDuplicateEvent: true
        });
      });
      return;
    }
    const renderInfoOptions = getRenderInfoOptions(
      uiModel,
      columnIndex,
      baseWidth,
      startColumnTime,
      endColumnTime
    );
    setDimension(uiModel, renderInfoOptions);
    setInnerHeights(uiModel, renderInfoOptions);
    setCroppedEdges(uiModel, renderInfoOptions);
  }
  function setDuplicateEvents(uiModels, options, selectedDuplicateEventCid) {
    const { getDuplicateEvents, getMainEvent } = options;
    const eventObjects = uiModels.map((uiModel) => uiModel.model.toEventObject());
    uiModels.forEach((targetUIModel) => {
      if (targetUIModel.collapse || targetUIModel.duplicateEvents.length > 0) {
        return;
      }
      const duplicateEvents = getDuplicateEvents(targetUIModel.model.toEventObject(), eventObjects);
      if (duplicateEvents.length <= 1) {
        return;
      }
      const mainEvent = getMainEvent(duplicateEvents);
      const duplicateEventUIModels = duplicateEvents.map(
        (event) => uiModels.find((uiModel) => uiModel.cid() === event.__cid)
      );
      const isSelectedGroup = !!(selectedDuplicateEventCid > DEFAULT_DUPLICATE_EVENT_CID && duplicateEvents.find((event) => event.__cid === selectedDuplicateEventCid));
      const duplicateStarts = duplicateEvents.reduce((acc, { start, goingDuration }) => {
        const renderStart = addMinutes(start, -goingDuration);
        return min(acc, renderStart);
      }, duplicateEvents[0].start);
      const duplicateEnds = duplicateEvents.reduce((acc, { end, comingDuration }) => {
        const renderEnd = addMinutes(end, comingDuration);
        return max(acc, renderEnd);
      }, duplicateEvents[0].end);
      duplicateEventUIModels.forEach((event, index) => {
        const isMain = event.cid() === mainEvent.__cid;
        const collapse = !(isSelectedGroup && event.cid() === selectedDuplicateEventCid || !isSelectedGroup && isMain);
        event.setUIProps({
          duplicateEvents: duplicateEventUIModels,
          duplicateEventIndex: index,
          collapse,
          isMain,
          duplicateStarts,
          duplicateEnds
        });
      });
    });
    return uiModels;
  }
  function setRenderInfoOfUIModels(events, startColumnTime, endColumnTime, selectedDuplicateEventCid, collapseDuplicateEventsOptions) {
    const uiModels = events.filter(isTimeEvent).filter(isBetween(startColumnTime, endColumnTime)).sort(array.compare.event.asc);
    if (collapseDuplicateEventsOptions) {
      setDuplicateEvents(uiModels, collapseDuplicateEventsOptions, selectedDuplicateEventCid);
    }
    const expandedEvents = uiModels.filter((uiModel) => !uiModel.collapse);
    const uiModelColl = createEventCollection(...expandedEvents);
    const usingTravelTime = true;
    const collisionGroups = getCollisionGroup(expandedEvents, usingTravelTime);
    const matrices = getMatrices(uiModelColl, collisionGroups, usingTravelTime);
    matrices.forEach((matrix) => {
      const maxRowLength = Math.max(...matrix.map((row) => row.length));
      const baseWidth = Math.round(100 / maxRowLength);
      matrix.forEach((row) => {
        row.forEach((uiModel, columnIndex) => {
          setRenderInfo({ uiModel, columnIndex, baseWidth, startColumnTime, endColumnTime });
        });
      });
    });
    return uiModels;
  }
  function useInterval(callback, delay) {
    const savedCallback = F$2(callback);
    _$2(() => {
      savedCallback.current = callback;
    }, [callback]);
    _$2(() => {
      const tick = () => savedCallback.current();
      const intervalDelay = delay != null ? delay : -1;
      if (intervalDelay > 0) {
        const id = setInterval(tick, intervalDelay);
        return () => clearInterval(id);
      }
    }, [delay]);
  }
  function useIsMounted() {
    const isMountedRef = F$2(true);
    _$2(() => {
      return () => {
        isMountedRef.current = false;
      };
    }, []);
    return x$3(() => isMountedRef.current, []);
  }
  const classNames = {
    timegrid: cls(className),
    scrollArea: cls(addTimeGridPrefix("scroll-area"))
  };
  function TimeGrid({ timeGridData, events }) {
    const {
      isReadOnly,
      week: { narrowWeekend, startDayOfWeek, collapseDuplicateEvents }
    } = useStore(optionsSelector);
    const showNowIndicator = useStore(showNowIndicatorOptionSelector);
    const selectedDuplicateEventCid = useStore(
      (state) => state.weekViewLayout.selectedDuplicateEventCid
    );
    const [, getNow] = usePrimaryTimezone();
    const isMounted = useIsMounted();
    const { width: timeGridLeftWidth } = useTheme(weekTimeGridLeftSelector);
    const [nowIndicatorState, setNowIndicatorState] = p$2(null);
    const { columns, rows } = timeGridData;
    const lastColumnIndex = columns.length - 1;
    const totalUIModels = q$1(
      () => columns.map(
        ({ date: date2 }) => events.filter(isBetween(toStartOfDay(date2), toEndOfDay(date2))).map((uiModel) => uiModel.clone())
      ).map(
        (uiModelsByColumn, columnIndex) => setRenderInfoOfUIModels(
          uiModelsByColumn,
          setTimeStrToDate(columns[columnIndex].date, first(rows).startTime),
          setTimeStrToDate(columns[columnIndex].date, last(rows).endTime),
          selectedDuplicateEventCid,
          collapseDuplicateEvents
        )
      ),
      [columns, rows, events, selectedDuplicateEventCid, collapseDuplicateEvents]
    );
    const currentDateData = q$1(() => {
      const now = getNow();
      const currentDateIndexInColumns = columns.findIndex((column) => isSameDate(column.date, now));
      if (currentDateIndexInColumns < 0) {
        return null;
      }
      const startTime = setTimeStrToDate(
        columns[currentDateIndexInColumns].date,
        timeGridData.rows[0].startTime
      );
      const endTime = setTimeStrToDate(
        columns[currentDateIndexInColumns].date,
        last(timeGridData.rows).endTime
      );
      return {
        startTime,
        endTime,
        currentDateIndex: currentDateIndexInColumns
      };
    }, [columns, getNow, timeGridData.rows]);
    const [columnsContainer, setColumnsContainer] = useDOMNode();
    const gridPositionFinder = q$1(
      () => createGridPositionFinder({
        rowsCount: rows.length,
        columnsCount: columns.length,
        container: columnsContainer,
        narrowWeekend,
        startDayOfWeek
      }),
      [columns.length, columnsContainer, narrowWeekend, rows.length, startDayOfWeek]
    );
    const onMouseDown = useGridSelection({
      type: "timeGrid",
      gridPositionFinder,
      selectionSorter: timeGridSelectionHelper.sortSelection,
      dateGetter: timeGridSelectionHelper.getDateFromCollection,
      dateCollection: timeGridData
    });
    const updateTimeGridIndicator = x$3(() => {
      if (isPresent(currentDateData)) {
        const { startTime, endTime } = currentDateData;
        const now = getNow();
        if (startTime <= now && now <= endTime) {
          setNowIndicatorState({
            top: getTopPercentByTime(now, startTime, endTime),
            now
          });
        }
      }
    }, [currentDateData, getNow]);
    A$2(() => {
      var _a;
      if (isMounted()) {
        if (((_a = currentDateData == null ? void 0 : currentDateData.currentDateIndex) != null ? _a : -1) >= 0) {
          updateTimeGridIndicator();
        } else {
          setNowIndicatorState(null);
        }
      }
    }, [currentDateData, isMounted, updateTimeGridIndicator]);
    useInterval(updateTimeGridIndicator, isPresent(currentDateData) ? MS_PER_MINUTES : null);
    return /* @__PURE__ */ y$3("div", {
      className: classNames.timegrid
    }, /* @__PURE__ */ y$3("div", {
      className: classNames.scrollArea
    }, /* @__PURE__ */ y$3(TimeColumn, {
      timeGridRows: rows,
      nowIndicatorState
    }), /* @__PURE__ */ y$3("div", {
      className: cls("columns"),
      style: { left: timeGridLeftWidth },
      ref: setColumnsContainer,
      onMouseDown: passConditionalProp(!isReadOnly, onMouseDown)
    }, /* @__PURE__ */ y$3(GridLines, {
      timeGridRows: rows
    }), /* @__PURE__ */ y$3(MovingEventShadow$1, {
      gridPositionFinder,
      timeGridData
    }), columns.map((column, index) => /* @__PURE__ */ y$3(Column, {
      key: column.date.toString(),
      timeGridData,
      columnDate: column.date,
      columnWidth: toPercent(column.width),
      columnIndex: index,
      totalUIModels,
      gridPositionFinder,
      isLastColumn: index === lastColumnIndex
    })), showNowIndicator && isPresent(currentDateData) && isPresent(nowIndicatorState) ? /* @__PURE__ */ y$3(NowIndicator, {
      top: nowIndicatorState.top,
      columnWidth: columns[0].width,
      columnCount: columns.length,
      columnIndex: currentDateData.currentDateIndex
    }) : null)));
  }
  function TimezoneCollapseButton({ isCollapsed }) {
    const eventBus = useEventBus();
    const iconClassName = cls("icon", {
      "ic-arrow-right": isCollapsed,
      "ic-arrow-left": !isCollapsed
    });
    return /* @__PURE__ */ y$3("button", {
      className: cls(addTimeGridPrefix("timezone-collapse-button")),
      "aria-expanded": !isCollapsed,
      onClick: () => eventBus.fire("clickTimezonesCollapseBtn", isCollapsed)
    }, /* @__PURE__ */ y$3("span", {
      className: iconClassName,
      role: "img"
    }));
  }
  function TimezoneLabel({ label, offset, tooltip, width = 100, left }) {
    return /* @__PURE__ */ y$3("div", {
      title: tooltip,
      className: cls(addTimeGridPrefix("timezone-label")),
      style: {
        width: toPercent(width),
        height: toPercent(100),
        left: toPercent(left)
      },
      role: "gridcell"
    }, /* @__PURE__ */ y$3(Template, {
      template: "timezoneDisplayLabel",
      param: { displayLabel: label, timezoneOffset: offset },
      as: "span"
    }));
  }
  function useTimezoneCollapseOptions() {
    const showTimezoneCollapseButton = useStore(showTimezoneCollapseButtonOptionSelector);
    const timezonesCollapsed = useStore(timezonesCollapsedOptionSelector);
    return q$1(() => {
      return {
        showTimezoneCollapseButton,
        timezonesCollapsed
      };
    }, [showTimezoneCollapseButton, timezonesCollapsed]);
  }
  function TimezoneLabels({ top }) {
    const timezones = useStore(timezonesSelector);
    const { width } = useTheme(weekTimeGridLeftSelector);
    const tzConverter = useTZConverter();
    const { showTimezoneCollapseButton, timezonesCollapsed } = useTimezoneCollapseOptions();
    if (timezones.length <= 1) {
      return null;
    }
    const timezoneLabelProps = timezones.map(({ displayLabel, timezoneName, tooltip }) => {
      return !isUndefined_1(displayLabel) ? { label: displayLabel, offset: null, tooltip: tooltip != null ? tooltip : timezoneName } : {
        label: null,
        offset: tzConverter(timezoneName).getTimezoneOffset(),
        tooltip: tooltip != null ? tooltip : timezoneName
      };
    });
    const [primaryTimezone, ...restTimezones] = timezoneLabelProps;
    const subTimezones = restTimezones.reverse();
    const timezonesCount = timezonesCollapsed ? 1 : timezones.length;
    const timezoneLabelWidth = 100 / timezonesCount;
    return /* @__PURE__ */ y$3("div", {
      style: {
        top,
        width
      },
      role: "columnheader",
      className: cls("timezone-labels-slot")
    }, !timezonesCollapsed && subTimezones.map((subTimezone, index) => {
      var _a;
      return /* @__PURE__ */ y$3(TimezoneLabel, __spreadValues({
        key: `subTimezone-${(_a = subTimezone.label) != null ? _a : subTimezone.offset}`,
        width: timezoneLabelWidth,
        left: timezoneLabelWidth * index
      }, subTimezone));
    }), showTimezoneCollapseButton && /* @__PURE__ */ y$3(TimezoneCollapseButton, {
      isCollapsed: timezonesCollapsed
    }), /* @__PURE__ */ y$3(TimezoneLabel, __spreadValues({
      width: timezoneLabelWidth,
      left: timezoneLabelWidth * subTimezones.length
    }, primaryTimezone)));
  }
  const VIEW_TYPE = {
    MONTH: "month",
    WEEK: "week",
    DAY: "day"
  };
  const DEFAULT_TASK_PANEL = ["milestone", "task"];
  const DEFAULT_EVENT_PANEL = ["allday", "time"];
  function getActivePanels(taskView, eventView) {
    const activePanels = [];
    if (taskView === true) {
      activePanels.push(...DEFAULT_TASK_PANEL);
    } else if (Array.isArray(taskView)) {
      activePanels.push(...taskView);
    }
    if (eventView === true) {
      activePanels.push(...DEFAULT_EVENT_PANEL);
    } else if (Array.isArray(eventView)) {
      activePanels.push(...eventView);
    }
    return activePanels;
  }
  function useEventsWithTimezone(events) {
    const primaryTimezoneName = useStore(primaryTimezoneSelector);
    const tzConverter = useTZConverter();
    return q$1(() => {
      if (primaryTimezoneName === "Local") {
        return events;
      }
      const isSystemUsingDST = isUsingDST(new TZDate());
      const {
        timedEvents = createEventCollection(),
        totalEvents = createEventCollection()
      } = events.groupBy(
        (eventModel) => eventModel.category === "time" ? "timedEvents" : "totalEvents"
      );
      timedEvents.each((eventModel) => {
        const clonedEventModel = clone$1(eventModel);
        let zonedStart = tzConverter(primaryTimezoneName, clonedEventModel.start);
        let zonedEnd = tzConverter(primaryTimezoneName, clonedEventModel.end);
        if (isSystemUsingDST) {
          if (!isUsingDST(zonedStart)) {
            zonedStart = zonedStart.addHours(1);
          }
          if (!isUsingDST(zonedEnd)) {
            zonedEnd = zonedEnd.addHours(1);
          }
        } else {
          if (isUsingDST(zonedStart)) {
            zonedStart = zonedStart.addHours(-1);
          }
          if (isUsingDST(zonedEnd)) {
            zonedEnd = zonedEnd.addHours(-1);
          }
        }
        clonedEventModel.start = zonedStart;
        clonedEventModel.end = zonedEnd;
        totalEvents.add(clonedEventModel);
      });
      return totalEvents;
    }, [events, primaryTimezoneName, tzConverter]);
  }
  function useCalendarData(calendar, ...filters) {
    const filteredEvents = q$1(
      () => calendar.events.filter(Collection.and(...filters)),
      [calendar.events, filters]
    );
    const filteredEventsWithTimezone = useEventsWithTimezone(filteredEvents);
    return q$1(
      () => __spreadProps(__spreadValues({}, calendar), {
        events: filteredEventsWithTimezone
      }),
      [calendar, filteredEventsWithTimezone]
    );
  }
  function isTimeGridDraggingType(draggingItemType) {
    return /^(event|gridSelection)\/timeGrid/.test(draggingItemType != null ? draggingItemType : "");
  }
  function useTimeGridScrollSync(scrollArea, rowCount) {
    useTransientUpdate(dndSelector, ({ y: y2, draggingItemType, draggingState }) => {
      if (isPresent(scrollArea) && isTimeGridDraggingType(draggingItemType) && draggingState === DraggingState.DRAGGING && isPresent(y2)) {
        const { offsetTop, offsetHeight, scrollHeight } = scrollArea;
        const scrollBoundary = Math.floor(scrollHeight / rowCount);
        const layoutHeight = offsetTop + offsetHeight;
        if (y2 < offsetTop + scrollBoundary) {
          const scrollDiff = y2 - (offsetTop + scrollBoundary);
          scrollArea.scrollTop = Math.max(0, scrollArea.scrollTop + scrollDiff);
        } else if (y2 > layoutHeight - scrollBoundary) {
          const scrollDiff = y2 - (layoutHeight - scrollBoundary);
          scrollArea.scrollTop = Math.min(offsetHeight, scrollArea.scrollTop + scrollDiff);
        }
      }
    });
  }
  function timegridHeightSelector(state) {
    var _a, _b, _c;
    return (_c = (_b = (_a = state.weekViewLayout) == null ? void 0 : _a.dayGridRows) == null ? void 0 : _b.time) == null ? void 0 : _c.height;
  }
  function useTimezoneLabelsTop(timePanel) {
    const timeGridPanelHeight = useStore(timegridHeightSelector);
    const [stickyTop, setStickyTop] = p$2(null);
    A$2(() => {
      if (isPresent(timeGridPanelHeight) && timePanel) {
        setStickyTop(timePanel.offsetTop);
      }
    }, [timeGridPanelHeight, timePanel]);
    return stickyTop;
  }
  function useDayViewState() {
    const calendar = useStore(calendarSelector);
    const options = useStore(optionsSelector);
    const { dayGridRows: gridRowLayout, lastPanelType } = useStore(weekViewLayoutSelector);
    const { renderDate } = useStore(viewSelector);
    return q$1(
      () => ({
        calendar,
        options,
        gridRowLayout,
        lastPanelType,
        renderDate
      }),
      [calendar, options, gridRowLayout, lastPanelType, renderDate]
    );
  }
  function Day$1() {
    var _a, _b;
    const { calendar, options, gridRowLayout, lastPanelType, renderDate } = useDayViewState();
    const primaryTimezoneName = useStore(primaryTimezoneSelector);
    const gridHeaderMarginLeft = useTheme(x$3((theme) => theme.week.dayGridLeft.width, []));
    const [timePanel, setTimePanelRef] = useDOMNode();
    const weekOptions = options.week;
    const {
      narrowWeekend,
      startDayOfWeek,
      workweek,
      hourStart,
      hourEnd,
      eventView,
      taskView,
      timeStep
    } = weekOptions;
    const days = q$1(() => [renderDate], [renderDate]);
    const dayNames = getDayNames(days, (_b = (_a = options.week) == null ? void 0 : _a.dayNames) != null ? _b : []);
    const { rowStyleInfo, cellWidthMap } = getRowStyleInfo(
      days.length,
      narrowWeekend,
      startDayOfWeek,
      workweek
    );
    const calendarData = useCalendarData(calendar, options.eventFilter);
    const dayGridEvents = q$1(() => {
      const getFilterRange = () => {
        if (primaryTimezoneName === "Local") {
          return [toStartOfDay(days[0]), toEndOfDay(days[0])];
        }
        return [toStartOfDay(addDate(days[0], -1)), toEndOfDay(addDate(days[0], 1))];
      };
      const [weekStartDate, weekEndDate] = getFilterRange();
      return getWeekViewEvents(days, calendarData, {
        narrowWeekend,
        hourStart,
        hourEnd,
        weekStartDate,
        weekEndDate
      });
    }, [calendarData, days, hourEnd, hourStart, narrowWeekend, primaryTimezoneName]);
    const timeGridData = q$1(
      () => createTimeGridData(days, {
        hourStart,
        hourEnd,
        narrowWeekend,
        timeStep
      }),
      [days, hourEnd, hourStart, narrowWeekend, timeStep]
    );
    const activePanels = getActivePanels(taskView, eventView);
    const gridRows = activePanels.map((key) => {
      var _a2, _b2;
      if (key === "time") {
        return null;
      }
      const rowType = key;
      return /* @__PURE__ */ y$3(Panel, {
        key: rowType,
        name: rowType,
        resizable: rowType !== lastPanelType
      }, rowType === "allday" ? /* @__PURE__ */ y$3(AlldayGridRow, {
        events: dayGridEvents[rowType],
        rowStyleInfo,
        gridColWidthMap: cellWidthMap,
        weekDates: days,
        height: (_a2 = gridRowLayout[rowType]) == null ? void 0 : _a2.height,
        options: weekOptions
      }) : /* @__PURE__ */ y$3(OtherGridRow, {
        category: rowType,
        events: dayGridEvents[rowType],
        weekDates: days,
        height: (_b2 = gridRowLayout[rowType]) == null ? void 0 : _b2.height,
        options: weekOptions,
        gridColWidthMap: cellWidthMap
      }));
    });
    useTimeGridScrollSync(timePanel, timeGridData.rows.length);
    const stickyTop = useTimezoneLabelsTop(timePanel);
    return /* @__PURE__ */ y$3(Layout, {
      className: cls("day-view"),
      autoAdjustPanels: true
    }, /* @__PURE__ */ y$3(Panel, {
      name: "day-view-day-names",
      initialHeight: WEEK_DAY_NAME_HEIGHT + WEEK_DAY_NAME_BORDER
    }, /* @__PURE__ */ y$3(GridHeader, {
      type: "week",
      dayNames,
      marginLeft: gridHeaderMarginLeft,
      rowStyleInfo
    })), gridRows, activePanels.includes("time") ? /* @__PURE__ */ y$3(Panel, {
      name: "time",
      autoSize: 1,
      ref: setTimePanelRef
    }, /* @__PURE__ */ y$3(TimeGrid, {
      events: dayGridEvents.time,
      timeGridData
    }), /* @__PURE__ */ y$3(TimezoneLabels, {
      top: stickyTop
    })) : null);
  }
  function AccumulatedGridSelection({ rowIndex, weekDates, narrowWeekend }) {
    const gridSelectionDataByRow = useStore(
      x$3(
        (state) => state.gridSelection.accumulated.dayGridMonth.map(
          (gridSelection) => dayGridMonthSelectionHelper.calculateSelection(gridSelection, rowIndex, weekDates.length)
        ),
        [rowIndex, weekDates]
      )
    );
    return /* @__PURE__ */ y$3("div", {
      className: cls("accumulated-grid-selection")
    }, gridSelectionDataByRow.map(
      (gridSelectionData) => gridSelectionData ? /* @__PURE__ */ y$3(GridSelection$1, {
        type: "accumulated",
        gridSelectionData,
        weekDates,
        narrowWeekend
      }) : null
    ));
  }
  function MoreEventsButton({ type, number, onClickButton, className: className2 }) {
    const { reset } = useDispatch("dnd");
    const handleMouseDown = (e2) => {
      e2.stopPropagation();
    };
    const handleClick = () => {
      reset();
      onClickButton();
    };
    const exceedButtonTemplate = `monthGrid${type === CellBarType.header ? "Header" : "Footer"}Exceed`;
    return /* @__PURE__ */ y$3("button", {
      type: "button",
      onMouseDown: handleMouseDown,
      onClick: handleClick,
      className: className2
    }, /* @__PURE__ */ y$3(Template, {
      template: exceedButtonTemplate,
      param: number
    }));
  }
  function getDateColor({
    date: date2,
    theme,
    renderDate,
    isToday
  }) {
    const dayIndex = date2.getDay();
    const thisMonth = renderDate.getMonth();
    const isSameMonth2 = thisMonth === date2.getMonth();
    const {
      common: { holiday, saturday, today, dayName },
      month: { dayExceptThisMonth, holidayExceptThisMonth }
    } = theme;
    if (isToday) {
      return today.color;
    }
    if (isSunday(dayIndex)) {
      return isSameMonth2 ? holiday.color : holidayExceptThisMonth.color;
    }
    if (isSaturday(dayIndex)) {
      return isSameMonth2 ? saturday.color : dayExceptThisMonth.color;
    }
    if (!isSameMonth2) {
      return dayExceptThisMonth.color;
    }
    return dayName.color;
  }
  function useCellHeaderTheme() {
    const common = useCommonTheme();
    const month = useMonthTheme();
    return q$1(() => ({ common, month }), [common, month]);
  }
  function CellHeader({
    type = CellBarType.header,
    exceedCount = 0,
    date: date2,
    onClickExceedCount
  }) {
    const { renderDate } = useStore(viewSelector);
    const [, getNow] = usePrimaryTimezone();
    const theme = useCellHeaderTheme();
    const height = theme.month.gridCell[`${type}Height`];
    const ymd = toFormat(date2, "YYYYMMDD");
    const todayYmd = toFormat(getNow(), "YYYYMMDD");
    const isToday = ymd === todayYmd;
    const templateParam = {
      date: toFormat(date2, "YYYY-MM-DD"),
      day: date2.getDay(),
      hiddenEventCount: exceedCount,
      isOtherMonth: date2.getMonth() !== renderDate.getMonth(),
      isToday: ymd === todayYmd,
      month: date2.getMonth(),
      ymd
    };
    const gridCellDateStyle = { color: getDateColor({ date: date2, theme, isToday, renderDate }) };
    const monthGridTemplate = `monthGrid${capitalize(type)}`;
    if (isNil(height)) {
      return null;
    }
    return /* @__PURE__ */ y$3("div", {
      className: cls(`grid-cell-${type}`),
      style: { height }
    }, /* @__PURE__ */ y$3("span", {
      className: cls("grid-cell-date"),
      style: gridCellDateStyle
    }, /* @__PURE__ */ y$3(Template, {
      template: monthGridTemplate,
      param: templateParam
    })), exceedCount ? /* @__PURE__ */ y$3(MoreEventsButton, {
      type,
      number: exceedCount,
      onClickButton: onClickExceedCount,
      className: cls("grid-cell-more-events")
    }) : null);
  }
  function getSeeMorePopupSize({
    grid,
    offsetWidth,
    eventLength,
    layerSize
  }) {
    const minHeight = getSize(grid).height + MONTH_MORE_VIEW_PADDING * 2;
    let width = offsetWidth + MONTH_MORE_VIEW_PADDING * 2;
    const { width: moreViewWidth, height: moreViewHeight } = layerSize;
    const MAX_DISPLAY_EVENT_COUNT = 10;
    width = Math.max(width, MONTH_MORE_VIEW_MIN_WIDTH);
    let height = MONTH_MORE_VIEW_HEADER_HEIGHT + MONTH_MORE_VIEW_HEADER_MARGIN_BOTTOM + MONTH_MORE_VIEW_PADDING;
    const eventHeight = MONTH_EVENT_HEIGHT + MONTH_EVENT_MARGIN_TOP;
    if (eventLength <= MAX_DISPLAY_EVENT_COUNT) {
      height += eventHeight * eventLength;
    } else {
      height += eventHeight * MAX_DISPLAY_EVENT_COUNT;
    }
    if (moreViewWidth) {
      width = moreViewWidth;
    }
    if (moreViewHeight) {
      height = moreViewHeight;
    }
    if (isNaN(height) || height < minHeight) {
      height = minHeight;
    }
    return { width, height };
  }
  function getSeeMorePopupPosition(popupSize, appContainerSize, cellRect) {
    const {
      width: containerWidth,
      height: containerHeight,
      left: containerLeft,
      top: containerTop
    } = appContainerSize;
    const { width: popupWidth, height: popupHeight } = popupSize;
    const containerRight = containerLeft + containerWidth;
    const containerBottom = containerTop + containerHeight;
    let left = cellRect.left + cellRect.width / 2 - popupWidth / 2;
    let { top } = cellRect;
    const isLeftOutOfContainer = left < containerLeft;
    const isRightOutOfContainer = left + popupWidth > containerRight;
    const isUpperOutOfContainer = top < containerTop;
    const isLowerOutOfContainer = top + popupHeight > containerBottom;
    if (isLeftOutOfContainer) {
      left = containerLeft;
    }
    if (isRightOutOfContainer) {
      left = containerRight - popupWidth;
    }
    if (isUpperOutOfContainer) {
      top = containerTop;
    }
    if (isLowerOutOfContainer) {
      top = containerBottom - popupHeight;
    }
    return { top: top + window.scrollY, left: left + window.scrollX };
  }
  function getSeeMorePopupRect({
    layoutContainer,
    cell,
    popupSize
  }) {
    const containerRect = layoutContainer.getBoundingClientRect();
    const cellRect = cell.getBoundingClientRect();
    const popupPosition = getSeeMorePopupPosition(popupSize, containerRect, cellRect);
    return __spreadValues(__spreadValues({}, popupSize), popupPosition);
  }
  function usePopupPosition(eventLength, parentContainer, layoutContainer) {
    const { width: moreViewWidth, height: moreViewHeight } = useTheme(monthMoreViewSelector);
    const [container, containerRefCallback] = useDOMNode();
    const [popupPosition, setPopupPosition] = p$2(null);
    _$2(() => {
      if (layoutContainer && parentContainer && container) {
        const popupSize = getSeeMorePopupSize({
          grid: parentContainer,
          offsetWidth: container.offsetWidth,
          eventLength,
          layerSize: {
            width: moreViewWidth,
            height: moreViewHeight
          }
        });
        const rect = getSeeMorePopupRect({
          cell: container,
          layoutContainer,
          popupSize
        });
        setPopupPosition(rect);
      }
    }, [layoutContainer, container, eventLength, parentContainer, moreViewWidth, moreViewHeight]);
    return { popupPosition, containerRefCallback };
  }
  function weekendBackgroundColorSelector(theme) {
    return theme.month.weekend.backgroundColor;
  }
  function GridCell({ date: date2, events = [], style, parentContainer, contentAreaHeight }) {
    const layoutContainer = useLayoutContainer();
    const { showSeeMorePopup } = useDispatch("popup");
    const backgroundColor = useTheme(weekendBackgroundColorSelector);
    const { popupPosition, containerRefCallback } = usePopupPosition(
      events.length,
      parentContainer,
      layoutContainer
    );
    const onOpenSeeMorePopup = x$3(() => {
      if (popupPosition) {
        showSeeMorePopup({
          date: date2,
          popupPosition,
          events
        });
      }
    }, [date2, events, popupPosition, showSeeMorePopup]);
    const exceedCount = getExceedCount(
      events,
      contentAreaHeight,
      MONTH_EVENT_HEIGHT + MONTH_EVENT_MARGIN_TOP
    );
    return /* @__PURE__ */ y$3("div", {
      className: cls("daygrid-cell"),
      style: __spreadProps(__spreadValues({}, style), { backgroundColor: isWeekend(date2.getDay()) ? backgroundColor : "inherit" }),
      ref: containerRefCallback
    }, /* @__PURE__ */ y$3(CellHeader, {
      type: CellBarType.header,
      exceedCount,
      date: date2,
      onClickExceedCount: onOpenSeeMorePopup
    }), /* @__PURE__ */ y$3(CellHeader, {
      type: CellBarType.footer,
      exceedCount,
      date: date2,
      onClickExceedCount: onOpenSeeMorePopup
    }));
  }
  const GridRow = w$1(function GridRow2({
    week,
    rowInfo,
    gridDateEventModelMap = {},
    contentAreaHeight
  }) {
    const [container, containerRefCallback] = useDOMNode();
    const border = useTheme(x$3((theme) => theme.common.border, []));
    return /* @__PURE__ */ y$3("div", {
      className: cls("weekday-grid"),
      style: { borderTop: border },
      ref: containerRefCallback
    }, week.map((date2, columnIndex) => {
      const dayIndex = date2.getDay();
      const { width, left } = rowInfo[columnIndex];
      const ymd = toFormat(toStartOfDay(date2), "YYYYMMDD");
      return /* @__PURE__ */ y$3(GridCell, {
        key: `daygrid-cell-${dayIndex}`,
        date: date2,
        style: {
          width: toPercent(width),
          left: toPercent(left)
        },
        parentContainer: container,
        events: gridDateEventModelMap[ymd],
        contentAreaHeight
      });
    }));
  });
  function GridSelectionByRow({ weekDates, narrowWeekend, rowIndex }) {
    const gridSelectionDataByRow = useStore(
      x$3(
        (state) => dayGridMonthSelectionHelper.calculateSelection(
          state.gridSelection.dayGridMonth,
          rowIndex,
          weekDates.length
        ),
        [rowIndex, weekDates.length]
      )
    );
    if (isNil(gridSelectionDataByRow)) {
      return null;
    }
    return /* @__PURE__ */ y$3(GridSelection$1, {
      type: "month",
      gridSelectionData: gridSelectionDataByRow,
      weekDates,
      narrowWeekend
    });
  }
  const MonthEvents = w$1(function MonthEvents2({
    contentAreaHeight,
    eventHeight = EVENT_HEIGHT,
    events,
    name,
    className: className2
  }) {
    const { headerHeight } = useTheme(monthGridCellSelector);
    const dayEvents = events.filter(isWithinHeight(contentAreaHeight, eventHeight + MONTH_EVENT_MARGIN_TOP)).map((uiModel) => /* @__PURE__ */ y$3(HorizontalEvent, {
      key: `${name}-DayEvent-${uiModel.cid()}`,
      uiModel,
      eventHeight,
      headerHeight: headerHeight != null ? headerHeight : MONTH_CELL_BAR_HEIGHT
    }));
    return /* @__PURE__ */ y$3("div", {
      className: className2
    }, dayEvents);
  });
  function useDayGridMonthEventMove({
    dateMatrix,
    rowInfo,
    gridPositionFinder,
    rowIndex
  }) {
    const eventBus = useEventBus();
    const {
      isDraggingEnd,
      isDraggingCanceled,
      draggingEvent: movingEvent,
      clearDraggingEvent
    } = useDraggingEvent("dayGrid", "move");
    const [currentGridPos, clearCurrentGridPos] = useCurrentPointerPositionInGrid(gridPositionFinder);
    const movingEventUIModel = q$1(() => {
      var _a, _b;
      let shadowEventUIModel = null;
      if (movingEvent && (currentGridPos == null ? void 0 : currentGridPos.rowIndex) === rowIndex) {
        shadowEventUIModel = movingEvent;
        shadowEventUIModel.left = rowInfo[(_a = currentGridPos == null ? void 0 : currentGridPos.columnIndex) != null ? _a : 0].left;
        shadowEventUIModel.width = rowInfo[(_b = currentGridPos == null ? void 0 : currentGridPos.columnIndex) != null ? _b : 0].width;
      }
      return shadowEventUIModel;
    }, [movingEvent, currentGridPos == null ? void 0 : currentGridPos.rowIndex, currentGridPos == null ? void 0 : currentGridPos.columnIndex, rowIndex, rowInfo]);
    useWhen(() => {
      const shouldUpdate = !isDraggingCanceled && isPresent(movingEventUIModel) && isPresent(currentGridPos);
      if (shouldUpdate) {
        const preStartDate = movingEventUIModel.model.getStarts();
        const eventDuration = movingEventUIModel.duration();
        const currentDate = dateMatrix[currentGridPos.rowIndex][currentGridPos.columnIndex];
        const timeOffsetPerDay = getDateDifference(currentDate, preStartDate) * MS_PER_DAY;
        const newStartDate = new TZDate(preStartDate.getTime() + timeOffsetPerDay);
        const newEndDate = new TZDate(newStartDate.getTime() + eventDuration);
        eventBus.fire("beforeUpdateEvent", {
          event: movingEventUIModel.model.toEventObject(),
          changes: {
            start: newStartDate,
            end: newEndDate
          }
        });
      }
      clearDraggingEvent();
      clearCurrentGridPos();
    }, isDraggingEnd);
    return movingEventUIModel;
  }
  function MovingEventShadow({ dateMatrix, gridPositionFinder, rowInfo, rowIndex }) {
    const movingEvent = useDayGridMonthEventMove({
      dateMatrix,
      rowInfo,
      gridPositionFinder,
      rowIndex
    });
    if (isNil(movingEvent)) {
      return null;
    }
    return /* @__PURE__ */ y$3(HorizontalEvent, {
      uiModel: movingEvent,
      movingLeft: movingEvent.left,
      eventHeight: EVENT_HEIGHT,
      headerHeight: MONTH_CELL_PADDING_TOP + MONTH_CELL_BAR_HEIGHT
    });
  }
  function getRowPosOfUIModel(uiModel, dateRow) {
    const startColumnIndex = Math.max(getGridDateIndex(uiModel.getStarts(), dateRow), 0);
    const endColumnIndex = getGridDateIndex(uiModel.getEnds(), dateRow);
    return {
      startColumnIndex,
      endColumnIndex
    };
  }
  function useDayGridMonthEventResize({
    dateMatrix,
    gridPositionFinder,
    renderedUIModels,
    cellWidthMap,
    rowIndex
  }) {
    const eventBus = useEventBus();
    const {
      isDraggingEnd,
      isDraggingCanceled,
      draggingEvent: resizingStartUIModel,
      clearDraggingEvent
    } = useDraggingEvent("dayGrid", "resize");
    const [currentGridPos, clearCurrentGridPos] = useCurrentPointerPositionInGrid(gridPositionFinder);
    const [guideProps, setGuideProps] = p$2(null);
    const clearStates = x$3(() => {
      setGuideProps(null);
      clearCurrentGridPos();
      clearDraggingEvent();
    }, [clearCurrentGridPos, clearDraggingEvent]);
    const baseResizingInfo = q$1(() => {
      if (isNil(resizingStartUIModel)) {
        return null;
      }
      const resizeTargetUIModelRows = renderedUIModels.map(
        ({ uiModels }) => uiModels.filter(
          (uiModel) => uiModel.cid() === resizingStartUIModel.cid()
        )
      );
      const eventStartDateRowIndex = resizeTargetUIModelRows.findIndex((row) => row.length > 0);
      const eventEndDateRowIndex = findLastIndex(resizeTargetUIModelRows, (row) => row.length > 0);
      const eventStartUIModelPos = getRowPosOfUIModel(
        resizeTargetUIModelRows[eventStartDateRowIndex][0],
        dateMatrix[eventStartDateRowIndex]
      );
      const eventEndUIModelPos = getRowPosOfUIModel(
        resizeTargetUIModelRows[eventEndDateRowIndex][0],
        dateMatrix[eventEndDateRowIndex]
      );
      return {
        eventStartDateColumnIndex: eventStartUIModelPos.startColumnIndex,
        eventStartDateRowIndex,
        eventEndDateColumnIndex: eventEndUIModelPos.endColumnIndex,
        eventEndDateRowIndex,
        resizeTargetUIModelRows
      };
    }, [dateMatrix, renderedUIModels, resizingStartUIModel]);
    const canCalculateProps = isPresent(baseResizingInfo) && isPresent(resizingStartUIModel) && isPresent(currentGridPos);
    _$2(() => {
      if (canCalculateProps && rowIndex === baseResizingInfo.eventStartDateRowIndex) {
        const { eventStartDateRowIndex, eventStartDateColumnIndex } = baseResizingInfo;
        const clonedUIModel = baseResizingInfo.resizeTargetUIModelRows[eventStartDateRowIndex][0].clone();
        let height;
        if (eventStartDateRowIndex === currentGridPos.rowIndex) {
          height = cellWidthMap[eventStartDateColumnIndex][Math.max(eventStartDateColumnIndex, currentGridPos.columnIndex)];
        } else if (eventStartDateRowIndex > currentGridPos.rowIndex) {
          height = cellWidthMap[eventStartDateColumnIndex][eventStartDateColumnIndex];
        } else {
          height = cellWidthMap[eventStartDateColumnIndex][dateMatrix[rowIndex].length - 1];
          clonedUIModel.setUIProps({ exceedRight: true });
        }
        setGuideProps([clonedUIModel, height]);
      }
    }, [baseResizingInfo, canCalculateProps, cellWidthMap, currentGridPos, dateMatrix, rowIndex]);
    _$2(() => {
      if (canCalculateProps && baseResizingInfo.eventStartDateRowIndex < rowIndex && rowIndex < currentGridPos.rowIndex) {
        const clonedUIModel = resizingStartUIModel.clone();
        clonedUIModel.setUIProps({ left: 0, exceedLeft: true, exceedRight: true });
        setGuideProps([clonedUIModel, "100%"]);
      }
    }, [baseResizingInfo, canCalculateProps, currentGridPos, resizingStartUIModel, rowIndex]);
    _$2(() => {
      if (canCalculateProps && baseResizingInfo.eventStartDateRowIndex < currentGridPos.rowIndex && rowIndex === currentGridPos.rowIndex) {
        const clonedUIModel = resizingStartUIModel.clone();
        clonedUIModel.setUIProps({ left: 0, exceedLeft: true });
        setGuideProps([clonedUIModel, cellWidthMap[0][currentGridPos.columnIndex]]);
      }
    }, [
      baseResizingInfo,
      canCalculateProps,
      cellWidthMap,
      currentGridPos,
      resizingStartUIModel,
      rowIndex
    ]);
    _$2(() => {
      if (canCalculateProps && rowIndex > baseResizingInfo.eventStartDateRowIndex && rowIndex > currentGridPos.rowIndex) {
        setGuideProps(null);
      }
    }, [canCalculateProps, currentGridPos, baseResizingInfo, rowIndex]);
    useWhen(() => {
      if (canCalculateProps) {
        const { eventStartDateColumnIndex, eventStartDateRowIndex } = baseResizingInfo;
        const shouldUpdate = !isDraggingCanceled && (currentGridPos.rowIndex === eventStartDateRowIndex && currentGridPos.columnIndex >= eventStartDateColumnIndex || currentGridPos.rowIndex > eventStartDateRowIndex);
        if (shouldUpdate) {
          const targetEndDate = dateMatrix[currentGridPos.rowIndex][currentGridPos.columnIndex];
          eventBus.fire("beforeUpdateEvent", {
            event: resizingStartUIModel.model.toEventObject(),
            changes: {
              end: targetEndDate
            }
          });
        }
      }
      clearStates();
    }, isDraggingEnd);
    return guideProps;
  }
  function ResizingGuideByRow({
    dateMatrix,
    cellWidthMap,
    gridPositionFinder,
    renderedUIModels,
    rowIndex
  }) {
    const resizingGuideProps = useDayGridMonthEventResize({
      dateMatrix,
      gridPositionFinder,
      cellWidthMap,
      renderedUIModels,
      rowIndex
    });
    if (isNil(resizingGuideProps)) {
      return null;
    }
    const [uiModel, resizingWidth] = resizingGuideProps;
    return /* @__PURE__ */ y$3("div", {
      className: cls("weekday-events")
    }, /* @__PURE__ */ y$3(HorizontalEvent, {
      key: `resizing-event-${uiModel.cid()}`,
      uiModel,
      eventHeight: MONTH_EVENT_HEIGHT,
      headerHeight: MONTH_CELL_PADDING_TOP + MONTH_CELL_BAR_HEIGHT,
      resizingWidth
    }));
  }
  const TOTAL_PERCENT_HEIGHT = 100;
  function useCellContentAreaHeight(eventHeight) {
    const visibleEventCount = useStore(monthVisibleEventCountSelector);
    const { headerHeight: themeHeaderHeight, footerHeight: themeFooterHeight } = useTheme(monthGridCellSelector);
    const ref = F$2(null);
    const [cellContentAreaHeight, setCellContentAreaHeight] = p$2(0);
    _$2(() => {
      if (ref.current) {
        const rowHeight = getSize(ref.current).height;
        const headerHeight = MONTH_CELL_PADDING_TOP + (themeHeaderHeight != null ? themeHeaderHeight : MONTH_CELL_BAR_HEIGHT);
        const footerHeight = themeFooterHeight != null ? themeFooterHeight : 0;
        const baseContentAreaHeight = rowHeight - headerHeight - footerHeight;
        const visibleEventCountHeight = visibleEventCount * (eventHeight + MONTH_EVENT_MARGIN_TOP);
        setCellContentAreaHeight(Math.min(baseContentAreaHeight, visibleEventCountHeight));
      }
    }, [themeFooterHeight, themeHeaderHeight, eventHeight, visibleEventCount]);
    return { ref, cellContentAreaHeight };
  }
  function DayGridMonth({ dateMatrix = [], rowInfo = [], cellWidthMap = [] }) {
    const [gridContainer, setGridContainerRef] = useDOMNode();
    const calendar = useStore(calendarSelector);
    const { ref, cellContentAreaHeight } = useCellContentAreaHeight(MONTH_EVENT_HEIGHT);
    const { eventFilter, month: monthOptions, isReadOnly } = useStore(optionsSelector);
    const { narrowWeekend, startDayOfWeek } = monthOptions;
    const rowHeight = TOTAL_PERCENT_HEIGHT / dateMatrix.length;
    const gridPositionFinder = q$1(
      () => createGridPositionFinder({
        container: gridContainer,
        rowsCount: dateMatrix.length,
        columnsCount: dateMatrix[0].length,
        narrowWeekend,
        startDayOfWeek
      }),
      [dateMatrix, gridContainer, narrowWeekend, startDayOfWeek]
    );
    const calendarData = useCalendarData(calendar, eventFilter);
    const renderedEventUIModels = q$1(
      () => dateMatrix.map((week) => getRenderedEventUIModels(week, calendarData, narrowWeekend)),
      [calendarData, dateMatrix, narrowWeekend]
    );
    const onMouseDown = useGridSelection({
      type: "dayGridMonth",
      gridPositionFinder,
      dateCollection: dateMatrix,
      dateGetter: dayGridMonthSelectionHelper.getDateFromCollection,
      selectionSorter: dayGridMonthSelectionHelper.sortSelection
    });
    return /* @__PURE__ */ y$3("div", {
      ref: setGridContainerRef,
      onMouseDown: passConditionalProp(!isReadOnly, onMouseDown),
      className: cls("month-daygrid")
    }, dateMatrix.map((week, rowIndex) => {
      const { uiModels, gridDateEventModelMap } = renderedEventUIModels[rowIndex];
      return /* @__PURE__ */ y$3("div", {
        key: `dayGrid-events-${rowIndex}`,
        className: cls("month-week-item"),
        style: { height: toPercent(rowHeight) },
        ref
      }, /* @__PURE__ */ y$3("div", {
        className: cls("weekday")
      }, /* @__PURE__ */ y$3(GridRow, {
        gridDateEventModelMap,
        week,
        rowInfo,
        contentAreaHeight: cellContentAreaHeight
      }), /* @__PURE__ */ y$3(MonthEvents, {
        name: "month",
        events: uiModels,
        contentAreaHeight: cellContentAreaHeight,
        eventHeight: MONTH_EVENT_HEIGHT,
        className: cls("weekday-events")
      }), /* @__PURE__ */ y$3(GridSelectionByRow, {
        weekDates: week,
        narrowWeekend,
        rowIndex
      }), /* @__PURE__ */ y$3(AccumulatedGridSelection, {
        rowIndex,
        weekDates: week,
        narrowWeekend
      })), /* @__PURE__ */ y$3(ResizingGuideByRow, {
        dateMatrix,
        gridPositionFinder,
        rowIndex,
        cellWidthMap,
        renderedUIModels: renderedEventUIModels
      }), /* @__PURE__ */ y$3(MovingEventShadow, {
        dateMatrix,
        gridPositionFinder,
        rowIndex,
        rowInfo
      }));
    }));
  }
  function getMonthDayNames(options) {
    const { dayNames, startDayOfWeek, workweek } = options.month;
    const dayIndices = [...Array(7)].map((_2, i2) => (startDayOfWeek + i2) % 7);
    const monthDayNames = dayIndices.map((i2) => ({
      day: i2,
      label: capitalize(dayNames[i2])
    }));
    return monthDayNames.filter((dayNameInfo) => workweek ? !isWeekend(dayNameInfo.day) : true);
  }
  function Month$1() {
    const options = useStore(optionsSelector);
    const { renderDate } = useStore(viewSelector);
    const dayNames = getMonthDayNames(options);
    const monthOptions = options.month;
    const { narrowWeekend, startDayOfWeek, workweek } = monthOptions;
    const dateMatrix = q$1(
      () => createDateMatrixOfMonth(renderDate, monthOptions),
      [monthOptions, renderDate]
    );
    const { rowStyleInfo, cellWidthMap } = q$1(
      () => getRowStyleInfo(dayNames.length, narrowWeekend, startDayOfWeek, workweek),
      [dayNames.length, narrowWeekend, startDayOfWeek, workweek]
    );
    const rowInfo = rowStyleInfo.map((cellStyleInfo, index) => __spreadProps(__spreadValues({}, cellStyleInfo), {
      date: dateMatrix[0][index]
    }));
    return /* @__PURE__ */ y$3(Layout, {
      className: cls("month")
    }, /* @__PURE__ */ y$3(GridHeader, {
      type: "month",
      dayNames,
      options: monthOptions,
      rowStyleInfo
    }), /* @__PURE__ */ y$3(DayGridMonth, {
      dateMatrix,
      rowInfo,
      cellWidthMap
    }));
  }
  function useWeekViewState() {
    const options = useStore(optionsSelector);
    const calendar = useStore(calendarSelector);
    const { dayGridRows: gridRowLayout, lastPanelType } = useStore(weekViewLayoutSelector);
    const { renderDate } = useStore(viewSelector);
    return q$1(
      () => ({
        options,
        calendar,
        gridRowLayout,
        lastPanelType,
        renderDate
      }),
      [calendar, gridRowLayout, lastPanelType, options, renderDate]
    );
  }
  function Week$1() {
    var _a, _b;
    const { options, calendar, gridRowLayout, lastPanelType, renderDate } = useWeekViewState();
    const gridHeaderMarginLeft = useTheme(x$3((theme) => theme.week.dayGridLeft.width, []));
    const primaryTimezoneName = useStore(primaryTimezoneSelector);
    const [timePanel, setTimePanelRef] = useDOMNode();
    const weekOptions = options.week;
    const {
      narrowWeekend,
      startDayOfWeek,
      workweek,
      hourStart,
      hourEnd,
      eventView,
      taskView,
      timeStep
    } = weekOptions;
    const weekDates = q$1(() => getWeekDates(renderDate, weekOptions), [renderDate, weekOptions]);
    const dayNames = getDayNames(weekDates, (_b = (_a = options.week) == null ? void 0 : _a.dayNames) != null ? _b : []);
    const { rowStyleInfo, cellWidthMap } = getRowStyleInfo(
      weekDates.length,
      narrowWeekend,
      startDayOfWeek,
      workweek
    );
    const calendarData = useCalendarData(calendar, options.eventFilter);
    const eventByPanel = q$1(() => {
      const getFilterRange = () => {
        if (primaryTimezoneName === "Local") {
          return [toStartOfDay(first(weekDates)), toEndOfDay(last(weekDates))];
        }
        return [toStartOfDay(addDate(first(weekDates), -1)), toEndOfDay(addDate(last(weekDates), 1))];
      };
      const [weekStartDate, weekEndDate] = getFilterRange();
      return getWeekViewEvents(weekDates, calendarData, {
        narrowWeekend,
        hourStart,
        hourEnd,
        weekStartDate,
        weekEndDate
      });
    }, [calendarData, hourEnd, hourStart, narrowWeekend, primaryTimezoneName, weekDates]);
    const timeGridData = q$1(
      () => createTimeGridData(weekDates, {
        hourStart,
        hourEnd,
        narrowWeekend,
        timeStep
      }),
      [hourEnd, hourStart, narrowWeekend, weekDates, timeStep]
    );
    const activePanels = getActivePanels(taskView, eventView);
    const dayGridRows = activePanels.map((key) => {
      var _a2, _b2;
      if (key === "time") {
        return null;
      }
      const rowType = key;
      return /* @__PURE__ */ y$3(Panel, {
        name: rowType,
        key: rowType,
        resizable: rowType !== lastPanelType
      }, rowType === "allday" ? /* @__PURE__ */ y$3(AlldayGridRow, {
        events: eventByPanel[rowType],
        rowStyleInfo,
        gridColWidthMap: cellWidthMap,
        weekDates,
        height: (_a2 = gridRowLayout[rowType]) == null ? void 0 : _a2.height,
        options: weekOptions
      }) : /* @__PURE__ */ y$3(OtherGridRow, {
        category: rowType,
        events: eventByPanel[rowType],
        weekDates,
        height: (_b2 = gridRowLayout[rowType]) == null ? void 0 : _b2.height,
        options: weekOptions,
        gridColWidthMap: cellWidthMap
      }));
    });
    const hasTimePanel = q$1(() => activePanels.includes("time"), [activePanels]);
    useTimeGridScrollSync(timePanel, timeGridData.rows.length);
    const stickyTop = useTimezoneLabelsTop(timePanel);
    return /* @__PURE__ */ y$3(Layout, {
      className: cls("week-view"),
      autoAdjustPanels: true
    }, /* @__PURE__ */ y$3(Panel, {
      name: "week-view-day-names",
      initialHeight: WEEK_DAY_NAME_HEIGHT + WEEK_DAY_NAME_BORDER * 2
    }, /* @__PURE__ */ y$3(GridHeader, {
      type: "week",
      dayNames,
      marginLeft: gridHeaderMarginLeft,
      options: weekOptions,
      rowStyleInfo
    })), dayGridRows, hasTimePanel ? /* @__PURE__ */ y$3(Panel, {
      name: "time",
      autoSize: 1,
      ref: setTimePanelRef
    }, /* @__PURE__ */ y$3(TimeGrid, {
      events: eventByPanel.time,
      timeGridData
    }), /* @__PURE__ */ y$3(TimezoneLabels, {
      top: stickyTop
    })) : null);
  }
  const views = {
    month: Month$1,
    week: Week$1,
    day: Day$1
  };
  function Main() {
    const { currentView } = useStore(viewSelector);
    const CurrentViewComponent = q$1(() => views[currentView] || (() => null), [currentView]);
    return /* @__PURE__ */ y$3(CurrentViewComponent, null);
  }
  var n = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i, o = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/, i = /[\s\n\\/='"\0<>]/, l = /^xlink:?./, a = /["&<]/;
  function s(e2) {
    if (false === a.test(e2 += ""))
      return e2;
    for (var t2 = 0, r2 = 0, n2 = "", o2 = ""; r2 < e2.length; r2++) {
      switch (e2.charCodeAt(r2)) {
        case 34:
          o2 = "&quot;";
          break;
        case 38:
          o2 = "&amp;";
          break;
        case 60:
          o2 = "&lt;";
          break;
        default:
          continue;
      }
      r2 !== t2 && (n2 += e2.slice(t2, r2)), n2 += o2, t2 = r2 + 1;
    }
    return r2 !== t2 && (n2 += e2.slice(t2, r2)), n2;
  }
  var f = function(e2, t2) {
    return String(e2).replace(/(\n+)/g, "$1" + (t2 || "	"));
  }, u = function(e2, t2, r2) {
    return String(e2).length > (t2 || 40) || !r2 && -1 !== String(e2).indexOf("\n") || -1 !== String(e2).indexOf("<");
  }, c = {}, _ = /([A-Z])/g;
  function p(e2) {
    var t2 = "";
    for (var r2 in e2) {
      var o2 = e2[r2];
      null != o2 && "" !== o2 && (t2 && (t2 += " "), t2 += "-" == r2[0] ? r2 : c[r2] || (c[r2] = r2.replace(_, "-$1").toLowerCase()), t2 = "number" == typeof o2 && false === n.test(r2) ? t2 + ": " + o2 + "px;" : t2 + ": " + o2 + ";");
    }
    return t2 || void 0;
  }
  function d(e2, t2) {
    return Array.isArray(t2) ? t2.reduce(d, e2) : null != t2 && false !== t2 && e2.push(t2), e2;
  }
  function v() {
    this.__d = true;
  }
  function h(e2, t2) {
    return { __v: e2, context: t2, props: e2.props, setState: v, forceUpdate: v, __d: true, __h: [] };
  }
  function g(e2, t2) {
    var r2 = e2.contextType, n2 = r2 && t2[r2.__c];
    return null != r2 ? n2 ? n2.props.value : r2.__ : t2;
  }
  var y = [];
  function m(r2, n2, a2, c2, _2, v2) {
    if (null == r2 || "boolean" == typeof r2)
      return "";
    if ("object" != typeof r2)
      return "function" == typeof r2 ? "" : s(r2);
    var b2 = a2.pretty, x2 = b2 && "string" == typeof b2 ? b2 : "	";
    if (Array.isArray(r2)) {
      for (var k2 = "", S2 = 0; S2 < r2.length; S2++)
        b2 && S2 > 0 && (k2 += "\n"), k2 += m(r2[S2], n2, a2, c2, _2, v2);
      return k2;
    }
    if (void 0 !== r2.constructor)
      return "";
    var w2, C2 = r2.type, O2 = r2.props, j2 = false;
    if ("function" == typeof C2) {
      if (j2 = true, !a2.shallow || !c2 && false !== a2.renderRootComponent) {
        if (C2 === g$2) {
          var A2 = [];
          return d(A2, r2.props.children), m(A2, n2, a2, false !== a2.shallowHighOrder, _2, v2);
        }
        var F2, H2 = r2.__c = h(r2, n2);
        l$3.__b && l$3.__b(r2);
        var M2 = l$3.__r;
        if (C2.prototype && "function" == typeof C2.prototype.render) {
          var L2 = g(C2, n2);
          (H2 = r2.__c = new C2(O2, L2)).__v = r2, H2._dirty = H2.__d = true, H2.props = O2, null == H2.state && (H2.state = {}), null == H2._nextState && null == H2.__s && (H2._nextState = H2.__s = H2.state), H2.context = L2, C2.getDerivedStateFromProps ? H2.state = Object.assign({}, H2.state, C2.getDerivedStateFromProps(H2.props, H2.state)) : H2.componentWillMount && (H2.componentWillMount(), H2.state = H2._nextState !== H2.state ? H2._nextState : H2.__s !== H2.state ? H2.__s : H2.state), M2 && M2(r2), F2 = H2.render(H2.props, H2.state, H2.context);
        } else
          for (var T2 = g(C2, n2), E2 = 0; H2.__d && E2++ < 25; )
            H2.__d = false, M2 && M2(r2), F2 = C2.call(r2.__c, O2, T2);
        return H2.getChildContext && (n2 = Object.assign({}, n2, H2.getChildContext())), l$3.diffed && l$3.diffed(r2), m(F2, n2, a2, false !== a2.shallowHighOrder, _2, v2);
      }
      C2 = (w2 = C2).displayName || w2 !== Function && w2.name || function(e2) {
        var t2 = (Function.prototype.toString.call(e2).match(/^\s*function\s+([^( ]+)/) || "")[1];
        if (!t2) {
          for (var r3 = -1, n3 = y.length; n3--; )
            if (y[n3] === e2) {
              r3 = n3;
              break;
            }
          r3 < 0 && (r3 = y.push(e2) - 1), t2 = "UnnamedComponent" + r3;
        }
        return t2;
      }(w2);
    }
    var $2, D2, N2 = "<" + C2;
    if (O2) {
      var P2 = Object.keys(O2);
      a2 && true === a2.sortAttributes && P2.sort();
      for (var W2 = 0; W2 < P2.length; W2++) {
        var I2 = P2[W2], R2 = O2[I2];
        if ("children" !== I2) {
          if (!i.test(I2) && (a2 && a2.allAttributes || "key" !== I2 && "ref" !== I2 && "__self" !== I2 && "__source" !== I2)) {
            if ("defaultValue" === I2)
              I2 = "value";
            else if ("defaultChecked" === I2)
              I2 = "checked";
            else if ("defaultSelected" === I2)
              I2 = "selected";
            else if ("className" === I2) {
              if (void 0 !== O2.class)
                continue;
              I2 = "class";
            } else
              _2 && l.test(I2) && (I2 = I2.toLowerCase().replace(/^xlink:?/, "xlink:"));
            if ("htmlFor" === I2) {
              if (O2.for)
                continue;
              I2 = "for";
            }
            "style" === I2 && R2 && "object" == typeof R2 && (R2 = p(R2)), "a" === I2[0] && "r" === I2[1] && "boolean" == typeof R2 && (R2 = String(R2));
            var U2 = a2.attributeHook && a2.attributeHook(I2, R2, n2, a2, j2);
            if (U2 || "" === U2)
              N2 += U2;
            else if ("dangerouslySetInnerHTML" === I2)
              D2 = R2 && R2.__html;
            else if ("textarea" === C2 && "value" === I2)
              $2 = R2;
            else if ((R2 || 0 === R2 || "" === R2) && "function" != typeof R2) {
              if (!(true !== R2 && "" !== R2 || (R2 = I2, a2 && a2.xml))) {
                N2 = N2 + " " + I2;
                continue;
              }
              if ("value" === I2) {
                if ("select" === C2) {
                  v2 = R2;
                  continue;
                }
                "option" === C2 && v2 == R2 && void 0 === O2.selected && (N2 += " selected");
              }
              N2 = N2 + " " + I2 + '="' + s(R2) + '"';
            }
          }
        } else
          $2 = R2;
      }
    }
    if (b2) {
      var V2 = N2.replace(/\n\s*/, " ");
      V2 === N2 || ~V2.indexOf("\n") ? b2 && ~N2.indexOf("\n") && (N2 += "\n") : N2 = V2;
    }
    if (N2 += ">", i.test(C2))
      throw new Error(C2 + " is not a valid HTML tag name in " + N2);
    var q2, z2 = o.test(C2) || a2.voidElements && a2.voidElements.test(C2), Z2 = [];
    if (D2)
      b2 && u(D2) && (D2 = "\n" + x2 + f(D2, x2)), N2 += D2;
    else if (null != $2 && d(q2 = [], $2).length) {
      for (var B2 = b2 && ~N2.indexOf("\n"), G2 = false, J2 = 0; J2 < q2.length; J2++) {
        var K2 = q2[J2];
        if (null != K2 && false !== K2) {
          var Q2 = m(K2, n2, a2, true, "svg" === C2 || "foreignObject" !== C2 && _2, v2);
          if (b2 && !B2 && u(Q2) && (B2 = true), Q2)
            if (b2) {
              var X2 = Q2.length > 0 && "<" != Q2[0];
              G2 && X2 ? Z2[Z2.length - 1] += Q2 : Z2.push(Q2), G2 = X2;
            } else
              Z2.push(Q2);
        }
      }
      if (b2 && B2)
        for (var Y2 = Z2.length; Y2--; )
          Z2[Y2] = "\n" + x2 + f(Z2[Y2], x2);
    }
    if (Z2.length || D2)
      N2 += Z2.join("");
    else if (a2 && a2.xml)
      return N2.substring(0, N2.length - 1) + " />";
    return !z2 || q2 || D2 ? (b2 && ~N2.indexOf("\n") && (N2 += "\n"), N2 = N2 + "</" + C2 + ">") : N2 = N2.replace(/>$/, " />"), N2;
  }
  var b = { shallow: true };
  S.render = S;
  var x = function(e2, t2) {
    return S(e2, t2, b);
  }, k = [];
  function S(n2, o2, i2) {
    o2 = o2 || {};
    var l2 = l$3.__s;
    l$3.__s = true;
    var a2, s2 = y$3(g$2, null);
    return s2.__k = [n2], a2 = i2 && (i2.pretty || i2.voidElements || i2.sortAttributes || i2.shallow || i2.allAttributes || i2.xml || i2.attributeHook) ? m(n2, o2, i2) : F(n2, o2, false, void 0, s2), l$3.__c && l$3.__c(n2, k), l$3.__s = l2, k.length = 0, a2;
  }
  function w(e2) {
    return null == e2 || "boolean" == typeof e2 ? null : "string" == typeof e2 || "number" == typeof e2 || "bigint" == typeof e2 ? y$3(null, null, e2) : e2;
  }
  function C(e2, t2) {
    return "className" === e2 ? "class" : "htmlFor" === e2 ? "for" : "defaultValue" === e2 ? "value" : "defaultChecked" === e2 ? "checked" : "defaultSelected" === e2 ? "selected" : t2 && l.test(e2) ? e2.toLowerCase().replace(/^xlink:?/, "xlink:") : e2;
  }
  function O(e2, t2) {
    return "style" === e2 && null != t2 && "object" == typeof t2 ? p(t2) : "a" === e2[0] && "r" === e2[1] && "boolean" == typeof t2 ? String(t2) : t2;
  }
  var j = Array.isArray, A = Object.assign;
  function F(r2, n2, l2, a2, f2) {
    if (null == r2 || true === r2 || false === r2 || "" === r2)
      return "";
    if ("object" != typeof r2)
      return "function" == typeof r2 ? "" : s(r2);
    if (j(r2)) {
      var u2 = "";
      f2.__k = r2;
      for (var c2 = 0; c2 < r2.length; c2++)
        u2 += F(r2[c2], n2, l2, a2, f2), r2[c2] = w(r2[c2]);
      return u2;
    }
    if (void 0 !== r2.constructor)
      return "";
    r2.__ = f2, l$3.__b && l$3.__b(r2);
    var _2 = r2.type, p2 = r2.props;
    if ("function" == typeof _2) {
      var d2;
      if (_2 === g$2)
        d2 = p2.children;
      else {
        d2 = _2.prototype && "function" == typeof _2.prototype.render ? function(e2, r3) {
          var n3 = e2.type, o2 = g(n3, r3), i2 = new n3(e2.props, o2);
          e2.__c = i2, i2.__v = e2, i2.__d = true, i2.props = e2.props, null == i2.state && (i2.state = {}), null == i2.__s && (i2.__s = i2.state), i2.context = o2, n3.getDerivedStateFromProps ? i2.state = A({}, i2.state, n3.getDerivedStateFromProps(i2.props, i2.state)) : i2.componentWillMount && (i2.componentWillMount(), i2.state = i2.__s !== i2.state ? i2.__s : i2.state);
          var l3 = l$3.__r;
          return l3 && l3(e2), i2.render(i2.props, i2.state, i2.context);
        }(r2, n2) : function(e2, r3) {
          var n3, o2 = h(e2, r3), i2 = g(e2.type, r3);
          e2.__c = o2;
          for (var l3 = l$3.__r, a3 = 0; o2.__d && a3++ < 25; )
            o2.__d = false, l3 && l3(e2), n3 = e2.type.call(o2, e2.props, i2);
          return n3;
        }(r2, n2);
        var v2 = r2.__c;
        v2.getChildContext && (n2 = A({}, n2, v2.getChildContext()));
      }
      var y2 = F(d2 = null != d2 && d2.type === g$2 && null == d2.key ? d2.props.children : d2, n2, l2, a2, r2);
      return l$3.diffed && l$3.diffed(r2), r2.__ = void 0, l$3.unmount && l$3.unmount(r2), y2;
    }
    var m2, b2, x2 = "<";
    if (x2 += _2, p2)
      for (var k2 in m2 = p2.children, p2) {
        var S2 = p2[k2];
        if (!("key" === k2 || "ref" === k2 || "__self" === k2 || "__source" === k2 || "children" === k2 || "className" === k2 && "class" in p2 || "htmlFor" === k2 && "for" in p2 || i.test(k2))) {
          if (S2 = O(k2 = C(k2, l2), S2), "dangerouslySetInnerHTML" === k2)
            b2 = S2 && S2.__html;
          else if ("textarea" === _2 && "value" === k2)
            m2 = S2;
          else if ((S2 || 0 === S2 || "" === S2) && "function" != typeof S2) {
            if (true === S2 || "" === S2) {
              S2 = k2, x2 = x2 + " " + k2;
              continue;
            }
            if ("value" === k2) {
              if ("select" === _2) {
                a2 = S2;
                continue;
              }
              "option" !== _2 || a2 != S2 || "selected" in p2 || (x2 += " selected");
            }
            x2 = x2 + " " + k2 + '="' + s(S2) + '"';
          }
        }
      }
    var H2 = x2;
    if (x2 += ">", i.test(_2))
      throw new Error(_2 + " is not a valid HTML tag name in " + x2);
    var M2 = "", L2 = false;
    if (b2)
      M2 += b2, L2 = true;
    else if ("string" == typeof m2)
      M2 += s(m2), L2 = true;
    else if (j(m2)) {
      r2.__k = m2;
      for (var T2 = 0; T2 < m2.length; T2++) {
        var E2 = m2[T2];
        if (m2[T2] = w(E2), null != E2 && false !== E2) {
          var $2 = F(E2, n2, "svg" === _2 || "foreignObject" !== _2 && l2, a2, r2);
          $2 && (M2 += $2, L2 = true);
        }
      }
    } else if (null != m2 && false !== m2 && true !== m2) {
      r2.__k = [w(m2)];
      var D2 = F(m2, n2, "svg" === _2 || "foreignObject" !== _2 && l2, a2, r2);
      D2 && (M2 += D2, L2 = true);
    }
    if (l$3.diffed && l$3.diffed(r2), r2.__ = void 0, l$3.unmount && l$3.unmount(r2), L2)
      x2 += M2;
    else if (o.test(_2))
      return H2 + " />";
    return x2 + "</" + _2 + ">";
  }
  S.shallowRender = x;
  function forEachOwnProperties$2(obj, iteratee, context) {
    var key;
    context = context || null;
    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (iteratee.call(context, obj[key], key, obj) === false) {
          break;
        }
      }
    }
  }
  var forEachOwnProperties_1 = forEachOwnProperties$2;
  var forEachOwnProperties$1 = forEachOwnProperties_1;
  function imagePing$1(url, trackingInfo) {
    var trackingElement = document.createElement("img");
    var queryString = "";
    forEachOwnProperties$1(trackingInfo, function(value, key) {
      queryString += "&" + key + "=" + value;
    });
    queryString = queryString.substring(1);
    trackingElement.src = url + "?" + queryString;
    trackingElement.style.display = "none";
    document.body.appendChild(trackingElement);
    document.body.removeChild(trackingElement);
    return trackingElement;
  }
  var imagePing_1 = imagePing$1;
  var isUndefined$1 = isUndefined_1;
  var imagePing = imagePing_1;
  var ms7days = 7 * 24 * 60 * 60 * 1e3;
  function isExpired(date2) {
    var now = new Date().getTime();
    return now - date2 > ms7days;
  }
  function sendHostname(appName, trackingId) {
    var url = "https://www.google-analytics.com/collect";
    var hostname = location.hostname;
    var hitType = "event";
    var eventCategory = "use";
    var applicationKeyForStorage = "TOAST UI " + appName + " for " + hostname + ": Statistics";
    var date2 = window.localStorage.getItem(applicationKeyForStorage);
    if (!isUndefined$1(window.tui) && window.tui.usageStatistics === false) {
      return;
    }
    if (date2 && !isExpired(date2)) {
      return;
    }
    window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());
    setTimeout(function() {
      if (document.readyState === "interactive" || document.readyState === "complete") {
        imagePing(url, {
          v: 1,
          t: hitType,
          tid: trackingId,
          cid: hostname,
          dp: hostname,
          dh: appName,
          el: appName,
          ec: eventCategory
        });
      }
    }, 1e3);
  }
  var sendHostname_1 = sendHostname;
  function CalendarContainer({ theme, store, eventBus, children }) {
    return /* @__PURE__ */ y$3(EventBusProvider, {
      value: eventBus
    }, /* @__PURE__ */ y$3(ThemeProvider, {
      store: theme
    }, /* @__PURE__ */ y$3(StoreProvider, {
      store
    }, /* @__PURE__ */ y$3(FloatingLayerProvider, null, children))));
  }
  const GA_TRACKING_ID = "UA-129951699-1";
  function extend$1(target, objects) {
    var hasOwnProp = Object.prototype.hasOwnProperty;
    var source, prop, i2, len;
    for (i2 = 1, len = arguments.length; i2 < len; i2 += 1) {
      source = arguments[i2];
      for (prop in source) {
        if (hasOwnProp.call(source, prop)) {
          target[prop] = source[prop];
        }
      }
    }
    return target;
  }
  var extend_1 = extend$1;
  function isNull$1(obj) {
    return obj === null;
  }
  var isNull_1 = isNull$1;
  var isUndefined = isUndefined_1;
  var isNull = isNull_1;
  function isExisty$1(param) {
    return !isUndefined(param) && !isNull(param);
  }
  var isExisty_1 = isExisty$1;
  function isArray$2(obj) {
    return obj instanceof Array;
  }
  var isArray_1 = isArray$2;
  function isFunction$1(obj) {
    return obj instanceof Function;
  }
  var isFunction_1 = isFunction$1;
  function forEachArray$1(arr, iteratee, context) {
    var index = 0;
    var len = arr.length;
    context = context || null;
    for (; index < len; index += 1) {
      if (iteratee.call(context, arr[index], index, arr) === false) {
        break;
      }
    }
  }
  var forEachArray_1 = forEachArray$1;
  var isArray$1 = isArray_1;
  var forEachArray = forEachArray_1;
  var forEachOwnProperties = forEachOwnProperties_1;
  function forEach$1(obj, iteratee, context) {
    if (isArray$1(obj)) {
      forEachArray(obj, iteratee, context);
    } else {
      forEachOwnProperties(obj, iteratee, context);
    }
  }
  var forEach_1 = forEach$1;
  var extend = extend_1;
  var isExisty = isExisty_1;
  var isString = isString_1;
  var isObject = isObject_1;
  var isArray = isArray_1;
  var isFunction = isFunction_1;
  var forEach = forEach_1;
  var R_EVENTNAME_SPLIT = /\s+/g;
  function CustomEvents() {
    this.events = null;
    this.contexts = null;
  }
  CustomEvents.mixin = function(func) {
    extend(func.prototype, CustomEvents.prototype);
  };
  CustomEvents.prototype._getHandlerItem = function(handler, context) {
    var item = { handler };
    if (context) {
      item.context = context;
    }
    return item;
  };
  CustomEvents.prototype._safeEvent = function(eventName) {
    var events = this.events;
    var byName;
    if (!events) {
      events = this.events = {};
    }
    if (eventName) {
      byName = events[eventName];
      if (!byName) {
        byName = [];
        events[eventName] = byName;
      }
      events = byName;
    }
    return events;
  };
  CustomEvents.prototype._safeContext = function() {
    var context = this.contexts;
    if (!context) {
      context = this.contexts = [];
    }
    return context;
  };
  CustomEvents.prototype._indexOfContext = function(ctx) {
    var context = this._safeContext();
    var index = 0;
    while (context[index]) {
      if (ctx === context[index][0]) {
        return index;
      }
      index += 1;
    }
    return -1;
  };
  CustomEvents.prototype._memorizeContext = function(ctx) {
    var context, index;
    if (!isExisty(ctx)) {
      return;
    }
    context = this._safeContext();
    index = this._indexOfContext(ctx);
    if (index > -1) {
      context[index][1] += 1;
    } else {
      context.push([ctx, 1]);
    }
  };
  CustomEvents.prototype._forgetContext = function(ctx) {
    var context, contextIndex;
    if (!isExisty(ctx)) {
      return;
    }
    context = this._safeContext();
    contextIndex = this._indexOfContext(ctx);
    if (contextIndex > -1) {
      context[contextIndex][1] -= 1;
      if (context[contextIndex][1] <= 0) {
        context.splice(contextIndex, 1);
      }
    }
  };
  CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
    var events = this._safeEvent(eventName);
    this._memorizeContext(context);
    events.push(this._getHandlerItem(handler, context));
  };
  CustomEvents.prototype.on = function(eventName, handler, context) {
    var self2 = this;
    if (isString(eventName)) {
      eventName = eventName.split(R_EVENTNAME_SPLIT);
      forEach(eventName, function(name) {
        self2._bindEvent(name, handler, context);
      });
    } else if (isObject(eventName)) {
      context = handler;
      forEach(eventName, function(func, name) {
        self2.on(name, func, context);
      });
    }
  };
  CustomEvents.prototype.once = function(eventName, handler, context) {
    var self2 = this;
    if (isObject(eventName)) {
      context = handler;
      forEach(eventName, function(func, name) {
        self2.once(name, func, context);
      });
      return;
    }
    function onceHandler() {
      handler.apply(context, arguments);
      self2.off(eventName, onceHandler, context);
    }
    this.on(eventName, onceHandler, context);
  };
  CustomEvents.prototype._spliceMatches = function(arr, predicate) {
    var i2 = 0;
    var len;
    if (!isArray(arr)) {
      return;
    }
    for (len = arr.length; i2 < len; i2 += 1) {
      if (predicate(arr[i2]) === true) {
        arr.splice(i2, 1);
        len -= 1;
        i2 -= 1;
      }
    }
  };
  CustomEvents.prototype._matchHandler = function(handler) {
    var self2 = this;
    return function(item) {
      var needRemove = handler === item.handler;
      if (needRemove) {
        self2._forgetContext(item.context);
      }
      return needRemove;
    };
  };
  CustomEvents.prototype._matchContext = function(context) {
    var self2 = this;
    return function(item) {
      var needRemove = context === item.context;
      if (needRemove) {
        self2._forgetContext(item.context);
      }
      return needRemove;
    };
  };
  CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
    var self2 = this;
    return function(item) {
      var matchHandler = handler === item.handler;
      var matchContext = context === item.context;
      var needRemove = matchHandler && matchContext;
      if (needRemove) {
        self2._forgetContext(item.context);
      }
      return needRemove;
    };
  };
  CustomEvents.prototype._offByEventName = function(eventName, handler) {
    var self2 = this;
    var andByHandler = isFunction(handler);
    var matchHandler = self2._matchHandler(handler);
    eventName = eventName.split(R_EVENTNAME_SPLIT);
    forEach(eventName, function(name) {
      var handlerItems = self2._safeEvent(name);
      if (andByHandler) {
        self2._spliceMatches(handlerItems, matchHandler);
      } else {
        forEach(handlerItems, function(item) {
          self2._forgetContext(item.context);
        });
        self2.events[name] = [];
      }
    });
  };
  CustomEvents.prototype._offByHandler = function(handler) {
    var self2 = this;
    var matchHandler = this._matchHandler(handler);
    forEach(this._safeEvent(), function(handlerItems) {
      self2._spliceMatches(handlerItems, matchHandler);
    });
  };
  CustomEvents.prototype._offByObject = function(obj, handler) {
    var self2 = this;
    var matchFunc;
    if (this._indexOfContext(obj) < 0) {
      forEach(obj, function(func, name) {
        self2.off(name, func);
      });
    } else if (isString(handler)) {
      matchFunc = this._matchContext(obj);
      self2._spliceMatches(this._safeEvent(handler), matchFunc);
    } else if (isFunction(handler)) {
      matchFunc = this._matchHandlerAndContext(handler, obj);
      forEach(this._safeEvent(), function(handlerItems) {
        self2._spliceMatches(handlerItems, matchFunc);
      });
    } else {
      matchFunc = this._matchContext(obj);
      forEach(this._safeEvent(), function(handlerItems) {
        self2._spliceMatches(handlerItems, matchFunc);
      });
    }
  };
  CustomEvents.prototype.off = function(eventName, handler) {
    if (isString(eventName)) {
      this._offByEventName(eventName, handler);
    } else if (!arguments.length) {
      this.events = {};
      this.contexts = [];
    } else if (isFunction(eventName)) {
      this._offByHandler(eventName);
    } else if (isObject(eventName)) {
      this._offByObject(eventName, handler);
    }
  };
  CustomEvents.prototype.fire = function(eventName) {
    this.invoke.apply(this, arguments);
  };
  CustomEvents.prototype.invoke = function(eventName) {
    var events, args, index, item;
    if (!this.hasListener(eventName)) {
      return true;
    }
    events = this._safeEvent(eventName);
    args = Array.prototype.slice.call(arguments, 1);
    index = 0;
    while (events[index]) {
      item = events[index];
      if (item.handler.apply(item.context, args) === false) {
        return false;
      }
      index += 1;
    }
    return true;
  };
  CustomEvents.prototype.hasListener = function(eventName) {
    return this.getListenerLength(eventName) > 0;
  };
  CustomEvents.prototype.getListenerLength = function(eventName) {
    var events = this._safeEvent(eventName);
    return events.length;
  };
  var customEvents = CustomEvents;
  class EventBusImpl extends customEvents {
    on(eventName, handler) {
      super.on(eventName, handler);
      return this;
    }
    off(eventName, handler) {
      super.off(eventName, handler);
      return this;
    }
    fire(eventName, ...args) {
      super.fire(eventName, ...args);
      return this;
    }
    once(eventName, handler) {
      super.once(eventName, handler);
      return this;
    }
  }
  class CalendarCore {
    constructor(container, options = {}) {
      var _a;
      this.container = isString_1(container) ? (_a = document == null ? void 0 : document.querySelector(container)) != null ? _a : null : container;
      this.theme = initThemeStore(options.theme);
      this.eventBus = new EventBusImpl();
      this.store = initCalendarStore(options);
      this.renderRange = this.calculateRenderRange(toStartOfDay());
      addAttributeHooks();
      if (this.getStoreState().options.usageStatistics === true) {
        sendHostname_1("calendar", GA_TRACKING_ID);
      }
    }
    getStoreState(group) {
      const state = this.store.getState();
      return group ? state[group] : state;
    }
    getStoreDispatchers(group) {
      const dispatchers = this.store.getState().dispatch;
      return group ? dispatchers[group] : dispatchers;
    }
    destroy() {
      if (this.container) {
        vn(this.container);
      }
      this.store.clearListeners();
      this.theme.clearListeners();
      this.eventBus.off();
      removeAttributeHooks();
      for (const key in this) {
        if (this.hasOwnProperty(key)) {
          delete this[key];
        }
      }
    }
    calculateMonthRenderDate({
      renderDate,
      offset,
      monthOptions
    }) {
      let newRenderDate = new TZDate(renderDate);
      const { visibleWeeksCount } = monthOptions;
      if (visibleWeeksCount > 0) {
        newRenderDate = addDate(newRenderDate, offset * 7 * visibleWeeksCount);
      } else {
        newRenderDate = addMonths(newRenderDate, offset);
      }
      const dateMatrix = createDateMatrixOfMonth(newRenderDate, monthOptions);
      const [[start]] = dateMatrix;
      const end = last(last(dateMatrix));
      return {
        renderDate: newRenderDate,
        renderRange: { start, end }
      };
    }
    calculateWeekRenderDate({
      renderDate,
      offset,
      weekOptions
    }) {
      const newRenderDate = new TZDate(renderDate);
      newRenderDate.addDate(offset * 7);
      const weekDates = getWeekDates(newRenderDate, weekOptions);
      const [start] = weekDates;
      const end = last(weekDates);
      return {
        renderDate: newRenderDate,
        renderRange: { start, end }
      };
    }
    calculateDayRenderDate({ renderDate, offset }) {
      const newRenderDate = new TZDate(renderDate);
      newRenderDate.addDate(offset);
      const start = toStartOfDay(newRenderDate);
      const end = toEndOfDay(newRenderDate);
      return {
        renderDate: newRenderDate,
        renderRange: { start, end }
      };
    }
    move(offset) {
      if (isNil(offset)) {
        return;
      }
      const { currentView, renderDate } = this.getStoreState().view;
      const { options } = this.getStoreState();
      const { setRenderDate } = this.getStoreDispatchers().view;
      const newRenderDate = new TZDate(renderDate);
      let calculatedRenderDate = {
        renderDate: newRenderDate,
        renderRange: { start: new TZDate(newRenderDate), end: new TZDate(newRenderDate) }
      };
      if (currentView === "month") {
        calculatedRenderDate = this.calculateMonthRenderDate({
          renderDate,
          offset,
          monthOptions: options.month
        });
      } else if (currentView === "week") {
        calculatedRenderDate = this.calculateWeekRenderDate({
          renderDate,
          offset,
          weekOptions: options.week
        });
      } else if (currentView === "day") {
        calculatedRenderDate = this.calculateDayRenderDate({ renderDate, offset });
      }
      setRenderDate(calculatedRenderDate.renderDate);
      this.renderRange = calculatedRenderDate.renderRange;
    }
    createEvents(events) {
      const { createEvents: createEvents2 } = this.getStoreDispatchers("calendar");
      createEvents2(events);
    }
    getEventModel(eventId, calendarId) {
      const { events } = this.getStoreState("calendar");
      return events.find(
        ({ id, calendarId: eventCalendarId }) => id === eventId && eventCalendarId === calendarId
      );
    }
    getEvent(eventId, calendarId) {
      var _a, _b;
      return (_b = (_a = this.getEventModel(eventId, calendarId)) == null ? void 0 : _a.toEventObject()) != null ? _b : null;
    }
    updateEvent(eventId, calendarId, changes) {
      const { updateEvent: updateEvent2 } = this.getStoreDispatchers("calendar");
      const event = this.getEventModel(eventId, calendarId);
      if (event) {
        updateEvent2({ event, eventData: changes });
      }
    }
    deleteEvent(eventId, calendarId) {
      const { deleteEvent: deleteEvent2 } = this.getStoreDispatchers("calendar");
      const event = this.getEventModel(eventId, calendarId);
      if (event) {
        deleteEvent2(event);
      }
    }
    setCalendarVisibility(calendarId, isVisible) {
      const { setCalendarVisibility } = this.getStoreDispatchers("calendar");
      const calendarIds = Array.isArray(calendarId) ? calendarId : [calendarId];
      setCalendarVisibility(calendarIds, isVisible);
    }
    render() {
      if (isPresent(this.container)) {
        N$2(
          /* @__PURE__ */ y$3(CalendarContainer, {
            theme: this.theme,
            store: this.store,
            eventBus: this.eventBus
          }, this.getComponent()),
          this.container
        );
      }
      return this;
    }
    renderToString() {
      return S(
        /* @__PURE__ */ y$3(CalendarContainer, {
          theme: this.theme,
          store: this.store,
          eventBus: this.eventBus
        }, this.getComponent())
      );
    }
    clear() {
      const { clearEvents: clearEvents2 } = this.getStoreDispatchers("calendar");
      clearEvents2();
    }
    scrollToNow(scrollBehavior = "auto") {
      this.eventBus.fire("scrollToNow", scrollBehavior);
    }
    calculateRenderRange(renderDate) {
      const { currentView } = this.getStoreState().view;
      const { options } = this.getStoreState();
      const newRenderDate = new TZDate(renderDate);
      let newRenderRange = { start: new TZDate(newRenderDate), end: new TZDate(newRenderDate) };
      if (currentView === "month") {
        newRenderRange = this.calculateMonthRenderDate({
          renderDate,
          offset: 0,
          monthOptions: options.month
        }).renderRange;
      } else if (currentView === "week") {
        newRenderRange = this.calculateWeekRenderDate({
          renderDate,
          offset: 0,
          weekOptions: options.week
        }).renderRange;
      } else if (currentView === "day") {
        newRenderRange = this.calculateDayRenderDate({ renderDate, offset: 0 }).renderRange;
      }
      return newRenderRange;
    }
    today() {
      const { setRenderDate } = this.getStoreDispatchers().view;
      const today = new TZDate();
      setRenderDate(today);
      this.renderRange = this.calculateRenderRange(today);
    }
    setDate(date2) {
      const { setRenderDate } = this.getStoreDispatchers("view");
      const dateToChange = new TZDate(date2);
      setRenderDate(dateToChange);
      this.renderRange = this.calculateRenderRange(dateToChange);
    }
    next() {
      this.move(1);
    }
    prev() {
      this.move(-1);
    }
    setCalendarColor(calendarId, colorOptions) {
      const { setCalendarColor } = this.getStoreDispatchers().calendar;
      setCalendarColor(calendarId, colorOptions);
    }
    changeView(viewName) {
      const { changeView } = this.getStoreDispatchers("view");
      changeView(viewName);
      this.renderRange = this.calculateRenderRange(this.getDate());
    }
    getElement(eventId, calendarId) {
      const event = this.getEvent(eventId, calendarId);
      if (event && this.container) {
        return this.container.querySelector(
          `[data-event-id="${eventId}"][data-calendar-id="${calendarId}"]`
        );
      }
      return null;
    }
    setTheme(theme) {
      const { setTheme } = this.theme.getState().dispatch;
      setTheme(theme);
    }
    getOptions() {
      const { options, template } = this.getStoreState();
      const _a = this.theme.getState(), theme = __objRest(_a, ["dispatch"]);
      return __spreadProps(__spreadValues({}, options), {
        template,
        theme
      });
    }
    setOptions(options) {
      const _a = options, { theme, template } = _a, restOptions = __objRest(_a, ["theme", "template"]);
      const { setTheme } = this.theme.getState().dispatch;
      const {
        options: { setOptions },
        template: { setTemplate }
      } = this.getStoreDispatchers();
      if (isPresent(theme)) {
        setTheme(theme);
      }
      if (isPresent(template)) {
        setTemplate(template);
      }
      setOptions(restOptions);
    }
    getDate() {
      const { renderDate } = this.getStoreState().view;
      return renderDate;
    }
    getDateRangeStart() {
      return this.renderRange.start;
    }
    getDateRangeEnd() {
      return this.renderRange.end;
    }
    getViewName() {
      const { currentView } = this.getStoreState("view");
      return currentView;
    }
    setCalendars(calendars) {
      const { setCalendars } = this.getStoreDispatchers().calendar;
      setCalendars(calendars);
    }
    openFormPopup(event) {
      const { showFormPopup } = this.getStoreDispatchers().popup;
      const eventModel = new EventModel(event);
      const { title, location: location2, start, end, isAllday: isAllday2, isPrivate, state: eventState } = eventModel;
      showFormPopup({
        isCreationPopup: true,
        event: eventModel,
        title,
        location: location2,
        start,
        end,
        isAllday: isAllday2,
        isPrivate,
        eventState
      });
    }
    clearGridSelections() {
      const { clearAll } = this.getStoreDispatchers().gridSelection;
      clearAll();
    }
    fire(eventName, ...args) {
      this.eventBus.fire(eventName, ...args);
      return this;
    }
    off(eventName, handler) {
      this.eventBus.off(eventName, handler);
      return this;
    }
    on(eventName, handler) {
      this.eventBus.on(eventName, handler);
      return this;
    }
    once(eventName, handler) {
      this.eventBus.once(eventName, handler);
      return this;
    }
  }
  function isValidViewType(viewType) {
    return !!Object.values(VIEW_TYPE).find((type) => type === viewType);
  }
  class Calendar extends CalendarCore {
    constructor(container, options = {}) {
      super(container, options);
      const { defaultView = "week" } = options;
      if (!isValidViewType(defaultView)) {
        throw new InvalidViewTypeError(defaultView);
      }
      this.render();
    }
    getComponent() {
      return /* @__PURE__ */ y$3(Main, null);
    }
  }

  /*global wp_ajax_object, Snap, Calendar */

  const bootstrap = {
    Alert,
    Button,
    Carousel,
    Collapse,
    Dropdown,
    Modal,
    Offcanvas,
    Popover,
    ScrollSpy,
    Tab,
    Toast,
    Tooltip
  };
  class n4dCalendar {
    constructor() {}
    init() {
      const calendars = document.querySelectorAll('.calendar');
      if (calendars) {
        calendars.forEach(item => {
          const calendar = new Calendar(item, {
            defaultView: 'month',
            isReadOnly: true,
            month: {
              dayNames: ['S', 'M', 'T', 'W', 'T', 'F', 'S']
            },
            theme: {
              month: {
                dayExceptThisMonth: {
                  color: '#FFF'
                },
                weekend: {
                  color: 'red'
                },
                holidayExceptThisMonth: {
                  color: '#FFF'
                }
              },
              common: {
                holiday: {
                  color: 'black'
                }
              }
            }
          });
          const cal_date = item.dataset.year + '-' + item.dataset.month + '-01';
          calendar.setDate(cal_date);
          const days = calendarApp.getDays(cal_date);
          if (days) {
            const excludes_el = document.querySelector("#billing-excludes");
            const excludes = excludes_el ? excludes_el.value : [];
            console.log(excludes);
            days.forEach((d, index) => {
              let year = d.getFullYear();
              let month = d.getMonth() + 1;
              let day = d.getDate().toString();
              if (month.toString().length < 2) month = '0' + month;
              if (day.length < 2) day = '0' + day;
              let date = "".concat(year, "-").concat(month, "-").concat(day);
              if (!excludes.includes(date)) {
                calendar.createEvents([{
                  id: index,
                  calendarId: 'cal1',
                  title: 'Billing',
                  start: "".concat(date, "T10:00:00"),
                  end: "".concat(date, "T11:00:00"),
                  location: 'Meeting Room A',
                  attendees: ['A', 'B', 'C'],
                  category: 'allday',
                  state: 'Busy',
                  isReadOnly: true,
                  color: '#fff',
                  backgroundColor: '#ccc',
                  customStyle: {
                    fontStyle: 'italic',
                    fontSize: '15px'
                  }
                } // EventObject
                ]);
              }
            });
          }
        });
        setTimeout(() => {
          const events = document.querySelectorAll('.toastui-calendar-grid-cell-more-events');
          events.forEach(event => {
            event.parentElement.classList.add("active");
          });
        }, 100);
        const billingSelectMonth = document.querySelectorAll('.billing-select-month');
        billingSelectMonth.forEach(select => {
          select.addEventListener("change", e => {
            const carousel = new bootstrap.Carousel(e.target.dataset.target);
            carousel.to(e.target.value - 1);
          });
        });
        const carouselCalendars = document.querySelector("#carouselCalendars");
        if (carouselCalendars) {
          carouselCalendars.addEventListener('slid.bs.carousel', event => {
            const trigger = document.querySelector('.billing-select-month[data-target="#carouselCalendars"]');
            if (trigger) {
              if (trigger.value !== event.to) {
                trigger.value = event.to + 1 > 6 ? 6 : event.to + 1;
              }
            }
          });
        }
      }
    }
    getDays(date) {
      var d = new Date(date);
      var month = d.getMonth(),
        days = [];
      d.setDate(1);

      // Get the first Monday in the month
      while (d.getDay() !== 1) {
        d.setDate(d.getDate() + 1);
      }
      // Get all the other Mondays in the month
      while (d.getMonth() === month) {
        days.push(new Date(d.getTime()));
        d.setDate(d.getDate() + 7);
      }
      d = new Date(date);
      d.setDate(1);
      while (d.getDay() !== 2) {
        d.setDate(d.getDate() + 1);
      }
      while (d.getMonth() === month) {
        days.push(new Date(d.getTime()));
        d.setDate(d.getDate() + 7);
      }
      return days;
    }
  }
  //Create Site APP
  let calendarApp = new n4dCalendar();
  document.addEventListener('readystatechange', function (evt) {
    switch (evt.target.readyState) {
      case "complete":
        calendarApp.init();
        break;
    }
  }, false);

})();
//# sourceMappingURL=calendar.min.js.map
